; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\CommonControl\PictureEx.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FH@BMBEKJNI@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ?IsDrawPointChanged@CPictureEx@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPictureEx@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CArray@VCRect@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$CArray@VCRect@@V1@@@QAEHVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CArray@VCRect@@V1@@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@?$CArray@VCRect@@V1@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@?$CArray@VCRect@@V1@@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAtGrow@?$CArray@VCRect@@V1@@@QAEXHVCRect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$DumpElements@VCRect@@@@YGXAAVCDumpContext@@PBVCRect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3CPictureEx@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CPictureEx@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CPictureEx@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCPictureEx@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$CArray@VCRect@@V1@@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4CPictureEx@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$CArray@VCRect@@V1@@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CArray@VCRect@@V1@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FG@LDNDNCJM@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R0PAVCFileException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??1AFX_EXCEPTION_LINK@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CPictureEx@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_THIS_FILE DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
_DATA	ENDS
CONST	SEGMENT
$SG187843 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG187844 DB	'Load: Error locking memory', 0aH, 00H
$SG187847 DB	'GIF', 00H
$SG187849 DB	'87a', 00H
$SG187850 DB	'89a', 00H
$SG188041 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG188042 DB	'Call one of the CPictureEx::Load() member functions befo'
	DB	're calling Draw()', 0aH, 00H
	ORG $+1
$SG188048 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG188049 DB	'Draw: Couldn''t start a GIF animation thread', 0aH, 00H
	ORG $+3
$SG188071 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG188072 DB	'Load (file): Error opening file %s', 0aH, 00H
$SG188077 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG188078 DB	'Load (file): Error allocating memory', 0aH, 00H
	ORG $+2
$SG188084 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG188085 DB	'Load (file): Error locking memory', 0aH, 00H
	ORG $+1
$SG188093 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG188094 DB	'Load (file): An exception occured while reading the file'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG188110 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG188111 DB	'Load (resource): Error loading resource %s', 0aH, 00H
$SG188116 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG188117 DB	'Load (resource): Error allocating memory', 0aH, 00H
	ORG $+2
$SG188125 DB	'.\src\Gui\CommonControl\PictureEx.cpp', 00H
	ORG $+2
$SG188126 DB	'Load (resource): Error locking memory', 0aH, 00H
	ORG $+5
$SG188738 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188752 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188768 DB	'with ', 00H
	ORG $+2
$SG188769 DB	' elements', 00H
	ORG $+2
$SG188771 DB	0aH, 00H
	ORG $+2
$SG188778 DB	0aH, 00H
	ORG $+6
$SG188786 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188788 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188791 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188793 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188795 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188798 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188974 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188976 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188991 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG188998 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG189034 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG189038 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG189048 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG189068 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG189070 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG189077 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
	ORG $+1
$SG189102 DB	'D:\Program Files (x86)\Microsoft Visual Studio .NET 2003'
	DB	'\Vc7\atlmfc\include\afxtempl.h', 00H
CONST	ENDS
PUBLIC	??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
PUBLIC	??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
PUBLIC	??_7CPictureEx@@6B@				; CPictureEx::`vftable'
PUBLIC	??_GCPictureEx@@UAEPAXI@Z			; CPictureEx::`scalar deleting destructor'
PUBLIC	??0?$CArray@VCRect@@V1@@@QAE@XZ			; CArray<CRect,CRect>::CArray<CRect,CRect>
PUBLIC	??_R4CPictureEx@@6B@				; CPictureEx::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPictureEx@@@8				; CPictureEx `RTTI Type Descriptor'
PUBLIC	??_R3CPictureEx@@8				; CPictureEx::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPictureEx@@8				; CPictureEx::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CPictureEx@@8			; CPictureEx::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??0CPictureEx@@QAE@_N@Z				; CPictureEx::CPictureEx
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??_ECPictureEx@@UAEPAXI@Z:NEAR			; CPictureEx::`vector deleting destructor'
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	??2CObject@@SGPAXIPBDH@Z:NEAR			; CObject::operator new
EXTRN	??3CObject@@SGXPAXPBDH@Z:NEAR			; CObject::operator delete
EXTRN	__imp__SetRect@20:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT rtc$IMZ
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\pictureex.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
xdata$x	SEGMENT
$T189663 DD	0ffffffffH
	DD	FLAT:$L189653
	DD	00H
	DD	FLAT:$L189654
	DD	00H
	DD	FLAT:$L189655
$T189659 DD	019930520H
	DD	03H
	DD	FLAT:$T189663
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CPictureEx@@6B@
CONST	SEGMENT
??_7CPictureEx@@6B@ DD FLAT:??_R4CPictureEx@@6B@	; CPictureEx::`vftable'
	DD	FLAT:??_ECPictureEx@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CPictureEx@@6B@
rdata$r	SEGMENT
??_R4CPictureEx@@6B@ DD 00H				; CPictureEx::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPictureEx@@@8
	DD	FLAT:??_R3CPictureEx@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPictureEx@@@8
_DATA	SEGMENT
??_R0?AVCPictureEx@@@8 DD FLAT:??_7type_info@@6B@	; CPictureEx `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPictureEx@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CPictureEx@@8
rdata$r	SEGMENT
??_R3CPictureEx@@8 DD 00H				; CPictureEx::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CPictureEx@@8
rdata$r	ENDS
;	COMDAT ??_R2CPictureEx@@8
rdata$r	SEGMENT
??_R2CPictureEx@@8 DD FLAT:??_R1A@?0A@A@CPictureEx@@8	; CPictureEx::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CPictureEx@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CPictureEx@@8 DD FLAT:??_R0?AVCPictureEx@@@8 ; CPictureEx::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt /RTCsu
rdata$r	ENDS
_TEXT	SEGMENT
tv159 = -40						; size = 4
tv147 = -36						; size = 4
$T189644 = -32						; size = 4
$T189643 = -28						; size = 4
$T189640 = -24						; size = 4
$T189639 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_bStretch$ = 8						; size = 1
??0CPictureEx@@QAE@_N@Z PROC NEAR			; CPictureEx::CPictureEx
; _this$ = ecx

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPictureEx@@QAE@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001b	56		 push	 esi
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00024	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00027	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0002a	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0002d	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00030	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00033	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00036	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00039	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CPictureEx@@6B@
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8a 55 08	 mov	 dl, BYTE PTR _bStretch$[ebp]
  00048	88 51 5c	 mov	 BYTE PTR [ecx+92], dl
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00054	e8 00 00 00 00	 call	 ??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 175  : 	// check structures size
; 176  : 	ASSERT(sizeof(TGIFImageDescriptor) == 10);
; 177  : 	ASSERT(sizeof(TGIFAppExtension)    == 14);
; 178  : 	ASSERT(sizeof(TGIFPlainTextExt)    == 15);
; 179  : 	ASSERT(sizeof(TGIFLSDescriptor)    ==  7);
; 180  : 	ASSERT(sizeof(TGIFControlExt)	   ==  8);
; 181  : 	ASSERT(sizeof(TGIFCommentExt)	   ==  2);
; 182  : 	ASSERT(sizeof(TGIFHeader)		   ==  6);
; 183  : 
; 184  : 	m_pGIFLSDescriptor = NULL;

  00060	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], 0

; 185  : 	m_pGIFHeader	   = NULL;

  0006a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	c7 41 74 00 00
	00 00		 mov	 DWORD PTR [ecx+116], 0

; 186  : 	m_pPicture		   = NULL;

  00074	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00077	c7 42 70 00 00
	00 00		 mov	 DWORD PTR [edx+112], 0

; 187  : 	m_pRawData		   = NULL;

  0007e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00081	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [eax+120], 0

; 188  : 	m_hThread		   = NULL;

  00088	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 189  : 	m_hBitmap          = NULL;

  00092	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00095	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0

; 190  : 	m_hMemDC		   = NULL;

  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0

; 191  : 
; 192  : 	m_hDispMemDC       = NULL;

  000a6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0

; 193  : 	m_hDispMemBM       = NULL;

  000b0	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000b3	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0

; 194  : 	m_hDispOldBM       = NULL;

  000ba	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 195  : 
; 196  : 	m_bHasMask         = FALSE;

  000c4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 197  : 	m_bIsInitialized   = FALSE;

  000ce	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d1	c7 42 48 00 00
	00 00		 mov	 DWORD PTR [edx+72], 0

; 198  : 	m_bExitThread	   = FALSE;

  000d8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000db	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 199  : 	m_bIsPlaying       = FALSE;

  000e2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 200  : 	m_bIsGIF		   = FALSE;

  000ec	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000ef	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 201  : 	m_clrBackground    = RGB(255,255,255); // white by default

  000f6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	c7 40 28 ff ff
	ff 00		 mov	 DWORD PTR [eax+40], 16777215 ; 00ffffffH

; 202  : 	m_nGlobalCTSize    = 0;

  00100	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 203  : 	m_nCurrOffset	   = 0;

  0010a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0010d	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 204  : 	m_nCurrFrame	   = 0;

  00114	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00117	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 205  : 	m_nDataSize		   = 0;

  0011e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 206  : 	m_PictureSize.cx = m_PictureSize.cy = 0;

  00128	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0012b	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0
  00132	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00135	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 207  : 	SetRect(&m_PaintRect,0,0,0,0);

  0013c	8b f4		 mov	 esi, esp
  0013e	6a 00		 push	 0
  00140	6a 00		 push	 0
  00142	6a 00		 push	 0
  00144	6a 00		 push	 0
  00146	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00149	83 c1 10	 add	 ecx, 16			; 00000010H
  0014c	51		 push	 ecx
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  00153	3b f4		 cmp	 esi, esp
  00155	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 208  : 
; 209  : 	m_bPause		= false;

  0015a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0015d	c6 42 04 00	 mov	 BYTE PTR [edx+4], 0

; 210  : 
; 211  : 	m_aryPoint = new CArray<CRect, CRect>;

  00161	68 d3 00 00 00	 push	 211			; 000000d3H
  00166	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  0016b	6a 14		 push	 20			; 00000014H
  0016d	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  00172	89 45 e8	 mov	 DWORD PTR $T189640[ebp], eax
  00175	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00179	83 7d e8 00	 cmp	 DWORD PTR $T189640[ebp], 0
  0017d	74 0d		 je	 SHORT $L189641
  0017f	8b 4d e8	 mov	 ecx, DWORD PTR $T189640[ebp]
  00182	e8 00 00 00 00	 call	 ??0?$CArray@VCRect@@V1@@@QAE@XZ ; CArray<CRect,CRect>::CArray<CRect,CRect>
  00187	89 45 dc	 mov	 DWORD PTR tv147[ebp], eax
  0018a	eb 07		 jmp	 SHORT $L189642
$L189641:
  0018c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv147[ebp], 0
$L189642:
  00193	8b 45 dc	 mov	 eax, DWORD PTR tv147[ebp]
  00196	89 45 ec	 mov	 DWORD PTR $T189639[ebp], eax
  00199	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0019d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a0	8b 55 ec	 mov	 edx, DWORD PTR $T189639[ebp]
  001a3	89 91 90 00 00
	00		 mov	 DWORD PTR [ecx+144], edx

; 212  : 	m_aryPrepPoint = new CArray<CRect , CRect>;

  001a9	68 d4 00 00 00	 push	 212			; 000000d4H
  001ae	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  001b3	6a 14		 push	 20			; 00000014H
  001b5	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  001ba	89 45 e0	 mov	 DWORD PTR $T189644[ebp], eax
  001bd	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001c1	83 7d e0 00	 cmp	 DWORD PTR $T189644[ebp], 0
  001c5	74 0d		 je	 SHORT $L189645
  001c7	8b 4d e0	 mov	 ecx, DWORD PTR $T189644[ebp]
  001ca	e8 00 00 00 00	 call	 ??0?$CArray@VCRect@@V1@@@QAE@XZ ; CArray<CRect,CRect>::CArray<CRect,CRect>
  001cf	89 45 d8	 mov	 DWORD PTR tv159[ebp], eax
  001d2	eb 07		 jmp	 SHORT $L189646
$L189645:
  001d4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
$L189646:
  001db	8b 45 d8	 mov	 eax, DWORD PTR tv159[ebp]
  001de	89 45 e4	 mov	 DWORD PTR $T189643[ebp], eax
  001e1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001e5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e8	8b 55 e4	 mov	 edx, DWORD PTR $T189643[ebp]
  001eb	89 91 94 00 00
	00		 mov	 DWORD PTR [ecx+148], edx

; 213  : 	m_hExitEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

  001f1	8b f4		 mov	 esi, esp
  001f3	6a 00		 push	 0
  001f5	6a 00		 push	 0
  001f7	6a 01		 push	 1
  001f9	6a 00		 push	 0
  001fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateEventA@16
  00201	3b f4		 cmp	 esi, esp
  00203	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00208	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0020b	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 214  : }

  0020e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00215	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00218	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0021b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00222	5e		 pop	 esi
  00223	83 c4 28	 add	 esp, 40			; 00000028H
  00226	3b ec		 cmp	 ebp, esp
  00228	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022d	8b e5		 mov	 esp, ebp
  0022f	5d		 pop	 ebp
  00230	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L189653:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
$L189654:
  0000e	68 d3 00 00 00	 push	 211			; 000000d3H
  00013	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00018	8b 45 e8	 mov	 eax, DWORD PTR $T189640[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??3CObject@@SGXPAXPBDH@Z ; CObject::operator delete
  00021	c3		 ret	 0
$L189655:
  00022	68 d4 00 00 00	 push	 212			; 000000d4H
  00027	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  0002c	8b 45 e0	 mov	 eax, DWORD PTR $T189644[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3CObject@@SGXPAXPBDH@Z ; CObject::operator delete
  00035	c3		 ret	 0
__ehhandler$??0CPictureEx@@QAE@_N@Z:
  00036	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T189659
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CPictureEx@@QAE@_N@Z ENDP				; CPictureEx::CPictureEx
PUBLIC	??1CPictureEx@@UAE@XZ				; CPictureEx::~CPictureEx
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCPictureEx@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCPictureEx@@UAEPAXI@Z PROC NEAR			; CPictureEx::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1CPictureEx@@UAE@XZ	; CPictureEx::~CPictureEx
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0c		 je	 SHORT $L187826
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
$L187826:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_GCPictureEx@@UAEPAXI@Z ENDP				; CPictureEx::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Stop@CPictureEx@@QAEXXZ			; CPictureEx::Stop
PUBLIC	?UnLoad@CPictureEx@@QAEXXZ			; CPictureEx::UnLoad
EXTRN	__imp__CloseHandle@4:NEAR
xdata$x	SEGMENT
$T189679 DD	0ffffffffH
	DD	FLAT:$L189675
$T189677 DD	019930520H
	DD	01H
	DD	FLAT:$T189679
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv87 = -40						; size = 4
tv79 = -36						; size = 4
$T189672 = -32						; size = 4
$T189671 = -28						; size = 4
$T189668 = -24						; size = 4
$T189667 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CPictureEx@@UAE@XZ PROC NEAR				; CPictureEx::~CPictureEx
; _this$ = ecx

; 217  : {

  00240	55		 push	 ebp
  00241	8b ec		 mov	 ebp, esp
  00243	6a ff		 push	 -1
  00245	68 00 00 00 00	 push	 __ehhandler$??1CPictureEx@@UAE@XZ
  0024a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00250	50		 push	 eax
  00251	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00258	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0025b	56		 push	 esi
  0025c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00261	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00264	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00267	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0026a	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0026d	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00270	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00273	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00276	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00279	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0027c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CPictureEx@@6B@
  00282	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 218  : 
; 219  : 	Stop();	

  00289	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0028c	e8 00 00 00 00	 call	 ?Stop@CPictureEx@@QAEXXZ ; CPictureEx::Stop

; 220  : 	UnLoad();

  00291	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00294	e8 00 00 00 00	 call	 ?UnLoad@CPictureEx@@QAEXXZ ; CPictureEx::UnLoad

; 221  : 	CloseHandle(m_hExitEvent);

  00299	8b f4		 mov	 esi, esp
  0029b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0029e	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  002a1	52		 push	 edx
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  002a8	3b f4		 cmp	 esi, esp
  002aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 222  : 	delete m_aryPrepPoint;

  002af	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002b2	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  002b8	89 4d e8	 mov	 DWORD PTR $T189668[ebp], ecx
  002bb	8b 55 e8	 mov	 edx, DWORD PTR $T189668[ebp]
  002be	89 55 ec	 mov	 DWORD PTR $T189667[ebp], edx
  002c1	83 7d ec 00	 cmp	 DWORD PTR $T189667[ebp], 0
  002c5	74 1b		 je	 SHORT $L189669
  002c7	8b f4		 mov	 esi, esp
  002c9	6a 01		 push	 1
  002cb	8b 45 ec	 mov	 eax, DWORD PTR $T189667[ebp]
  002ce	8b 10		 mov	 edx, DWORD PTR [eax]
  002d0	8b 4d ec	 mov	 ecx, DWORD PTR $T189667[ebp]
  002d3	ff 52 04	 call	 DWORD PTR [edx+4]
  002d6	3b f4		 cmp	 esi, esp
  002d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002dd	89 45 dc	 mov	 DWORD PTR tv79[ebp], eax
  002e0	eb 07		 jmp	 SHORT $L189670
$L189669:
  002e2	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$L189670:

; 223  : 	delete m_aryPoint;

  002e9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002ec	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  002f2	89 4d e0	 mov	 DWORD PTR $T189672[ebp], ecx
  002f5	8b 55 e0	 mov	 edx, DWORD PTR $T189672[ebp]
  002f8	89 55 e4	 mov	 DWORD PTR $T189671[ebp], edx
  002fb	83 7d e4 00	 cmp	 DWORD PTR $T189671[ebp], 0
  002ff	74 1b		 je	 SHORT $L189673
  00301	8b f4		 mov	 esi, esp
  00303	6a 01		 push	 1
  00305	8b 45 e4	 mov	 eax, DWORD PTR $T189671[ebp]
  00308	8b 10		 mov	 edx, DWORD PTR [eax]
  0030a	8b 4d e4	 mov	 ecx, DWORD PTR $T189671[ebp]
  0030d	ff 52 04	 call	 DWORD PTR [edx+4]
  00310	3b f4		 cmp	 esi, esp
  00312	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00317	89 45 d8	 mov	 DWORD PTR tv87[ebp], eax
  0031a	eb 07		 jmp	 SHORT $L187829
$L189673:
  0031c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$L187829:

; 224  : 
; 225  : }

  00323	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0032a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0032d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00333	e8 00 00 00 00	 call	 ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  00338	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0033b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00342	5e		 pop	 esi
  00343	83 c4 28	 add	 esp, 40			; 00000028H
  00346	3b ec		 cmp	 ebp, esp
  00348	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0034d	8b e5		 mov	 esp, ebp
  0034f	5d		 pop	 ebp
  00350	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L189675:
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00049	e9 00 00 00 00	 jmp	 ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
__ehhandler$??1CPictureEx@@UAE@XZ:
  0004e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T189677
  00053	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CPictureEx@@UAE@XZ ENDP				; CPictureEx::~CPictureEx
PUBLIC	?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::empty
PUBLIC	?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::push_back
PUBLIC	?SkipNextGraphicBlock@CPictureEx@@IAEHXZ	; CPictureEx::SkipNextGraphicBlock
PUBLIC	?PrepareDC@CPictureEx@@IAEHHH@Z			; CPictureEx::PrepareDC
PUBLIC	?ResetDataPointer@CPictureEx@@IAEXXZ		; CPictureEx::ResetDataPointer
PUBLIC	?GetNextGraphicBlock@CPictureEx@@IAEPAXPAI0PAUtagSIZE@@10@Z ; CPictureEx::GetNextGraphicBlock
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ		; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z ; CPictureEx::TGIFLSDescriptor::GetPackedValue
PUBLIC	?Load@CPictureEx@@QAEHPAXK@Z			; CPictureEx::Load
EXTRN	__imp__CreateStreamOnHGlobal@12:NEAR
EXTRN	__imp__GlobalLock@4:NEAR
EXTRN	__imp__GlobalUnlock@4:NEAR
EXTRN	__imp__GlobalFree@4:NEAR
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	__imp__GetDC@4:NEAR
EXTRN	__imp__ReleaseDC@8:NEAR
EXTRN	_IID_IPicture:BYTE
EXTRN	__imp__GetDeviceCaps@8:NEAR
EXTRN	_memcmp:NEAR
EXTRN	__imp__OleLoadPicture@20:NEAR
EXTRN	__imp__MulDiv@12:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T189681 = -128						; size = 8
_pStream$187892 = -116					; size = 4
_nCurFrame$187888 = -108				; size = 4
_hFrameData$187887 = -104				; size = 4
_nBlockLen$187886 = -96					; size = 4
_frame$187885 = -84					; size = 28
_nFrameCount$187873 = -52				; size = 4
_pBkClr$187864 = -48					; size = 4
_hDC$187858 = -44					; size = 4
_hmHeight$187857 = -36					; size = 4
_hmWidth$187856 = -24					; size = 4
_pStream$ = -12						; size = 4
_this$ = -4						; size = 4
_hGlobal$ = 8						; size = 4
_dwSize$ = 12						; size = 4
?Load@CPictureEx@@QAEHPAXK@Z PROC NEAR			; CPictureEx::Load
; _this$ = ecx

; 235  : {

  00360	55		 push	 ebp
  00361	8b ec		 mov	 ebp, esp
  00363	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00369	56		 push	 esi
  0036a	57		 push	 edi
  0036b	51		 push	 ecx
  0036c	8d 7d 80	 lea	 edi, DWORD PTR [ebp-128]
  0036f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00374	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00379	f3 ab		 rep stosd
  0037b	59		 pop	 ecx
  0037c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 	IStream *pStream = NULL;

  0037f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pStream$[ebp], 0

; 237  : 	UnLoad();

  00386	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00389	e8 00 00 00 00	 call	 ?UnLoad@CPictureEx@@QAEXXZ ; CPictureEx::UnLoad

; 238  : 
; 239  : 	if (!(m_pRawData = reinterpret_cast<unsigned char*> (GlobalLock(hGlobal))) )

  0038e	8b f4		 mov	 esi, esp
  00390	8b 45 08	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  00393	50		 push	 eax
  00394	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  0039a	3b f4		 cmp	 esi, esp
  0039c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a4	89 41 78	 mov	 DWORD PTR [ecx+120], eax
  003a7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003aa	83 7a 78 00	 cmp	 DWORD PTR [edx+120], 0
  003ae	75 27		 jne	 SHORT $L187841

; 240  : 	{
; 241  : 		TRACE(_T("Load: Error locking memory\n"));

  003b0	68 00 00 00 00	 push	 OFFSET FLAT:$SG187844
  003b5	68 f1 00 00 00	 push	 241			; 000000f1H
  003ba	68 00 00 00 00	 push	 OFFSET FLAT:$SG187843
  003bf	8d 4d 80	 lea	 ecx, DWORD PTR $T189681[ebp]
  003c2	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  003c7	50		 push	 eax
  003c8	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  003cd	83 c4 08	 add	 esp, 8

; 242  : 		return FALSE;

  003d0	33 c0		 xor	 eax, eax
  003d2	e9 b7 04 00 00	 jmp	 $L187838
$L187841:

; 243  : 	};
; 244  : 
; 245  : 	m_nDataSize = dwSize;

  003d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003da	8b 4d 0c	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  003dd	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 246  : 	m_pGIFHeader = reinterpret_cast<TGIFHeader *> (m_pRawData);

  003e0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003e6	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  003e9	89 4a 74	 mov	 DWORD PTR [edx+116], ecx

; 247  : 
; 248  : 	if ((memcmp(&m_pGIFHeader->m_cSignature,"GIF",3) != 0) &&
; 249  : 		((memcmp(&m_pGIFHeader->m_cVersion,"87a",3) != 0) ||
; 250  : 		 (memcmp(&m_pGIFHeader->m_cVersion,"89a",3) != 0)) )

  003ec	6a 03		 push	 3
  003ee	68 00 00 00 00	 push	 OFFSET FLAT:$SG187847
  003f3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003f6	8b 42 74	 mov	 eax, DWORD PTR [edx+116]
  003f9	50		 push	 eax
  003fa	e8 00 00 00 00	 call	 _memcmp
  003ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00402	85 c0		 test	 eax, eax
  00404	0f 84 b7 01 00
	00		 je	 $L187846
  0040a	6a 03		 push	 3
  0040c	68 00 00 00 00	 push	 OFFSET FLAT:$SG187849
  00411	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00414	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00417	83 c2 03	 add	 edx, 3
  0041a	52		 push	 edx
  0041b	e8 00 00 00 00	 call	 _memcmp
  00420	83 c4 0c	 add	 esp, 12			; 0000000cH
  00423	85 c0		 test	 eax, eax
  00425	75 21		 jne	 SHORT $L187848
  00427	6a 03		 push	 3
  00429	68 00 00 00 00	 push	 OFFSET FLAT:$SG187850
  0042e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00431	8b 48 74	 mov	 ecx, DWORD PTR [eax+116]
  00434	83 c1 03	 add	 ecx, 3
  00437	51		 push	 ecx
  00438	e8 00 00 00 00	 call	 _memcmp
  0043d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00440	85 c0		 test	 eax, eax
  00442	0f 84 79 01 00
	00		 je	 $L187846
$L187848:

; 251  : 	{
; 252  : 	// it's neither GIF87a nor GIF89a
; 253  : 	// do the default processing
; 254  : 
; 255  : 		// clear GIF variables
; 256  : 		m_pRawData = NULL;

  00448	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0044b	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0

; 257  : 		GlobalUnlock(hGlobal);

  00452	8b f4		 mov	 esi, esp
  00454	8b 45 08	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  00457	50		 push	 eax
  00458	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  0045e	3b f4		 cmp	 esi, esp
  00460	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 258  : 
; 259  : 		// don't delete memory on object's release
; 260  : 		if (CreateStreamOnHGlobal(hGlobal,FALSE,&pStream) != S_OK)

  00465	8b f4		 mov	 esi, esp
  00467	8d 4d f4	 lea	 ecx, DWORD PTR _pStream$[ebp]
  0046a	51		 push	 ecx
  0046b	6a 00		 push	 0
  0046d	8b 55 08	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00470	52		 push	 edx
  00471	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateStreamOnHGlobal@12
  00477	3b f4		 cmp	 esi, esp
  00479	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0047e	85 c0		 test	 eax, eax
  00480	74 07		 je	 SHORT $L187852

; 261  : 			return FALSE;

  00482	33 c0		 xor	 eax, eax
  00484	e9 05 04 00 00	 jmp	 $L187838
$L187852:

; 262  : 
; 263  : 		if (OleLoadPicture(pStream,dwSize,FALSE,IID_IPicture,
; 264  : 			reinterpret_cast<LPVOID *>(&m_pPicture)) != S_OK)

  00489	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0048c	83 c0 70	 add	 eax, 112		; 00000070H
  0048f	8b f4		 mov	 esi, esp
  00491	50		 push	 eax
  00492	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPicture
  00497	6a 00		 push	 0
  00499	8b 4d 0c	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  0049c	51		 push	 ecx
  0049d	8b 55 f4	 mov	 edx, DWORD PTR _pStream$[ebp]
  004a0	52		 push	 edx
  004a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleLoadPicture@20
  004a7	3b f4		 cmp	 esi, esp
  004a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004ae	85 c0		 test	 eax, eax
  004b0	74 1c		 je	 SHORT $L187855

; 265  : 		{
; 266  : 			pStream->Release();

  004b2	8b 45 f4	 mov	 eax, DWORD PTR _pStream$[ebp]
  004b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  004b7	8b f4		 mov	 esi, esp
  004b9	8b 55 f4	 mov	 edx, DWORD PTR _pStream$[ebp]
  004bc	52		 push	 edx
  004bd	ff 51 08	 call	 DWORD PTR [ecx+8]
  004c0	3b f4		 cmp	 esi, esp
  004c2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 267  : 			return FALSE;

  004c7	33 c0		 xor	 eax, eax
  004c9	e9 c0 03 00 00	 jmp	 $L187838
$L187855:

; 268  : 		};
; 269  : 		pStream->Release();

  004ce	8b 45 f4	 mov	 eax, DWORD PTR _pStream$[ebp]
  004d1	8b 08		 mov	 ecx, DWORD PTR [eax]
  004d3	8b f4		 mov	 esi, esp
  004d5	8b 55 f4	 mov	 edx, DWORD PTR _pStream$[ebp]
  004d8	52		 push	 edx
  004d9	ff 51 08	 call	 DWORD PTR [ecx+8]
  004dc	3b f4		 cmp	 esi, esp
  004de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 270  : 
; 271  : 		// store picture's size
; 272  : 
; 273  : 		long hmWidth;
; 274  : 		long hmHeight;
; 275  : 		m_pPicture->get_Width(&hmWidth);

  004e3	8b f4		 mov	 esi, esp
  004e5	8d 45 e8	 lea	 eax, DWORD PTR _hmWidth$187856[ebp]
  004e8	50		 push	 eax
  004e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ec	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  004ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004f2	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  004f5	8b 12		 mov	 edx, DWORD PTR [edx]
  004f7	51		 push	 ecx
  004f8	ff 52 18	 call	 DWORD PTR [edx+24]
  004fb	3b f4		 cmp	 esi, esp
  004fd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 276  : 		m_pPicture->get_Height(&hmHeight);

  00502	8b f4		 mov	 esi, esp
  00504	8d 45 dc	 lea	 eax, DWORD PTR _hmHeight$187857[ebp]
  00507	50		 push	 eax
  00508	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0050e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00511	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00514	8b 12		 mov	 edx, DWORD PTR [edx]
  00516	51		 push	 ecx
  00517	ff 52 1c	 call	 DWORD PTR [edx+28]
  0051a	3b f4		 cmp	 esi, esp
  0051c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 277  : 
; 278  : 		HDC hDC = ::GetDC(m_hWnd);

  00521	8b f4		 mov	 esi, esp
  00523	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00526	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00529	51		 push	 ecx
  0052a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00530	3b f4		 cmp	 esi, esp
  00532	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00537	89 45 d4	 mov	 DWORD PTR _hDC$187858[ebp], eax

; 279  : 		m_PictureSize.cx = MulDiv(hmWidth, GetDeviceCaps(hDC,LOGPIXELSX), 2540);

  0053a	8b f4		 mov	 esi, esp
  0053c	68 ec 09 00 00	 push	 2540			; 000009ecH
  00541	8b fc		 mov	 edi, esp
  00543	6a 58		 push	 88			; 00000058H
  00545	8b 55 d4	 mov	 edx, DWORD PTR _hDC$187858[ebp]
  00548	52		 push	 edx
  00549	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8
  0054f	3b fc		 cmp	 edi, esp
  00551	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00556	50		 push	 eax
  00557	8b 45 e8	 mov	 eax, DWORD PTR _hmWidth$187856[ebp]
  0055a	50		 push	 eax
  0055b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  00561	3b f4		 cmp	 esi, esp
  00563	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00568	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056b	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 280  : 		m_PictureSize.cy = MulDiv(hmHeight, GetDeviceCaps(hDC,LOGPIXELSY), 2540);

  0056e	8b f4		 mov	 esi, esp
  00570	68 ec 09 00 00	 push	 2540			; 000009ecH
  00575	8b fc		 mov	 edi, esp
  00577	6a 5a		 push	 90			; 0000005aH
  00579	8b 55 d4	 mov	 edx, DWORD PTR _hDC$187858[ebp]
  0057c	52		 push	 edx
  0057d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8
  00583	3b fc		 cmp	 edi, esp
  00585	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0058a	50		 push	 eax
  0058b	8b 45 dc	 mov	 eax, DWORD PTR _hmHeight$187857[ebp]
  0058e	50		 push	 eax
  0058f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  00595	3b f4		 cmp	 esi, esp
  00597	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0059c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0059f	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 281  : 		::ReleaseDC(m_hWnd,hDC);

  005a2	8b f4		 mov	 esi, esp
  005a4	8b 55 d4	 mov	 edx, DWORD PTR _hDC$187858[ebp]
  005a7	52		 push	 edx
  005a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005ab	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  005ae	51		 push	 ecx
  005af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  005b5	3b f4		 cmp	 esi, esp
  005b7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 282  : 	}
; 283  : 	else

  005bc	e9 b7 02 00 00	 jmp	 $L187859
$L187846:

; 284  : 	{
; 285  : 		// it's a GIF
; 286  : 		m_bIsGIF = TRUE;

  005c1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005c4	c7 42 3c 01 00
	00 00		 mov	 DWORD PTR [edx+60], 1

; 287  : 		m_pGIFLSDescriptor = reinterpret_cast<TGIFLSDescriptor *>
; 288  : 			(m_pRawData + sizeof(TGIFHeader));

  005cb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005ce	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  005d1	83 c1 06	 add	 ecx, 6
  005d4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005d7	89 4a 7c	 mov	 DWORD PTR [edx+124], ecx

; 289  : 		if (m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCT) == 1)

  005da	6a 00		 push	 0
  005dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  005df	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  005e2	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z ; CPictureEx::TGIFLSDescriptor::GetPackedValue
  005e7	83 f8 01	 cmp	 eax, 1
  005ea	75 60		 jne	 SHORT $L187862

; 290  : 		{
; 291  : 			// calculate the globat color table size
; 292  : 			m_nGlobalCTSize = static_cast<int>
; 293  : 				(3* (1 << (m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCTSIZE)+1)));

  005ec	6a 03		 push	 3
  005ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005f1	8b 49 7c	 mov	 ecx, DWORD PTR [ecx+124]
  005f4	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z ; CPictureEx::TGIFLSDescriptor::GetPackedValue
  005f9	83 c0 01	 add	 eax, 1
  005fc	ba 01 00 00 00	 mov	 edx, 1
  00601	8b c8		 mov	 ecx, eax
  00603	d3 e2		 shl	 edx, cl
  00605	6b d2 03	 imul	 edx, 3
  00608	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0060b	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 294  : 			// get the background color if GCT is present
; 295  : 			unsigned char *pBkClr = m_pRawData + sizeof(TGIFHeader) + 
; 296  : 				sizeof(TGIFLSDescriptor) + 3*m_pGIFLSDescriptor->m_cBkIndex;

  0060e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00611	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00614	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00617	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  0061a	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  0061e	6b c0 03	 imul	 eax, 3
  00621	8d 4c 02 0d	 lea	 ecx, DWORD PTR [edx+eax+13]
  00625	89 4d d0	 mov	 DWORD PTR _pBkClr$187864[ebp], ecx

; 297  : 			m_clrBackground = RGB(pBkClr[0],pBkClr[1],pBkClr[2]);

  00628	8b 55 d0	 mov	 edx, DWORD PTR _pBkClr$187864[ebp]
  0062b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0062e	8b 4d d0	 mov	 ecx, DWORD PTR _pBkClr$187864[ebp]
  00631	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00635	c1 e2 08	 shl	 edx, 8
  00638	0b c2		 or	 eax, edx
  0063a	8b 4d d0	 mov	 ecx, DWORD PTR _pBkClr$187864[ebp]
  0063d	0f b6 51 02	 movzx	 edx, BYTE PTR [ecx+2]
  00641	c1 e2 10	 shl	 edx, 16			; 00000010H
  00644	0b c2		 or	 eax, edx
  00646	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00649	89 41 28	 mov	 DWORD PTR [ecx+40], eax
$L187862:

; 298  : 		};
; 299  : 
; 300  : 		// store the picture's size
; 301  : 		m_PictureSize.cx = m_pGIFLSDescriptor->m_wWidth;

  0064c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0064f	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00652	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00655	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00658	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 302  : 		m_PictureSize.cy = m_pGIFLSDescriptor->m_wHeight;

  0065b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0065e	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  00661	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00665	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00668	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 303  : 
; 304  : 		// determine frame count for this picture
; 305  : 		UINT nFrameCount=0;

  0066b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _nFrameCount$187873[ebp], 0

; 306  : 		ResetDataPointer();

  00672	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00675	e8 00 00 00 00	 call	 ?ResetDataPointer@CPictureEx@@IAEXXZ ; CPictureEx::ResetDataPointer
$L187875:

; 307  : 		while (SkipNextGraphicBlock())

  0067a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0067d	e8 00 00 00 00	 call	 ?SkipNextGraphicBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextGraphicBlock
  00682	85 c0		 test	 eax, eax
  00684	74 0b		 je	 SHORT $L187876

; 308  : 			nFrameCount++;

  00686	8b 4d cc	 mov	 ecx, DWORD PTR _nFrameCount$187873[ebp]
  00689	83 c1 01	 add	 ecx, 1
  0068c	89 4d cc	 mov	 DWORD PTR _nFrameCount$187873[ebp], ecx
  0068f	eb e9		 jmp	 SHORT $L187875
$L187876:

; 309  : 
; 310  : #ifdef GIF_TRACING
; 311  : 		TRACE(
; 312  : 			_T(" -= GIF encountered\n"
; 313  : 			   "Logical Screen dimensions = %dx%d\n"
; 314  : 			   "Global color table = %d\n"
; 315  : 			   "Color depth = %d\n"
; 316  : 			   "Sort flag = %d\n"
; 317  : 			   "Size of Global Color Table = %d\n"
; 318  : 			   "Background color index = %d\n"
; 319  : 			   "Pixel aspect ratio = %d\n"
; 320  : 			   "Frame count = %d\n"
; 321  : 			   "Background color = %06Xh\n\n"
; 322  : 			  ),
; 323  : 			m_pGIFLSDescriptor->m_wWidth,
; 324  : 			m_pGIFLSDescriptor->m_wHeight,
; 325  : 			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCT),
; 326  : 			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_CRESOLUTION),
; 327  : 			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_SORT),
; 328  : 			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCTSIZE),
; 329  : 			m_pGIFLSDescriptor->m_cBkIndex,
; 330  : 			m_pGIFLSDescriptor->m_cPixelAspect,
; 331  : 			nFrameCount,
; 332  : 			m_clrBackground
; 333  : 			);
; 334  : 		EnumGIFBlocks();
; 335  : #endif
; 336  : 
; 337  : 		if (nFrameCount == 0) // it's an empty GIF!

  00691	83 7d cc 00	 cmp	 DWORD PTR _nFrameCount$187873[ebp], 0
  00695	75 24		 jne	 SHORT $L187877

; 338  : 		{
; 339  : 			m_pRawData = NULL;

  00697	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0069a	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0

; 340  : 			GlobalUnlock(hGlobal);

  006a1	8b f4		 mov	 esi, esp
  006a3	8b 45 08	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  006a6	50		 push	 eax
  006a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  006ad	3b f4		 cmp	 esi, esp
  006af	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 341  : 			return FALSE;

  006b4	33 c0		 xor	 eax, eax
  006b6	e9 d3 01 00 00	 jmp	 $L187838
$L187877:

; 342  : 		};
; 343  : 
; 344  : 		// now check the frame count
; 345  : 		// if there's only one frame, no need to animate this GIF
; 346  : 		// therefore, treat it like any other pic
; 347  : 
; 348  : 		if (nFrameCount == 1)

  006bb	83 7d cc 01	 cmp	 DWORD PTR _nFrameCount$187873[ebp], 1
  006bf	0f 85 a0 00 00
	00		 jne	 $L187878

; 349  : 		{
; 350  : 			// clear GIF variables
; 351  : 			m_pRawData = NULL;

  006c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006c8	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], 0

; 352  : 			GlobalUnlock(hGlobal);

  006cf	8b f4		 mov	 esi, esp
  006d1	8b 55 08	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  006d4	52		 push	 edx
  006d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  006db	3b f4		 cmp	 esi, esp
  006dd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 353  : 
; 354  : 			// don't delete memory on object's release
; 355  : 			if (CreateStreamOnHGlobal(hGlobal,FALSE,&pStream) != S_OK)

  006e2	8b f4		 mov	 esi, esp
  006e4	8d 45 f4	 lea	 eax, DWORD PTR _pStream$[ebp]
  006e7	50		 push	 eax
  006e8	6a 00		 push	 0
  006ea	8b 4d 08	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  006ed	51		 push	 ecx
  006ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateStreamOnHGlobal@12
  006f4	3b f4		 cmp	 esi, esp
  006f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006fb	85 c0		 test	 eax, eax
  006fd	74 07		 je	 SHORT $L187880

; 356  : 				return FALSE;

  006ff	33 c0		 xor	 eax, eax
  00701	e9 88 01 00 00	 jmp	 $L187838
$L187880:

; 357  : 
; 358  : 			if (OleLoadPicture(pStream,dwSize,FALSE,IID_IPicture,
; 359  : 				(LPVOID *)&m_pPicture) != S_OK)

  00706	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00709	83 c2 70	 add	 edx, 112		; 00000070H
  0070c	8b f4		 mov	 esi, esp
  0070e	52		 push	 edx
  0070f	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPicture
  00714	6a 00		 push	 0
  00716	8b 45 0c	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00719	50		 push	 eax
  0071a	8b 4d f4	 mov	 ecx, DWORD PTR _pStream$[ebp]
  0071d	51		 push	 ecx
  0071e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleLoadPicture@20
  00724	3b f4		 cmp	 esi, esp
  00726	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0072b	85 c0		 test	 eax, eax
  0072d	74 1c		 je	 SHORT $L187883

; 360  : 			{
; 361  : 				pStream->Release();

  0072f	8b 55 f4	 mov	 edx, DWORD PTR _pStream$[ebp]
  00732	8b 02		 mov	 eax, DWORD PTR [edx]
  00734	8b f4		 mov	 esi, esp
  00736	8b 4d f4	 mov	 ecx, DWORD PTR _pStream$[ebp]
  00739	51		 push	 ecx
  0073a	ff 50 08	 call	 DWORD PTR [eax+8]
  0073d	3b f4		 cmp	 esi, esp
  0073f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 362  : 				return FALSE;

  00744	33 c0		 xor	 eax, eax
  00746	e9 43 01 00 00	 jmp	 $L187838
$L187883:

; 363  : 			};
; 364  : 
; 365  : 			pStream->Release();

  0074b	8b 55 f4	 mov	 edx, DWORD PTR _pStream$[ebp]
  0074e	8b 02		 mov	 eax, DWORD PTR [edx]
  00750	8b f4		 mov	 esi, esp
  00752	8b 4d f4	 mov	 ecx, DWORD PTR _pStream$[ebp]
  00755	51		 push	 ecx
  00756	ff 50 08	 call	 DWORD PTR [eax+8]
  00759	3b f4		 cmp	 esi, esp
  0075b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 366  : 		}
; 367  : 		else

  00760	e9 13 01 00 00	 jmp	 $L187859
$L187878:

; 368  : 		{
; 369  : 		// if, on the contrary, there are several frames
; 370  : 		// then store separate frames in an array
; 371  : 
; 372  : 			TFrame frame;
; 373  : 			UINT nBlockLen;
; 374  : 			HGLOBAL hFrameData;
; 375  : 			UINT nCurFrame = 0;

  00765	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _nCurFrame$187888[ebp], 0

; 376  : 
; 377  : 			ResetDataPointer();

  0076c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0076f	e8 00 00 00 00	 call	 ?ResetDataPointer@CPictureEx@@IAEXXZ ; CPictureEx::ResetDataPointer
$L187890:

; 378  : 			while (hFrameData = GetNextGraphicBlock(&nBlockLen,
; 379  : 				&frame.m_nDelay, &frame.m_frameSize,
; 380  : 				&frame.m_frameOffset, &frame.m_nDisposal) )

  00774	8d 55 c4	 lea	 edx, DWORD PTR _frame$187885[ebp+24]
  00777	52		 push	 edx
  00778	8d 45 b8	 lea	 eax, DWORD PTR _frame$187885[ebp+12]
  0077b	50		 push	 eax
  0077c	8d 4d b0	 lea	 ecx, DWORD PTR _frame$187885[ebp+4]
  0077f	51		 push	 ecx
  00780	8d 55 c0	 lea	 edx, DWORD PTR _frame$187885[ebp+20]
  00783	52		 push	 edx
  00784	8d 45 a0	 lea	 eax, DWORD PTR _nBlockLen$187886[ebp]
  00787	50		 push	 eax
  00788	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0078b	e8 00 00 00 00	 call	 ?GetNextGraphicBlock@CPictureEx@@IAEPAXPAI0PAUtagSIZE@@10@Z ; CPictureEx::GetNextGraphicBlock
  00790	89 45 98	 mov	 DWORD PTR _hFrameData$187887[ebp], eax
  00793	83 7d 98 00	 cmp	 DWORD PTR _hFrameData$187887[ebp], 0
  00797	0f 84 a5 00 00
	00		 je	 $L187891

; 381  : 			{
; 382  : 				#ifdef GIF_TRACING
; 383  : 				//////////////////////////////////////////////
; 384  : 				// uncomment the following strings if you want 
; 385  : 				// to write separate frames on disk
; 386  : 				//
; 387  : 				//	CString szName;
; 388  : 				//	szName.Format(_T("%.4d.gif"),nCurFrame);
; 389  : 				//	WriteDataOnDisk(szName,hFrameData,nBlockLen);
; 390  : 				//	nCurFrame++;
; 391  : 				#endif // GIF_TRACING
; 392  : 
; 393  : 				IStream *pStream = NULL;

  0079d	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _pStream$187892[ebp], 0

; 394  : 
; 395  : 				// delete memory on object's release
; 396  : 				if (CreateStreamOnHGlobal(hFrameData,TRUE,&pStream) != S_OK)

  007a4	8b f4		 mov	 esi, esp
  007a6	8d 4d 8c	 lea	 ecx, DWORD PTR _pStream$187892[ebp]
  007a9	51		 push	 ecx
  007aa	6a 01		 push	 1
  007ac	8b 55 98	 mov	 edx, DWORD PTR _hFrameData$187887[ebp]
  007af	52		 push	 edx
  007b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateStreamOnHGlobal@12
  007b6	3b f4		 cmp	 esi, esp
  007b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  007bd	85 c0		 test	 eax, eax
  007bf	74 15		 je	 SHORT $L187894

; 397  : 				{
; 398  : 					GlobalFree(hFrameData);

  007c1	8b f4		 mov	 esi, esp
  007c3	8b 45 98	 mov	 eax, DWORD PTR _hFrameData$187887[ebp]
  007c6	50		 push	 eax
  007c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  007cd	3b f4		 cmp	 esi, esp
  007cf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 399  : 					continue;

  007d4	eb 9e		 jmp	 SHORT $L187890
$L187894:

; 400  : 				};
; 401  : 
; 402  : 				if (OleLoadPicture(pStream,nBlockLen,FALSE,
; 403  : 					IID_IPicture,
; 404  : 					reinterpret_cast<LPVOID *>(&frame.m_pPicture)) != S_OK)

  007d6	8b f4		 mov	 esi, esp
  007d8	8d 4d ac	 lea	 ecx, DWORD PTR _frame$187885[ebp]
  007db	51		 push	 ecx
  007dc	68 00 00 00 00	 push	 OFFSET FLAT:_IID_IPicture
  007e1	6a 00		 push	 0
  007e3	8b 55 a0	 mov	 edx, DWORD PTR _nBlockLen$187886[ebp]
  007e6	52		 push	 edx
  007e7	8b 45 8c	 mov	 eax, DWORD PTR _pStream$187892[ebp]
  007ea	50		 push	 eax
  007eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleLoadPicture@20
  007f1	3b f4		 cmp	 esi, esp
  007f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  007f8	85 c0		 test	 eax, eax
  007fa	74 1a		 je	 SHORT $L187897

; 405  : 				{
; 406  : 					pStream->Release();

  007fc	8b 4d 8c	 mov	 ecx, DWORD PTR _pStream$187892[ebp]
  007ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00801	8b f4		 mov	 esi, esp
  00803	8b 45 8c	 mov	 eax, DWORD PTR _pStream$187892[ebp]
  00806	50		 push	 eax
  00807	ff 52 08	 call	 DWORD PTR [edx+8]
  0080a	3b f4		 cmp	 esi, esp
  0080c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 407  : 					continue;

  00811	e9 5e ff ff ff	 jmp	 $L187890
$L187897:

; 408  : 				};
; 409  : 				pStream->Release();

  00816	8b 4d 8c	 mov	 ecx, DWORD PTR _pStream$187892[ebp]
  00819	8b 11		 mov	 edx, DWORD PTR [ecx]
  0081b	8b f4		 mov	 esi, esp
  0081d	8b 45 8c	 mov	 eax, DWORD PTR _pStream$187892[ebp]
  00820	50		 push	 eax
  00821	ff 52 08	 call	 DWORD PTR [edx+8]
  00824	3b f4		 cmp	 esi, esp
  00826	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 410  : 			
; 411  : 				// everything went well, add this frame
; 412  : 				m_arrFrames.push_back(frame);

  0082b	8d 4d ac	 lea	 ecx, DWORD PTR _frame$187885[ebp]
  0082e	51		 push	 ecx
  0082f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00832	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00838	e8 00 00 00 00	 call	 ?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::push_back

; 413  : 			};

  0083d	e9 32 ff ff ff	 jmp	 $L187890
$L187891:

; 414  : 
; 415  : 			// clean after ourselves
; 416  : 			m_pRawData = NULL;

  00842	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00845	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0

; 417  : 			GlobalUnlock(hGlobal);

  0084c	8b f4		 mov	 esi, esp
  0084e	8b 45 08	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  00851	50		 push	 eax
  00852	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  00858	3b f4		 cmp	 esi, esp
  0085a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 418  : 
; 419  : 			if (m_arrFrames.empty()) // couldn't load any frames

  0085f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00862	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00868	e8 00 00 00 00	 call	 ?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::empty
  0086d	0f b6 c8	 movzx	 ecx, al
  00870	85 c9		 test	 ecx, ecx
  00872	74 04		 je	 SHORT $L187859

; 420  : 				return FALSE;

  00874	33 c0		 xor	 eax, eax
  00876	eb 16		 jmp	 SHORT $L187838
$L187859:

; 421  : 		};
; 422  : 	}; // if (!IsGIF...
; 423  : 
; 424  : 	return PrepareDC(m_PictureSize.cx,m_PictureSize.cy);

  00878	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0087b	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0087e	50		 push	 eax
  0087f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00882	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00885	52		 push	 edx
  00886	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00889	e8 00 00 00 00	 call	 ?PrepareDC@CPictureEx@@IAEHHH@Z ; CPictureEx::PrepareDC
$L187838:

; 425  : }

  0088e	52		 push	 edx
  0088f	8b cd		 mov	 ecx, ebp
  00891	50		 push	 eax
  00892	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189691
  00898	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0089d	58		 pop	 eax
  0089e	5a		 pop	 edx
  0089f	5f		 pop	 edi
  008a0	5e		 pop	 esi
  008a1	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  008a7	3b ec		 cmp	 ebp, esp
  008a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  008ae	8b e5		 mov	 esp, ebp
  008b0	5d		 pop	 ebp
  008b1	c2 08 00	 ret	 8
$L189691:
  008b4	06 00 00 00	 DD	 6
  008b8	00 00 00 00	 DD	 $L189690
$L189690:
  008bc	f4 ff ff ff	 DD	 -12			; fffffff4H
  008c0	04 00 00 00	 DD	 4
  008c4	00 00 00 00	 DD	 $L189684
  008c8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  008cc	04 00 00 00	 DD	 4
  008d0	00 00 00 00	 DD	 $L189685
  008d4	dc ff ff ff	 DD	 -36			; ffffffdcH
  008d8	04 00 00 00	 DD	 4
  008dc	00 00 00 00	 DD	 $L189686
  008e0	ac ff ff ff	 DD	 -84			; ffffffacH
  008e4	1c 00 00 00	 DD	 28			; 0000001cH
  008e8	00 00 00 00	 DD	 $L189687
  008ec	a0 ff ff ff	 DD	 -96			; ffffffa0H
  008f0	04 00 00 00	 DD	 4
  008f4	00 00 00 00	 DD	 $L189688
  008f8	8c ff ff ff	 DD	 -116			; ffffff8cH
  008fc	04 00 00 00	 DD	 4
  00900	00 00 00 00	 DD	 $L189689
$L189689:
  00904	70		 DB	 112			; 00000070H
  00905	53		 DB	 83			; 00000053H
  00906	74		 DB	 116			; 00000074H
  00907	72		 DB	 114			; 00000072H
  00908	65		 DB	 101			; 00000065H
  00909	61		 DB	 97			; 00000061H
  0090a	6d		 DB	 109			; 0000006dH
  0090b	00		 DB	 0
$L189688:
  0090c	6e		 DB	 110			; 0000006eH
  0090d	42		 DB	 66			; 00000042H
  0090e	6c		 DB	 108			; 0000006cH
  0090f	6f		 DB	 111			; 0000006fH
  00910	63		 DB	 99			; 00000063H
  00911	6b		 DB	 107			; 0000006bH
  00912	4c		 DB	 76			; 0000004cH
  00913	65		 DB	 101			; 00000065H
  00914	6e		 DB	 110			; 0000006eH
  00915	00		 DB	 0
$L189687:
  00916	66		 DB	 102			; 00000066H
  00917	72		 DB	 114			; 00000072H
  00918	61		 DB	 97			; 00000061H
  00919	6d		 DB	 109			; 0000006dH
  0091a	65		 DB	 101			; 00000065H
  0091b	00		 DB	 0
$L189686:
  0091c	68		 DB	 104			; 00000068H
  0091d	6d		 DB	 109			; 0000006dH
  0091e	48		 DB	 72			; 00000048H
  0091f	65		 DB	 101			; 00000065H
  00920	69		 DB	 105			; 00000069H
  00921	67		 DB	 103			; 00000067H
  00922	68		 DB	 104			; 00000068H
  00923	74		 DB	 116			; 00000074H
  00924	00		 DB	 0
$L189685:
  00925	68		 DB	 104			; 00000068H
  00926	6d		 DB	 109			; 0000006dH
  00927	57		 DB	 87			; 00000057H
  00928	69		 DB	 105			; 00000069H
  00929	64		 DB	 100			; 00000064H
  0092a	74		 DB	 116			; 00000074H
  0092b	68		 DB	 104			; 00000068H
  0092c	00		 DB	 0
$L189684:
  0092d	70		 DB	 112			; 00000070H
  0092e	53		 DB	 83			; 00000053H
  0092f	74		 DB	 116			; 00000074H
  00930	72		 DB	 114			; 00000072H
  00931	65		 DB	 101			; 00000065H
  00932	61		 DB	 97			; 00000061H
  00933	6d		 DB	 109			; 0000006dH
  00934	00		 DB	 0
?Load@CPictureEx@@QAEHPAXK@Z ENDP			; CPictureEx::Load
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z
_TEXT	SEGMENT
tv66 = -12						; size = 4
_nRet$ = -8						; size = 4
_this$ = -4						; size = 4
_Value$ = 8						; size = 4
?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z PROC NEAR ; CPictureEx::TGIFLSDescriptor::GetPackedValue, COMDAT
; _this$ = ecx

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	int nRet = (int)m_cPacked;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00025	89 4d f8	 mov	 DWORD PTR _nRet$[ebp], ecx

; 118  : 
; 119  : 	switch (Value)

  00028	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  0002b	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  0002e	83 7d f4 03	 cmp	 DWORD PTR tv66[ebp], 3
  00032	77 3d		 ja	 SHORT $L187766
  00034	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00037	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L189694[eax*4]
$L187769:

; 120  : 	{
; 121  : 	case LSD_PACKED_GLOBALCT:
; 122  : 		nRet = nRet >> 7;

  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _nRet$[ebp]
  00041	c1 f9 07	 sar	 ecx, 7
  00044	89 4d f8	 mov	 DWORD PTR _nRet$[ebp], ecx

; 123  : 		break;

  00047	eb 28		 jmp	 SHORT $L187766
$L187770:

; 124  : 
; 125  : 	case LSD_PACKED_CRESOLUTION:
; 126  : 		nRet = ((nRet & 0x70) >> 4) + 1;

  00049	8b 55 f8	 mov	 edx, DWORD PTR _nRet$[ebp]
  0004c	83 e2 70	 and	 edx, 112		; 00000070H
  0004f	c1 fa 04	 sar	 edx, 4
  00052	83 c2 01	 add	 edx, 1
  00055	89 55 f8	 mov	 DWORD PTR _nRet$[ebp], edx

; 127  : 		break;

  00058	eb 17		 jmp	 SHORT $L187766
$L187771:

; 128  : 
; 129  : 	case LSD_PACKED_SORT:
; 130  : 		nRet = (nRet & 8) >> 3;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _nRet$[ebp]
  0005d	83 e0 08	 and	 eax, 8
  00060	c1 f8 03	 sar	 eax, 3
  00063	89 45 f8	 mov	 DWORD PTR _nRet$[ebp], eax

; 131  : 		break;

  00066	eb 09		 jmp	 SHORT $L187766
$L187772:

; 132  : 
; 133  : 	case LSD_PACKED_GLOBALCTSIZE:
; 134  : 		nRet &= 7;

  00068	8b 4d f8	 mov	 ecx, DWORD PTR _nRet$[ebp]
  0006b	83 e1 07	 and	 ecx, 7
  0006e	89 4d f8	 mov	 DWORD PTR _nRet$[ebp], ecx
$L187766:

; 135  : 		break;
; 136  : 	};
; 137  : 
; 138  : 	return nRet;

  00071	8b 45 f8	 mov	 eax, DWORD PTR _nRet$[ebp]

; 139  : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
$L189694:
  0007a	00 00 00 00	 DD	 $L187769
  0007e	00 00 00 00	 DD	 $L187770
  00082	00 00 00 00	 DD	 $L187771
  00086	00 00 00 00	 DD	 $L187772
?GetPackedValue@TGIFLSDescriptor@CPictureEx@@QAEHW4LSDPackedValues@2@@Z ENDP ; CPictureEx::TGIFLSDescriptor::GetPackedValue
_TEXT	ENDS
PUBLIC	?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
PUBLIC	?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end
PUBLIC	?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::clear
PUBLIC	??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator<
PUBLIC	??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
PUBLIC	??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*
PUBLIC	??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	__imp__DeleteObject@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv129 = -32						; size = 4
$T189698 = -28						; size = 4
$T189697 = -24						; size = 4
$T189696 = -20						; size = 4
_it$ = -12						; size = 4
_this$ = -4						; size = 4
?UnLoad@CPictureEx@@QAEXXZ PROC NEAR			; CPictureEx::UnLoad
; _this$ = ecx

; 428  : {

  00940	55		 push	 ebp
  00941	8b ec		 mov	 ebp, esp
  00943	83 ec 20	 sub	 esp, 32			; 00000020H
  00946	56		 push	 esi
  00947	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0094c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0094f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00952	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00955	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00958	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0095b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0095e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00961	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00964	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 	Stop();

  00967	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0096a	e8 00 00 00 00	 call	 ?Stop@CPictureEx@@QAEXXZ ; CPictureEx::Stop

; 430  : 	if (m_pPicture)

  0096f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00972	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  00976	74 25		 je	 SHORT $L187902

; 431  : 	{
; 432  : 		m_pPicture->Release();

  00978	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0097b	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0097e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00981	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00984	8b 12		 mov	 edx, DWORD PTR [edx]
  00986	8b f4		 mov	 esi, esp
  00988	51		 push	 ecx
  00989	ff 52 08	 call	 DWORD PTR [edx+8]
  0098c	3b f4		 cmp	 esi, esp
  0098e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 433  : 		m_pPicture = NULL;

  00993	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00996	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], 0
$L187902:

; 434  : 	};
; 435  : 	
; 436  : 	std::vector<TFrame>::iterator it;

  0099d	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  009a0	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator

; 437  : 	for (it=m_arrFrames.begin();it<m_arrFrames.end();it++)

  009a5	8d 4d ec	 lea	 ecx, DWORD PTR $T189696[ebp]
  009a8	51		 push	 ecx
  009a9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009ac	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  009b2	e8 00 00 00 00	 call	 ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
  009b7	8b 10		 mov	 edx, DWORD PTR [eax]
  009b9	89 55 f4	 mov	 DWORD PTR _it$[ebp], edx
  009bc	eb 0e		 jmp	 SHORT $L188024
$L188025:
  009be	6a 00		 push	 0
  009c0	8d 45 e8	 lea	 eax, DWORD PTR $T189697[ebp]
  009c3	50		 push	 eax
  009c4	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  009c7	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
$L188024:
  009cc	8d 4d e4	 lea	 ecx, DWORD PTR $T189698[ebp]
  009cf	51		 push	 ecx
  009d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009d3	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  009d9	e8 00 00 00 00	 call	 ?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end
  009de	50		 push	 eax
  009df	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  009e2	e8 00 00 00 00	 call	 ??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator<
  009e7	0f b6 d0	 movzx	 edx, al
  009ea	85 d2		 test	 edx, edx
  009ec	74 24		 je	 SHORT $L188026

; 438  : 		(*it).m_pPicture->Release();

  009ee	8d 4d f4	 lea	 ecx, DWORD PTR _it$[ebp]
  009f1	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*
  009f6	8b 00		 mov	 eax, DWORD PTR [eax]
  009f8	89 45 e0	 mov	 DWORD PTR tv129[ebp], eax
  009fb	8b 4d e0	 mov	 ecx, DWORD PTR tv129[ebp]
  009fe	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a00	8b f4		 mov	 esi, esp
  00a02	8b 45 e0	 mov	 eax, DWORD PTR tv129[ebp]
  00a05	50		 push	 eax
  00a06	ff 52 08	 call	 DWORD PTR [edx+8]
  00a09	3b f4		 cmp	 esi, esp
  00a0b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a10	eb ac		 jmp	 SHORT $L188025
$L188026:

; 439  : 	m_arrFrames.clear();

  00a12	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a15	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00a1b	e8 00 00 00 00	 call	 ?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::clear

; 440  : 
; 441  : 	if (m_hMemDC)

  00a20	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a23	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  00a27	74 5d		 je	 SHORT $L188027

; 442  : 	{
; 443  : 		SelectObject(m_hMemDC,m_hOldBitmap);

  00a29	8b f4		 mov	 esi, esp
  00a2b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a2e	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00a31	50		 push	 eax
  00a32	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a35	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00a38	52		 push	 edx
  00a39	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  00a3f	3b f4		 cmp	 esi, esp
  00a41	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 444  : 		::DeleteDC(m_hMemDC);

  00a46	8b f4		 mov	 esi, esp
  00a48	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a4b	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00a4e	51		 push	 ecx
  00a4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  00a55	3b f4		 cmp	 esi, esp
  00a57	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 445  : 		::DeleteObject(m_hBitmap);

  00a5c	8b f4		 mov	 esi, esp
  00a5e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a61	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00a64	50		 push	 eax
  00a65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  00a6b	3b f4		 cmp	 esi, esp
  00a6d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 446  : 		m_hMemDC  = NULL;

  00a72	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a75	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0

; 447  : 		m_hBitmap = NULL;

  00a7c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00a7f	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0
$L188027:

; 448  : 	};
; 449  : 
; 450  : 	if (m_hDispMemDC)

  00a86	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a89	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00a8d	74 5d		 je	 SHORT $L188028

; 451  : 	{
; 452  : 		SelectObject(m_hDispMemDC,m_hDispOldBM);

  00a8f	8b f4		 mov	 esi, esp
  00a91	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a94	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00a97	52		 push	 edx
  00a98	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a9b	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00a9e	51		 push	 ecx
  00a9f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  00aa5	3b f4		 cmp	 esi, esp
  00aa7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 453  : 		::DeleteDC(m_hDispMemDC);

  00aac	8b f4		 mov	 esi, esp
  00aae	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ab1	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00ab4	50		 push	 eax
  00ab5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  00abb	3b f4		 cmp	 esi, esp
  00abd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 454  : 		::DeleteObject(m_hDispMemBM);

  00ac2	8b f4		 mov	 esi, esp
  00ac4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ac7	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00aca	52		 push	 edx
  00acb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  00ad1	3b f4		 cmp	 esi, esp
  00ad3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 455  : 		m_hDispMemDC  = NULL;

  00ad8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00adb	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 456  : 		m_hDispMemBM = NULL;

  00ae2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae5	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0
$L188028:

; 457  : 	};
; 458  : 
; 459  : 	SetRect(&m_PaintRect,0,0,0,0);

  00aec	8b f4		 mov	 esi, esp
  00aee	6a 00		 push	 0
  00af0	6a 00		 push	 0
  00af2	6a 00		 push	 0
  00af4	6a 00		 push	 0
  00af6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00af9	83 c2 10	 add	 edx, 16			; 00000010H
  00afc	52		 push	 edx
  00afd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  00b03	3b f4		 cmp	 esi, esp
  00b05	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 460  : 	m_pGIFLSDescriptor = NULL;

  00b0a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b0d	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], 0

; 461  : 	m_pGIFHeader	   = NULL;

  00b14	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b17	c7 41 74 00 00
	00 00		 mov	 DWORD PTR [ecx+116], 0

; 462  : 	m_pRawData		   = NULL;

  00b1e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b21	c7 42 78 00 00
	00 00		 mov	 DWORD PTR [edx+120], 0

; 463  : 	m_hThread		   = NULL;

  00b28	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b2b	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 464  : 	m_bIsInitialized   = FALSE;

  00b32	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b35	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 465  : 	m_bExitThread	   = FALSE;

  00b3c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b3f	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 466  : 	m_bIsGIF		   = FALSE;

  00b46	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b49	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 467  : 	m_clrBackground    = RGB(255,255,255); // white by default

  00b50	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b53	c7 41 28 ff ff
	ff 00		 mov	 DWORD PTR [ecx+40], 16777215 ; 00ffffffH

; 468  : 	m_nGlobalCTSize	   = 0;

  00b5a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b5d	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 469  : 	m_nCurrOffset	   = 0;

  00b64	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00b67	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 470  : 	m_nCurrFrame	   = 0;

  00b6e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00b71	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0

; 471  : 	m_nDataSize		   = 0;

  00b78	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00b7b	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 472  : }

  00b82	52		 push	 edx
  00b83	8b cd		 mov	 ecx, ebp
  00b85	50		 push	 eax
  00b86	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189701
  00b8c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00b91	58		 pop	 eax
  00b92	5a		 pop	 edx
  00b93	5e		 pop	 esi
  00b94	83 c4 20	 add	 esp, 32			; 00000020H
  00b97	3b ec		 cmp	 ebp, esp
  00b99	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b9e	8b e5		 mov	 esp, ebp
  00ba0	5d		 pop	 ebp
  00ba1	c3		 ret	 0
$L189701:
  00ba2	01 00 00 00	 DD	 1
  00ba6	00 00 00 00	 DD	 $L189700
$L189700:
  00baa	f4 ff ff ff	 DD	 -12			; fffffff4H
  00bae	04 00 00 00	 DD	 4
  00bb2	00 00 00 00	 DD	 $L189699
$L189699:
  00bb6	69		 DB	 105			; 00000069H
  00bb7	74		 DB	 116			; 00000074H
  00bb8	00		 DB	 0
?UnLoad@CPictureEx@@QAEXXZ ENDP				; CPictureEx::UnLoad
_TEXT	ENDS
PUBLIC	?_ThreadAnimation@CPictureEx@@KGIPAX@Z		; CPictureEx::_ThreadAnimation
PUBLIC	?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z		; CPictureEx::OnPaint
PUBLIC	?IsAnimatedGIF@CPictureEx@@QBEHXZ		; CPictureEx::IsAnimatedGIF
PUBLIC	?Draw@CPictureEx@@QAEHXZ			; CPictureEx::Draw
EXTRN	__imp___beginthreadex:NEAR
EXTRN	__imp__ResumeThread@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T189704 = -56						; size = 8
$T189703 = -48						; size = 8
_hmHeight$188054 = -36					; size = 4
_hmWidth$188053 = -24					; size = 4
_nDummy$188044 = -12					; size = 4
_this$ = -4						; size = 4
?Draw@CPictureEx@@QAEHXZ PROC NEAR			; CPictureEx::Draw
; _this$ = ecx

; 475  : {

  00bc0	55		 push	 ebp
  00bc1	8b ec		 mov	 ebp, esp
  00bc3	83 ec 38	 sub	 esp, 56			; 00000038H
  00bc6	56		 push	 esi
  00bc7	57		 push	 edi
  00bc8	51		 push	 ecx
  00bc9	8d 7d c8	 lea	 edi, DWORD PTR [ebp-56]
  00bcc	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00bd1	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00bd6	f3 ab		 rep stosd
  00bd8	59		 pop	 ecx
  00bd9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 	if(m_hThread != NULL)

  00bdc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00bdf	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00be3	74 07		 je	 SHORT $L188038

; 477  : 		return FALSE;

  00be5	33 c0		 xor	 eax, eax
  00be7	e9 5a 01 00 00	 jmp	 $L188037
$L188038:

; 478  : 	if (!m_bIsInitialized)

  00bec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00bef	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  00bf3	75 27		 jne	 SHORT $L188039

; 479  : 	{
; 480  : 		TRACE(_T("Call one of the CPictureEx::Load() member functions before calling Draw()\n"));

  00bf5	68 00 00 00 00	 push	 OFFSET FLAT:$SG188042
  00bfa	68 e0 01 00 00	 push	 480			; 000001e0H
  00bff	68 00 00 00 00	 push	 OFFSET FLAT:$SG188041
  00c04	8d 4d d0	 lea	 ecx, DWORD PTR $T189703[ebp]
  00c07	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  00c0c	50		 push	 eax
  00c0d	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  00c12	83 c4 08	 add	 esp, 8

; 481  : 		return FALSE;

  00c15	33 c0		 xor	 eax, eax
  00c17	e9 2a 01 00 00	 jmp	 $L188037
$L188039:

; 482  : 	};
; 483  : 
; 484  : 	if (IsAnimatedGIF())

  00c1c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c1f	e8 00 00 00 00	 call	 ?IsAnimatedGIF@CPictureEx@@QBEHXZ ; CPictureEx::IsAnimatedGIF
  00c24	85 c0		 test	 eax, eax
  00c26	74 76		 je	 SHORT $L188043

; 485  : 	{
; 486  : 	// the picture needs animation
; 487  : 	// we'll start the thread that will handle it for us
; 488  : 	
; 489  : 		unsigned int nDummy;
; 490  : 		m_hThread = (HANDLE) _beginthreadex(NULL,0,_ThreadAnimation,this,
; 491  : 			CREATE_SUSPENDED,&nDummy);

  00c28	8b f4		 mov	 esi, esp
  00c2a	8d 55 f4	 lea	 edx, DWORD PTR _nDummy$188044[ebp]
  00c2d	52		 push	 edx
  00c2e	6a 04		 push	 4
  00c30	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c33	50		 push	 eax
  00c34	68 00 00 00 00	 push	 OFFSET FLAT:?_ThreadAnimation@CPictureEx@@KGIPAX@Z ; CPictureEx::_ThreadAnimation
  00c39	6a 00		 push	 0
  00c3b	6a 00		 push	 0
  00c3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___beginthreadex
  00c43	83 c4 18	 add	 esp, 24			; 00000018H
  00c46	3b f4		 cmp	 esi, esp
  00c48	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c4d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00c50	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 492  : 		if (!m_hThread)

  00c53	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00c56	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  00c5a	75 27		 jne	 SHORT $L188046

; 493  : 		{
; 494  : 			TRACE(_T("Draw: Couldn't start a GIF animation thread\n"));

  00c5c	68 00 00 00 00	 push	 OFFSET FLAT:$SG188049
  00c61	68 ee 01 00 00	 push	 494			; 000001eeH
  00c66	68 00 00 00 00	 push	 OFFSET FLAT:$SG188048
  00c6b	8d 4d c8	 lea	 ecx, DWORD PTR $T189704[ebp]
  00c6e	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  00c73	50		 push	 eax
  00c74	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  00c79	83 c4 08	 add	 esp, 8

; 495  : 			return FALSE;

  00c7c	33 c0		 xor	 eax, eax
  00c7e	e9 c3 00 00 00	 jmp	 $L188037
$L188046:

; 496  : 		} 
; 497  : 		else 
; 498  : 			ResumeThread(m_hThread);

  00c83	8b f4		 mov	 esi, esp
  00c85	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00c88	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00c8b	51		 push	 ecx
  00c8c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResumeThread@4
  00c92	3b f4		 cmp	 esi, esp
  00c94	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 499  : 	} 
; 500  : 	else

  00c99	e9 a6 00 00 00	 jmp	 $L188051
$L188043:

; 501  : 	{
; 502  : 		if (m_pPicture)

  00c9e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00ca1	83 7a 70 00	 cmp	 DWORD PTR [edx+112], 0
  00ca5	0f 84 99 00 00
	00		 je	 $L188051

; 503  : 		{
; 504  : 			long hmWidth;
; 505  : 			long hmHeight;
; 506  : 			m_pPicture->get_Width(&hmWidth);

  00cab	8b f4		 mov	 esi, esp
  00cad	8d 45 e8	 lea	 eax, DWORD PTR _hmWidth$188053[ebp]
  00cb0	50		 push	 eax
  00cb1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cb4	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00cb7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cba	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00cbd	8b 12		 mov	 edx, DWORD PTR [edx]
  00cbf	51		 push	 ecx
  00cc0	ff 52 18	 call	 DWORD PTR [edx+24]
  00cc3	3b f4		 cmp	 esi, esp
  00cc5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 507  : 			m_pPicture->get_Height(&hmHeight);

  00cca	8b f4		 mov	 esi, esp
  00ccc	8d 45 dc	 lea	 eax, DWORD PTR _hmHeight$188054[ebp]
  00ccf	50		 push	 eax
  00cd0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00cd3	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00cd6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00cd9	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00cdc	8b 12		 mov	 edx, DWORD PTR [edx]
  00cde	51		 push	 ecx
  00cdf	ff 52 1c	 call	 DWORD PTR [edx+28]
  00ce2	3b f4		 cmp	 esi, esp
  00ce4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 508  : 			if (m_pPicture->Render(m_hMemDC, 0, 0, m_PictureSize.cx, m_PictureSize.cy, 
; 509  : 				0, hmHeight, hmWidth, -hmHeight, NULL) == S_OK)

  00ce9	8b f4		 mov	 esi, esp
  00ceb	6a 00		 push	 0
  00ced	8b 45 dc	 mov	 eax, DWORD PTR _hmHeight$188054[ebp]
  00cf0	f7 d8		 neg	 eax
  00cf2	50		 push	 eax
  00cf3	8b 4d e8	 mov	 ecx, DWORD PTR _hmWidth$188053[ebp]
  00cf6	51		 push	 ecx
  00cf7	8b 55 dc	 mov	 edx, DWORD PTR _hmHeight$188054[ebp]
  00cfa	52		 push	 edx
  00cfb	6a 00		 push	 0
  00cfd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00d00	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00d03	51		 push	 ecx
  00d04	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00d07	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00d0a	50		 push	 eax
  00d0b	6a 00		 push	 0
  00d0d	6a 00		 push	 0
  00d0f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d12	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00d15	52		 push	 edx
  00d16	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00d19	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00d1c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00d1f	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00d22	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00d24	50		 push	 eax
  00d25	ff 51 20	 call	 DWORD PTR [ecx+32]
  00d28	3b f4		 cmp	 esi, esp
  00d2a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d2f	85 c0		 test	 eax, eax
  00d31	75 11		 jne	 SHORT $L188051

; 510  : 			{
; 511  : ////				Invalidate(FALSE);
; 512  : 				OnPaint();

  00d33	6a 00		 push	 0
  00d35	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00d38	e8 00 00 00 00	 call	 ?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z ; CPictureEx::OnPaint

; 513  : 				return TRUE;

  00d3d	b8 01 00 00 00	 mov	 eax, 1
  00d42	eb 02		 jmp	 SHORT $L188037
$L188051:

; 514  : 			};
; 515  : 		};
; 516  : 	};
; 517  : 
; 518  : 	return FALSE;	

  00d44	33 c0		 xor	 eax, eax
$L188037:

; 519  : }

  00d46	52		 push	 edx
  00d47	8b cd		 mov	 ecx, ebp
  00d49	50		 push	 eax
  00d4a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189709
  00d50	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00d55	58		 pop	 eax
  00d56	5a		 pop	 edx
  00d57	5f		 pop	 edi
  00d58	5e		 pop	 esi
  00d59	83 c4 38	 add	 esp, 56			; 00000038H
  00d5c	3b ec		 cmp	 ebp, esp
  00d5e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d63	8b e5		 mov	 esp, ebp
  00d65	5d		 pop	 ebp
  00d66	c3		 ret	 0
$L189709:
  00d67	03 00 00 00	 DD	 3
  00d6b	00 00 00 00	 DD	 $L189708
$L189708:
  00d6f	f4 ff ff ff	 DD	 -12			; fffffff4H
  00d73	04 00 00 00	 DD	 4
  00d77	00 00 00 00	 DD	 $L189705
  00d7b	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00d7f	04 00 00 00	 DD	 4
  00d83	00 00 00 00	 DD	 $L189706
  00d87	dc ff ff ff	 DD	 -36			; ffffffdcH
  00d8b	04 00 00 00	 DD	 4
  00d8f	00 00 00 00	 DD	 $L189707
$L189707:
  00d93	68		 DB	 104			; 00000068H
  00d94	6d		 DB	 109			; 0000006dH
  00d95	48		 DB	 72			; 00000048H
  00d96	65		 DB	 101			; 00000065H
  00d97	69		 DB	 105			; 00000069H
  00d98	67		 DB	 103			; 00000067H
  00d99	68		 DB	 104			; 00000068H
  00d9a	74		 DB	 116			; 00000074H
  00d9b	00		 DB	 0
$L189706:
  00d9c	68		 DB	 104			; 00000068H
  00d9d	6d		 DB	 109			; 0000006dH
  00d9e	57		 DB	 87			; 00000057H
  00d9f	69		 DB	 105			; 00000069H
  00da0	64		 DB	 100			; 00000064H
  00da1	74		 DB	 116			; 00000074H
  00da2	68		 DB	 104			; 00000068H
  00da3	00		 DB	 0
$L189705:
  00da4	6e		 DB	 110			; 0000006eH
  00da5	44		 DB	 68			; 00000044H
  00da6	75		 DB	 117			; 00000075H
  00da7	6d		 DB	 109			; 0000006dH
  00da8	6d		 DB	 109			; 0000006dH
  00da9	79		 DB	 121			; 00000079H
  00daa	00		 DB	 0
?Draw@CPictureEx@@QAEHXZ ENDP				; CPictureEx::Draw
_TEXT	ENDS
PUBLIC	?GetSize@CPictureEx@@QBE?AUtagSIZE@@XZ		; CPictureEx::GetSize
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetSize@CPictureEx@@QBE?AUtagSIZE@@XZ PROC NEAR	; CPictureEx::GetSize
; _this$ = ecx

; 522  : {

  00db0	55		 push	 ebp
  00db1	8b ec		 mov	 ebp, esp
  00db3	51		 push	 ecx
  00db4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00dbb	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 523  : 	return m_PictureSize;

  00dbe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00dc1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00dc4	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00dc7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00dca	89 08		 mov	 DWORD PTR [eax], ecx
  00dcc	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00dcf	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 524  : }

  00dd2	8b e5		 mov	 esp, ebp
  00dd4	5d		 pop	 ebp
  00dd5	c2 04 00	 ret	 4
?GetSize@CPictureEx@@QBE?AUtagSIZE@@XZ ENDP		; CPictureEx::GetSize
_TEXT	ENDS
PUBLIC	??_R0PAVCFileException@@@8			; CFileException * `RTTI Type Descriptor'
PUBLIC	??1AFX_EXCEPTION_LINK@@QAE@XZ			; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK
PUBLIC	?Load@CPictureEx@@QAEHPBD@Z			; CPictureEx::Load
EXTRN	__imp__GlobalAlloc@8:NEAR
EXTRN	?AfxAssertFailedLine@@YGHPBDH@Z:NEAR		; AfxAssertFailedLine
EXTRN	?IsKindOf@CObject@@QBEHPBUCRuntimeClass@@@Z:NEAR ; CObject::IsKindOf
EXTRN	?Delete@CException@@QAEXXZ:NEAR			; CException::Delete
EXTRN	??0AFX_EXCEPTION_LINK@@QAE@XZ:NEAR		; AFX_EXCEPTION_LINK::AFX_EXCEPTION_LINK
EXTRN	?GetThisClass@CFileException@@SGPAUCRuntimeClass@@XZ:NEAR ; CFileException::GetThisClass
EXTRN	??0CFile@@QAE@XZ:NEAR				; CFile::CFile
EXTRN	?Open@CFile@@UAEHPBDIPAVCFileException@@@Z:NEAR	; CFile::Open
EXTRN	?GetLength@CFile@@UBE_KXZ:NEAR			; CFile::GetLength
EXTRN	?Read@CFile@@UAEIPAXI@Z:NEAR			; CFile::Read
EXTRN	?Close@CFile@@UAEXXZ:NEAR			; CFile::Close
EXTRN	??1CFile@@UAE@XZ:NEAR				; CFile::~CFile
xdata$x	SEGMENT
$T189737 DD	0ffffffffH
	DD	FLAT:$L189725
	DD	00H
	DD	FLAT:$L189726
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T189739 DD	00H
	DD	FLAT:??_R0PAVCFileException@@@8
	DD	0ffffffb0H
	DD	FLAT:$L189724
$T189738 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T189739
$T189730 DD	019930520H
	DD	04H
	DD	FLAT:$T189737
	DD	01H
	DD	FLAT:$T189738
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_R0PAVCFileException@@@8
_DATA	SEGMENT
??_R0PAVCFileException@@@8 DD FLAT:??_7type_info@@6B@	; CFileException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCFileException@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
_TEXT	SEGMENT
$T189722 = -140						; size = 4
$T189721 = -136						; size = 4
$T189720 = -132						; size = 8
$T189718 = -124						; size = 4
$T189717 = -120						; size = 8
$T189716 = -112						; size = 4
$T189715 = -108						; size = 8
$T189714 = -100						; size = 4
$T189713 = -96						; size = 8
_bRetValue$ = -88					; size = 4
_e$188089 = -80						; size = 4
__afxExceptionLink$188087 = -68				; size = 8
_pData$ = -56						; size = 4
_dwSize$ = -52						; size = 4
_hGlobal$ = -48						; size = 4
_file$ = -40						; size = 16
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_szFileName$ = 8					; size = 4
?Load@CPictureEx@@QAEHPBD@Z PROC NEAR			; CPictureEx::Load
; _this$ = ecx

; 527  : {

  00de0	55		 push	 ebp
  00de1	8b ec		 mov	 ebp, esp
  00de3	6a ff		 push	 -1
  00de5	68 00 00 00 00	 push	 __ehhandler$?Load@CPictureEx@@QAEHPBD@Z
  00dea	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00df0	50		 push	 eax
  00df1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00df8	51		 push	 ecx
  00df9	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00dfc	53		 push	 ebx
  00dfd	56		 push	 esi
  00dfe	57		 push	 edi
  00dff	51		 push	 ecx
  00e00	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00e06	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00e0b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00e10	f3 ab		 rep stosd
  00e12	59		 pop	 ecx
  00e13	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00e16	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 528  : 	ASSERT(szFileName);

  00e19	83 7d 08 00	 cmp	 DWORD PTR _szFileName$[ebp], 0
  00e1d	75 14		 jne	 SHORT $L189712
  00e1f	68 10 02 00 00	 push	 528			; 00000210H
  00e24	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00e29	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00e2e	85 c0		 test	 eax, eax
  00e30	74 01		 je	 SHORT $L189712
  00e32	cc		 int	 3
$L189712:

; 529  : 	
; 530  : 	CFile file;

  00e33	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  00e36	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile
  00e3b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 531  : 	HGLOBAL hGlobal;
; 532  : 	DWORD dwSize;
; 533  : 
; 534  : 	if (!file.Open(szFileName,
; 535  : 				CFile::modeRead | 
; 536  : 				CFile::shareDenyWrite) )

  00e42	6a 00		 push	 0
  00e44	6a 20		 push	 32			; 00000020H
  00e46	8b 4d 08	 mov	 ecx, DWORD PTR _szFileName$[ebp]
  00e49	51		 push	 ecx
  00e4a	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  00e4d	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  00e52	85 c0		 test	 eax, eax
  00e54	75 42		 jne	 SHORT $L188069

; 537  : 	{
; 538  : 		TRACE(_T("Load (file): Error opening file %s\n"),szFileName);

  00e56	8b 55 08	 mov	 edx, DWORD PTR _szFileName$[ebp]
  00e59	52		 push	 edx
  00e5a	68 00 00 00 00	 push	 OFFSET FLAT:$SG188072
  00e5f	68 1a 02 00 00	 push	 538			; 0000021aH
  00e64	68 00 00 00 00	 push	 OFFSET FLAT:$SG188071
  00e69	8d 4d a0	 lea	 ecx, DWORD PTR $T189713[ebp]
  00e6c	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  00e71	50		 push	 eax
  00e72	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  00e77	83 c4 0c	 add	 esp, 12			; 0000000cH

; 539  : 		return FALSE;

  00e7a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T189714[ebp], 0
  00e81	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00e88	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  00e8b	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00e90	8b 45 9c	 mov	 eax, DWORD PTR $T189714[ebp]
  00e93	e9 16 02 00 00	 jmp	 $L188064
$L188069:

; 540  : 	};
; 541  : 
; 542  : 	dwSize = (DWORD)(file.GetLength());

  00e98	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  00e9b	e8 00 00 00 00	 call	 ?GetLength@CFile@@UBE_KXZ ; CFile::GetLength
  00ea0	89 45 cc	 mov	 DWORD PTR _dwSize$[ebp], eax

; 543  : 	hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,dwSize);

  00ea3	8b f4		 mov	 esi, esp
  00ea5	8b 45 cc	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00ea8	50		 push	 eax
  00ea9	6a 22		 push	 34			; 00000022H
  00eab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00eb1	3b f4		 cmp	 esi, esp
  00eb3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00eb8	89 45 d0	 mov	 DWORD PTR _hGlobal$[ebp], eax

; 544  : 	if (!hGlobal)

  00ebb	83 7d d0 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  00ebf	75 3e		 jne	 SHORT $L188075

; 545  : 	{
; 546  : 		TRACE(_T("Load (file): Error allocating memory\n"));

  00ec1	68 00 00 00 00	 push	 OFFSET FLAT:$SG188078
  00ec6	68 22 02 00 00	 push	 546			; 00000222H
  00ecb	68 00 00 00 00	 push	 OFFSET FLAT:$SG188077
  00ed0	8d 4d 94	 lea	 ecx, DWORD PTR $T189715[ebp]
  00ed3	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  00ed8	50		 push	 eax
  00ed9	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  00ede	83 c4 08	 add	 esp, 8

; 547  : 		return FALSE;

  00ee1	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T189716[ebp], 0
  00ee8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00eef	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  00ef2	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00ef7	8b 45 90	 mov	 eax, DWORD PTR $T189716[ebp]
  00efa	e9 af 01 00 00	 jmp	 $L188064
$L188075:

; 548  : 	};
; 549  : 	
; 550  : 	char *pData = reinterpret_cast<char*>(GlobalLock(hGlobal));

  00eff	8b f4		 mov	 esi, esp
  00f01	8b 4d d0	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  00f04	51		 push	 ecx
  00f05	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  00f0b	3b f4		 cmp	 esi, esp
  00f0d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00f12	89 45 c8	 mov	 DWORD PTR _pData$[ebp], eax

; 551  : 	if (!pData)

  00f15	83 7d c8 00	 cmp	 DWORD PTR _pData$[ebp], 0
  00f19	75 51		 jne	 SHORT $L188082

; 552  : 	{
; 553  : 		TRACE(_T("Load (file): Error locking memory\n"));

  00f1b	68 00 00 00 00	 push	 OFFSET FLAT:$SG188085
  00f20	68 29 02 00 00	 push	 553			; 00000229H
  00f25	68 00 00 00 00	 push	 OFFSET FLAT:$SG188084
  00f2a	8d 4d 88	 lea	 ecx, DWORD PTR $T189717[ebp]
  00f2d	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  00f32	50		 push	 eax
  00f33	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  00f38	83 c4 08	 add	 esp, 8

; 554  : 		GlobalFree(hGlobal);

  00f3b	8b f4		 mov	 esi, esp
  00f3d	8b 55 d0	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00f40	52		 push	 edx
  00f41	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  00f47	3b f4		 cmp	 esi, esp
  00f49	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 555  : 		return FALSE;

  00f4e	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T189718[ebp], 0
  00f55	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00f5c	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  00f5f	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  00f64	8b 45 84	 mov	 eax, DWORD PTR $T189718[ebp]
  00f67	e9 42 01 00 00	 jmp	 $L188064
$L188082:

; 556  : 	};
; 557  : 
; 558  : 	TRY

  00f6c	8d 4d bc	 lea	 ecx, DWORD PTR __afxExceptionLink$188087[ebp]
  00f6f	e8 00 00 00 00	 call	 ??0AFX_EXCEPTION_LINK@@QAE@XZ ; AFX_EXCEPTION_LINK::AFX_EXCEPTION_LINK
  00f74	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00f78	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 559  : 	{
; 560  : 		file.Read(pData,dwSize);

  00f7c	8b 45 cc	 mov	 eax, DWORD PTR _dwSize$[ebp]
  00f7f	50		 push	 eax
  00f80	8b 4d c8	 mov	 ecx, DWORD PTR _pData$[ebp]
  00f83	51		 push	 ecx
  00f84	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  00f87	e8 00 00 00 00	 call	 ?Read@CFile@@UAEIPAXI@Z	; CFile::Read
  00f8c	e9 86 00 00 00	 jmp	 $L189723
$L189724:

; 561  : 	}
; 562  : 	CATCH(CFileException, e);                                          

  00f91	e8 00 00 00 00	 call	 ?GetThisClass@CFileException@@SGPAUCRuntimeClass@@XZ ; CFileException::GetThisClass
  00f96	50		 push	 eax
  00f97	8b 4d b0	 mov	 ecx, DWORD PTR _e$188089[ebp]
  00f9a	e8 00 00 00 00	 call	 ?IsKindOf@CObject@@QBEHPBUCRuntimeClass@@@Z ; CObject::IsKindOf
  00f9f	85 c0		 test	 eax, eax
  00fa1	75 14		 jne	 SHORT $L189719
  00fa3	68 32 02 00 00	 push	 562			; 00000232H
  00fa8	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  00fad	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00fb2	85 c0		 test	 eax, eax
  00fb4	74 01		 je	 SHORT $L189719
  00fb6	cc		 int	 3
$L189719:
  00fb7	8b 45 b0	 mov	 eax, DWORD PTR _e$188089[ebp]
  00fba	89 45 c0	 mov	 DWORD PTR __afxExceptionLink$188087[ebp+4], eax

; 563  : 	{
; 564  : 		TRACE(_T("Load (file): An exception occured while reading the file %s\n"),

  00fbd	8b 4d 08	 mov	 ecx, DWORD PTR _szFileName$[ebp]
  00fc0	51		 push	 ecx
  00fc1	68 00 00 00 00	 push	 OFFSET FLAT:$SG188094
  00fc6	68 34 02 00 00	 push	 564			; 00000234H
  00fcb	68 00 00 00 00	 push	 OFFSET FLAT:$SG188093
  00fd0	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T189720[ebp]
  00fd6	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  00fdb	50		 push	 eax
  00fdc	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  00fe1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 565  : 			szFileName);
; 566  : 		GlobalFree(hGlobal);

  00fe4	8b f4		 mov	 esi, esp
  00fe6	8b 55 d0	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  00fe9	52		 push	 edx
  00fea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  00ff0	3b f4		 cmp	 esi, esp
  00ff2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 567  : 		e->Delete();

  00ff7	8b 4d b0	 mov	 ecx, DWORD PTR _e$188089[ebp]
  00ffa	e8 00 00 00 00	 call	 ?Delete@CException@@QAEXXZ ; CException::Delete

; 568  : 		file.Close();

  00fff	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  01002	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 569  : 		return FALSE;

  01007	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T189721[ebp], 0
  01011	b8 00 00 00 00	 mov	 eax, $L189728
  01016	c3		 ret	 0
$L189723:

; 570  : 	}
; 571  : 	END_CATCH

  01017	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0101e	eb 23		 jmp	 SHORT $L189727
$L189728:

; 569  : 		return FALSE;

  01020	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  01024	8d 4d bc	 lea	 ecx, DWORD PTR __afxExceptionLink$188087[ebp]
  01027	e8 00 00 00 00	 call	 ??1AFX_EXCEPTION_LINK@@QAE@XZ ; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK
  0102c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  01033	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  01036	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  0103b	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T189721[ebp]
  01041	eb 6b		 jmp	 SHORT $L188064
$L189727:

; 570  : 	}
; 571  : 	END_CATCH

  01043	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  01047	8d 4d bc	 lea	 ecx, DWORD PTR __afxExceptionLink$188087[ebp]
  0104a	e8 00 00 00 00	 call	 ??1AFX_EXCEPTION_LINK@@QAE@XZ ; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK

; 572  : 	GlobalUnlock(hGlobal);

  0104f	8b f4		 mov	 esi, esp
  01051	8b 45 d0	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  01054	50		 push	 eax
  01055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  0105b	3b f4		 cmp	 esi, esp
  0105d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 573  : 	file.Close();

  01062	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  01065	e8 00 00 00 00	 call	 ?Close@CFile@@UAEXXZ	; CFile::Close

; 574  : 
; 575  : 	BOOL bRetValue = Load(hGlobal,dwSize);

  0106a	8b 4d cc	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  0106d	51		 push	 ecx
  0106e	8b 55 d0	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  01071	52		 push	 edx
  01072	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  01075	e8 00 00 00 00	 call	 ?Load@CPictureEx@@QAEHPAXK@Z ; CPictureEx::Load
  0107a	89 45 a8	 mov	 DWORD PTR _bRetValue$[ebp], eax

; 576  : 	GlobalFree(hGlobal);

  0107d	8b f4		 mov	 esi, esp
  0107f	8b 45 d0	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  01082	50		 push	 eax
  01083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  01089	3b f4		 cmp	 esi, esp
  0108b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 577  : 	return bRetValue;

  01090	8b 4d a8	 mov	 ecx, DWORD PTR _bRetValue$[ebp]
  01093	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T189722[ebp], ecx
  01099	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  010a0	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  010a3	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  010a8	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T189722[ebp]
$L188064:

; 578  : }

  010ae	52		 push	 edx
  010af	8b cd		 mov	 ecx, ebp
  010b1	50		 push	 eax
  010b2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189736
  010b8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  010bd	58		 pop	 eax
  010be	5a		 pop	 edx
  010bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  010c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  010c9	5f		 pop	 edi
  010ca	5e		 pop	 esi
  010cb	5b		 pop	 ebx
  010cc	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  010d2	3b ec		 cmp	 ebp, esp
  010d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  010d9	8b e5		 mov	 esp, ebp
  010db	5d		 pop	 ebp
  010dc	c2 04 00	 ret	 4
$L189736:
  010df	03 00 00 00	 DD	 3
  010e3	00 00 00 00	 DD	 $L189735
$L189735:
  010e7	d8 ff ff ff	 DD	 -40			; ffffffd8H
  010eb	10 00 00 00	 DD	 16			; 00000010H
  010ef	00 00 00 00	 DD	 $L189731
  010f3	bc ff ff ff	 DD	 -68			; ffffffbcH
  010f7	08 00 00 00	 DD	 8
  010fb	00 00 00 00	 DD	 $L189732
  010ff	b0 ff ff ff	 DD	 -80			; ffffffb0H
  01103	04 00 00 00	 DD	 4
  01107	00 00 00 00	 DD	 $L189733
$L189733:
  0110b	65		 DB	 101			; 00000065H
  0110c	00		 DB	 0
$L189732:
  0110d	5f		 DB	 95			; 0000005fH
  0110e	61		 DB	 97			; 00000061H
  0110f	66		 DB	 102			; 00000066H
  01110	78		 DB	 120			; 00000078H
  01111	45		 DB	 69			; 00000045H
  01112	78		 DB	 120			; 00000078H
  01113	63		 DB	 99			; 00000063H
  01114	65		 DB	 101			; 00000065H
  01115	70		 DB	 112			; 00000070H
  01116	74		 DB	 116			; 00000074H
  01117	69		 DB	 105			; 00000069H
  01118	6f		 DB	 111			; 0000006fH
  01119	6e		 DB	 110			; 0000006eH
  0111a	4c		 DB	 76			; 0000004cH
  0111b	69		 DB	 105			; 00000069H
  0111c	6e		 DB	 110			; 0000006eH
  0111d	6b		 DB	 107			; 0000006bH
  0111e	00		 DB	 0
$L189731:
  0111f	66		 DB	 102			; 00000066H
  01120	69		 DB	 105			; 00000069H
  01121	6c		 DB	 108			; 0000006cH
  01122	65		 DB	 101			; 00000065H
  01123	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L189725:
  00058	8d 4d d8	 lea	 ecx, DWORD PTR _file$[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
$L189726:
  00060	8d 4d bc	 lea	 ecx, DWORD PTR __afxExceptionLink$188087[ebp]
  00063	e9 00 00 00 00	 jmp	 ??1AFX_EXCEPTION_LINK@@QAE@XZ ; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK
__ehhandler$?Load@CPictureEx@@QAEHPBD@Z:
  00068	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T189730
  0006d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Load@CPictureEx@@QAEHPBD@Z ENDP			; CPictureEx::Load
PUBLIC	?Load@CPictureEx@@QAEHPBD0@Z			; CPictureEx::Load
EXTRN	__imp__FreeResource@4:NEAR
EXTRN	__imp__LockResource@4:NEAR
EXTRN	?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ:NEAR ; AfxGetResourceHandle
EXTRN	__imp__FindResourceA@12:NEAR
EXTRN	__imp__LoadResource@8:NEAR
EXTRN	__imp__SizeofResource@8:NEAR
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T189745 = -56						; size = 8
$T189744 = -48						; size = 8
$T189743 = -40						; size = 8
_bRetValue$ = -32					; size = 4
_pSrc$ = -28						; size = 4
_pDest$ = -24						; size = 4
_hGlobal$ = -20						; size = 4
_dwSize$ = -16						; size = 4
_hResData$ = -12					; size = 4
_hPicture$ = -8						; size = 4
_this$ = -4						; size = 4
_szResourceName$ = 8					; size = 4
_szResourceType$ = 12					; size = 4
?Load@CPictureEx@@QAEHPBD0@Z PROC NEAR			; CPictureEx::Load
; _this$ = ecx

; 581  : {

  01130	55		 push	 ebp
  01131	8b ec		 mov	 ebp, esp
  01133	83 ec 38	 sub	 esp, 56			; 00000038H
  01136	56		 push	 esi
  01137	57		 push	 edi
  01138	51		 push	 ecx
  01139	8d 7d c8	 lea	 edi, DWORD PTR [ebp-56]
  0113c	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  01141	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  01146	f3 ab		 rep stosd
  01148	59		 pop	 ecx
  01149	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 582  : 	ASSERT(szResourceName);

  0114c	83 7d 08 00	 cmp	 DWORD PTR _szResourceName$[ebp], 0
  01150	75 14		 jne	 SHORT $L189741
  01152	68 46 02 00 00	 push	 582			; 00000246H
  01157	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  0115c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  01161	85 c0		 test	 eax, eax
  01163	74 01		 je	 SHORT $L189741
  01165	cc		 int	 3
$L189741:

; 583  : 	ASSERT(szResourceType);

  01166	83 7d 0c 00	 cmp	 DWORD PTR _szResourceType$[ebp], 0
  0116a	75 14		 jne	 SHORT $L189742
  0116c	68 47 02 00 00	 push	 583			; 00000247H
  01171	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  01176	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0117b	85 c0		 test	 eax, eax
  0117d	74 01		 je	 SHORT $L189742
  0117f	cc		 int	 3
$L189742:

; 584  : 
; 585  : 	HRSRC hPicture = FindResource(AfxGetResourceHandle(),szResourceName,szResourceType);

  01180	8b f4		 mov	 esi, esp
  01182	8b 55 0c	 mov	 edx, DWORD PTR _szResourceType$[ebp]
  01185	52		 push	 edx
  01186	8b 45 08	 mov	 eax, DWORD PTR _szResourceName$[ebp]
  01189	50		 push	 eax
  0118a	e8 00 00 00 00	 call	 ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ ; AfxGetResourceHandle
  0118f	50		 push	 eax
  01190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  01196	3b f4		 cmp	 esi, esp
  01198	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0119d	89 45 f8	 mov	 DWORD PTR _hPicture$[ebp], eax

; 586  : 	HGLOBAL hResData;
; 587  : 	if (!hPicture || !(hResData = LoadResource(AfxGetResourceHandle(),hPicture)))

  011a0	83 7d f8 00	 cmp	 DWORD PTR _hPicture$[ebp], 0
  011a4	74 22		 je	 SHORT $L188108
  011a6	8b f4		 mov	 esi, esp
  011a8	8b 4d f8	 mov	 ecx, DWORD PTR _hPicture$[ebp]
  011ab	51		 push	 ecx
  011ac	e8 00 00 00 00	 call	 ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ ; AfxGetResourceHandle
  011b1	50		 push	 eax
  011b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  011b8	3b f4		 cmp	 esi, esp
  011ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  011bf	89 45 f4	 mov	 DWORD PTR _hResData$[ebp], eax
  011c2	83 7d f4 00	 cmp	 DWORD PTR _hResData$[ebp], 0
  011c6	75 2b		 jne	 SHORT $L188107
$L188108:

; 588  : 	{
; 589  : 		TRACE(_T("Load (resource): Error loading resource %s\n"),szResourceName);

  011c8	8b 55 08	 mov	 edx, DWORD PTR _szResourceName$[ebp]
  011cb	52		 push	 edx
  011cc	68 00 00 00 00	 push	 OFFSET FLAT:$SG188111
  011d1	68 4d 02 00 00	 push	 589			; 0000024dH
  011d6	68 00 00 00 00	 push	 OFFSET FLAT:$SG188110
  011db	8d 4d d8	 lea	 ecx, DWORD PTR $T189743[ebp]
  011de	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  011e3	50		 push	 eax
  011e4	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  011e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 590  : 		return FALSE;

  011ec	33 c0		 xor	 eax, eax
  011ee	e9 59 01 00 00	 jmp	 $L188102
$L188107:

; 591  : 	};
; 592  : 	DWORD dwSize = SizeofResource(AfxGetResourceHandle(),hPicture);

  011f3	8b f4		 mov	 esi, esp
  011f5	8b 45 f8	 mov	 eax, DWORD PTR _hPicture$[ebp]
  011f8	50		 push	 eax
  011f9	e8 00 00 00 00	 call	 ?AfxGetResourceHandle@@YGPAUHINSTANCE__@@XZ ; AfxGetResourceHandle
  011fe	50		 push	 eax
  011ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8
  01205	3b f4		 cmp	 esi, esp
  01207	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0120c	89 45 f0	 mov	 DWORD PTR _dwSize$[ebp], eax

; 593  : 
; 594  : 	// hResData is not the real HGLOBAL (we can't lock it)
; 595  : 	// let's make it real
; 596  : 
; 597  : 	HGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,dwSize);

  0120f	8b f4		 mov	 esi, esp
  01211	8b 4d f0	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  01214	51		 push	 ecx
  01215	6a 22		 push	 34			; 00000022H
  01217	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  0121d	3b f4		 cmp	 esi, esp
  0121f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01224	89 45 ec	 mov	 DWORD PTR _hGlobal$[ebp], eax

; 598  : 	if (!hGlobal)

  01227	83 7d ec 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  0122b	75 3a		 jne	 SHORT $L188114

; 599  : 	{
; 600  : 		TRACE(_T("Load (resource): Error allocating memory\n"));

  0122d	68 00 00 00 00	 push	 OFFSET FLAT:$SG188117
  01232	68 58 02 00 00	 push	 600			; 00000258H
  01237	68 00 00 00 00	 push	 OFFSET FLAT:$SG188116
  0123c	8d 4d d0	 lea	 ecx, DWORD PTR $T189744[ebp]
  0123f	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  01244	50		 push	 eax
  01245	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  0124a	83 c4 08	 add	 esp, 8

; 601  : 		FreeResource(hResData);

  0124d	8b f4		 mov	 esi, esp
  0124f	8b 55 f4	 mov	 edx, DWORD PTR _hResData$[ebp]
  01252	52		 push	 edx
  01253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeResource@4
  01259	3b f4		 cmp	 esi, esp
  0125b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 602  : 		return FALSE;

  01260	33 c0		 xor	 eax, eax
  01262	e9 e5 00 00 00	 jmp	 $L188102
$L188114:

; 603  : 	};
; 604  : 	
; 605  : 	char *pDest = reinterpret_cast<char *> (GlobalLock(hGlobal));

  01267	8b f4		 mov	 esi, esp
  01269	8b 45 ec	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  0126c	50		 push	 eax
  0126d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  01273	3b f4		 cmp	 esi, esp
  01275	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0127a	89 45 e8	 mov	 DWORD PTR _pDest$[ebp], eax

; 606  : 	char *pSrc = reinterpret_cast<char *> (LockResource(hResData));

  0127d	8b f4		 mov	 esi, esp
  0127f	8b 4d f4	 mov	 ecx, DWORD PTR _hResData$[ebp]
  01282	51		 push	 ecx
  01283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LockResource@4
  01289	3b f4		 cmp	 esi, esp
  0128b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01290	89 45 e4	 mov	 DWORD PTR _pSrc$[ebp], eax

; 607  : 	if (!pSrc || !pDest)

  01293	83 7d e4 00	 cmp	 DWORD PTR _pSrc$[ebp], 0
  01297	74 06		 je	 SHORT $L188123
  01299	83 7d e8 00	 cmp	 DWORD PTR _pDest$[ebp], 0
  0129d	75 4a		 jne	 SHORT $L188122
$L188123:

; 608  : 	{
; 609  : 		TRACE(_T("Load (resource): Error locking memory\n"));

  0129f	68 00 00 00 00	 push	 OFFSET FLAT:$SG188126
  012a4	68 61 02 00 00	 push	 609			; 00000261H
  012a9	68 00 00 00 00	 push	 OFFSET FLAT:$SG188125
  012ae	8d 4d c8	 lea	 ecx, DWORD PTR $T189745[ebp]
  012b1	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  012b6	50		 push	 eax
  012b7	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  012bc	83 c4 08	 add	 esp, 8

; 610  : 		GlobalFree(hGlobal);

  012bf	8b f4		 mov	 esi, esp
  012c1	8b 55 ec	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  012c4	52		 push	 edx
  012c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  012cb	3b f4		 cmp	 esi, esp
  012cd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 611  : 		FreeResource(hResData);

  012d2	8b f4		 mov	 esi, esp
  012d4	8b 45 f4	 mov	 eax, DWORD PTR _hResData$[ebp]
  012d7	50		 push	 eax
  012d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeResource@4
  012de	3b f4		 cmp	 esi, esp
  012e0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 612  : 		return FALSE;

  012e5	33 c0		 xor	 eax, eax
  012e7	eb 63		 jmp	 SHORT $L188102
$L188122:

; 613  : 	};
; 614  : 	CopyMemory(pDest,pSrc,dwSize);

  012e9	8b 4d f0	 mov	 ecx, DWORD PTR _dwSize$[ebp]
  012ec	51		 push	 ecx
  012ed	8b 55 e4	 mov	 edx, DWORD PTR _pSrc$[ebp]
  012f0	52		 push	 edx
  012f1	8b 45 e8	 mov	 eax, DWORD PTR _pDest$[ebp]
  012f4	50		 push	 eax
  012f5	e8 00 00 00 00	 call	 _memcpy
  012fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 615  : 	FreeResource(hResData);

  012fd	8b f4		 mov	 esi, esp
  012ff	8b 4d f4	 mov	 ecx, DWORD PTR _hResData$[ebp]
  01302	51		 push	 ecx
  01303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeResource@4
  01309	3b f4		 cmp	 esi, esp
  0130b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 616  : 	GlobalUnlock(hGlobal);

  01310	8b f4		 mov	 esi, esp
  01312	8b 55 ec	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  01315	52		 push	 edx
  01316	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
  0131c	3b f4		 cmp	 esi, esp
  0131e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 617  : 
; 618  : 	BOOL bRetValue = Load(hGlobal,dwSize);

  01323	8b 45 f0	 mov	 eax, DWORD PTR _dwSize$[ebp]
  01326	50		 push	 eax
  01327	8b 4d ec	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  0132a	51		 push	 ecx
  0132b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0132e	e8 00 00 00 00	 call	 ?Load@CPictureEx@@QAEHPAXK@Z ; CPictureEx::Load
  01333	89 45 e0	 mov	 DWORD PTR _bRetValue$[ebp], eax

; 619  : 	GlobalFree(hGlobal);

  01336	8b f4		 mov	 esi, esp
  01338	8b 55 ec	 mov	 edx, DWORD PTR _hGlobal$[ebp]
  0133b	52		 push	 edx
  0133c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
  01342	3b f4		 cmp	 esi, esp
  01344	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 620  : 	return bRetValue;

  01349	8b 45 e0	 mov	 eax, DWORD PTR _bRetValue$[ebp]
$L188102:

; 621  : }

  0134c	5f		 pop	 edi
  0134d	5e		 pop	 esi
  0134e	83 c4 38	 add	 esp, 56			; 00000038H
  01351	3b ec		 cmp	 ebp, esp
  01353	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01358	8b e5		 mov	 esp, ebp
  0135a	5d		 pop	 ebp
  0135b	c2 08 00	 ret	 8
?Load@CPictureEx@@QAEHPBD0@Z ENDP			; CPictureEx::Load
; Function compile flags: /Odt /RTCsu
_this$ = -4						; size = 4
?ResetDataPointer@CPictureEx@@IAEXXZ PROC NEAR		; CPictureEx::ResetDataPointer
; _this$ = ecx

; 624  : {

  01360	55		 push	 ebp
  01361	8b ec		 mov	 ebp, esp
  01363	51		 push	 ecx
  01364	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0136b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 625  : 	// skip header and logical screen descriptor
; 626  : 	m_nCurrOffset = 
; 627  : 		sizeof(TGIFHeader)+sizeof(TGIFLSDescriptor)+m_nGlobalCTSize;

  0136e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01371	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01374	83 c1 0d	 add	 ecx, 13			; 0000000dH
  01377	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0137a	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 628  : }

  0137d	8b e5		 mov	 esp, ebp
  0137f	5d		 pop	 ebp
  01380	c3		 ret	 0
?ResetDataPointer@CPictureEx@@IAEXXZ ENDP		; CPictureEx::ResetDataPointer
_TEXT	ENDS
PUBLIC	?GetNextBlockLen@CPictureEx@@IBEHXZ		; CPictureEx::GetNextBlockLen
PUBLIC	?SkipNextBlock@CPictureEx@@IAEHXZ		; CPictureEx::SkipNextBlock
PUBLIC	?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_nBlock$ = -8						; size = 4
_this$ = -4						; size = 4
?SkipNextGraphicBlock@CPictureEx@@IAEHXZ PROC NEAR	; CPictureEx::SkipNextGraphicBlock
; _this$ = ecx

; 631  : {

  01390	55		 push	 ebp
  01391	8b ec		 mov	 ebp, esp
  01393	83 ec 08	 sub	 esp, 8
  01396	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0139d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  013a4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 	if (!m_pRawData) return FALSE;

  013a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  013aa	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  013ae	75 07		 jne	 SHORT $L188136
  013b0	33 c0		 xor	 eax, eax
  013b2	e9 e7 00 00 00	 jmp	 $L188135
$L188136:

; 633  : 
; 634  : 	// GIF header + LSDescriptor [+ GCT] [+ Control block] + Data
; 635  : 
; 636  : 	enum GIFBlockTypes nBlock;
; 637  : 
; 638  : 	nBlock = GetNextBlock();

  013b7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013ba	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  013bf	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax
$L188139:

; 639  : 
; 640  : 	while ((nBlock != BLOCK_CONTROLEXT) &&
; 641  : 		   (nBlock != BLOCK_IMAGE) &&
; 642  : 		   (nBlock != BLOCK_PLAINTEXT) &&
; 643  : 		   (nBlock != BLOCK_UNKNOWN) &&
; 644  : 		   (nBlock != BLOCK_TRAILER) )

  013c2	83 7d f8 03	 cmp	 DWORD PTR _nBlock$[ebp], 3
  013c6	74 38		 je	 SHORT $L188140
  013c8	83 7d f8 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  013cc	74 32		 je	 SHORT $L188140
  013ce	83 7d f8 04	 cmp	 DWORD PTR _nBlock$[ebp], 4
  013d2	74 2c		 je	 SHORT $L188140
  013d4	83 7d f8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  013d8	74 26		 je	 SHORT $L188140
  013da	83 7d f8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  013de	74 20		 je	 SHORT $L188140

; 645  : 	{
; 646  : 		if (!SkipNextBlock()) return NULL;

  013e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013e3	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  013e8	85 c0		 test	 eax, eax
  013ea	75 07		 jne	 SHORT $L188141
  013ec	33 c0		 xor	 eax, eax
  013ee	e9 ab 00 00 00	 jmp	 $L188135
$L188141:

; 647  : 		nBlock = GetNextBlock();

  013f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013f6	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  013fb	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax

; 648  : 	};

  013fe	eb c2		 jmp	 SHORT $L188139
$L188140:

; 649  : 
; 650  : 	if ((nBlock == BLOCK_UNKNOWN) ||
; 651  : 		(nBlock == BLOCK_TRAILER))

  01400	83 7d f8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  01404	74 06		 je	 SHORT $L188143
  01406	83 7d f8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  0140a	75 07		 jne	 SHORT $L188142
$L188143:

; 652  : 		return FALSE;

  0140c	33 c0		 xor	 eax, eax
  0140e	e9 8b 00 00 00	 jmp	 $L188135
$L188142:

; 653  : 
; 654  : 	// it's either a control ext.block, an image or a plain text
; 655  : 
; 656  : 	if (GetNextBlockLen() <= 0) return FALSE;

  01413	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01416	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  0141b	85 c0		 test	 eax, eax
  0141d	7f 04		 jg	 SHORT $L188144
  0141f	33 c0		 xor	 eax, eax
  01421	eb 7b		 jmp	 SHORT $L188135
$L188144:

; 657  : 
; 658  : 	if (nBlock == BLOCK_CONTROLEXT)

  01423	83 7d f8 03	 cmp	 DWORD PTR _nBlock$[ebp], 3
  01427	75 60		 jne	 SHORT $L188145

; 659  : 	{
; 660  : 		if (!SkipNextBlock()) return FALSE;

  01429	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0142c	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  01431	85 c0		 test	 eax, eax
  01433	75 04		 jne	 SHORT $L188146
  01435	33 c0		 xor	 eax, eax
  01437	eb 65		 jmp	 SHORT $L188135
$L188146:

; 661  : 		nBlock = GetNextBlock();

  01439	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0143c	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  01441	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax
$L188148:

; 662  : 
; 663  : 		// skip everything until we meet an image block or a plain-text block
; 664  : 		while ((nBlock != BLOCK_IMAGE) &&
; 665  : 			   (nBlock != BLOCK_PLAINTEXT) &&
; 666  : 			   (nBlock != BLOCK_UNKNOWN) &&
; 667  : 			   (nBlock != BLOCK_TRAILER) )

  01444	83 7d f8 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  01448	74 2f		 je	 SHORT $L188149
  0144a	83 7d f8 04	 cmp	 DWORD PTR _nBlock$[ebp], 4
  0144e	74 29		 je	 SHORT $L188149
  01450	83 7d f8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  01454	74 23		 je	 SHORT $L188149
  01456	83 7d f8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  0145a	74 1d		 je	 SHORT $L188149

; 668  : 		{
; 669  : 			if (!SkipNextBlock()) return NULL;

  0145c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0145f	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  01464	85 c0		 test	 eax, eax
  01466	75 04		 jne	 SHORT $L188150
  01468	33 c0		 xor	 eax, eax
  0146a	eb 32		 jmp	 SHORT $L188135
$L188150:

; 670  : 			nBlock = GetNextBlock();

  0146c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0146f	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  01474	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax

; 671  : 		};

  01477	eb cb		 jmp	 SHORT $L188148
$L188149:

; 672  : 
; 673  : 		if ((nBlock == BLOCK_UNKNOWN) ||
; 674  : 			(nBlock == BLOCK_TRAILER))

  01479	83 7d f8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  0147d	74 06		 je	 SHORT $L188152
  0147f	83 7d f8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  01483	75 04		 jne	 SHORT $L188145
$L188152:

; 675  : 			return FALSE;

  01485	33 c0		 xor	 eax, eax
  01487	eb 15		 jmp	 SHORT $L188135
$L188145:

; 676  : 	};
; 677  : 
; 678  : 	// skip the found data block (image or plain-text)
; 679  : 	if (!SkipNextBlock()) return FALSE;

  01489	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0148c	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  01491	85 c0		 test	 eax, eax
  01493	75 04		 jne	 SHORT $L188153
  01495	33 c0		 xor	 eax, eax
  01497	eb 05		 jmp	 SHORT $L188135
$L188153:

; 680  : 
; 681  : 	return TRUE;

  01499	b8 01 00 00 00	 mov	 eax, 1
$L188135:

; 682  : }

  0149e	83 c4 08	 add	 esp, 8
  014a1	3b ec		 cmp	 ebp, esp
  014a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  014a8	8b e5		 mov	 esp, ebp
  014aa	5d		 pop	 ebp
  014ab	c3		 ret	 0
?SkipNextGraphicBlock@CPictureEx@@IAEHXZ ENDP		; CPictureEx::SkipNextGraphicBlock
_TEXT	ENDS
PUBLIC	?GetSubBlocksLen@CPictureEx@@IBEII@Z		; CPictureEx::GetSubBlocksLen
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_nCurOffset$ = -12					; size = 4
_nRet$ = -8						; size = 4
_this$ = -4						; size = 4
_nStartingOffset$ = 8					; size = 4
?GetSubBlocksLen@CPictureEx@@IBEII@Z PROC NEAR		; CPictureEx::GetSubBlocksLen
; _this$ = ecx

; 685  : {

  014b0	55		 push	 ebp
  014b1	8b ec		 mov	 ebp, esp
  014b3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  014b6	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  014bd	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  014c4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  014cb	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 686  : 	UINT nRet = 0;

  014ce	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nRet$[ebp], 0

; 687  : 	UINT nCurOffset = nStartingOffset;

  014d5	8b 45 08	 mov	 eax, DWORD PTR _nStartingOffset$[ebp]
  014d8	89 45 f4	 mov	 DWORD PTR _nCurOffset$[ebp], eax
$L188161:

; 688  : 	
; 689  : 	while (m_pRawData[nCurOffset] != 0)

  014db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  014de	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  014e1	8b 45 f4	 mov	 eax, DWORD PTR _nCurOffset$[ebp]
  014e4	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  014e8	85 c9		 test	 ecx, ecx
  014ea	74 30		 je	 SHORT $L188162

; 690  : 	{
; 691  : 		nRet += m_pRawData[nCurOffset]+1;

  014ec	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  014ef	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  014f2	8b 4d f4	 mov	 ecx, DWORD PTR _nCurOffset$[ebp]
  014f5	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  014f9	8b 45 f8	 mov	 eax, DWORD PTR _nRet$[ebp]
  014fc	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  01500	89 4d f8	 mov	 DWORD PTR _nRet$[ebp], ecx

; 692  : 		nCurOffset += m_pRawData[nCurOffset]+1;

  01503	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01506	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  01509	8b 4d f4	 mov	 ecx, DWORD PTR _nCurOffset$[ebp]
  0150c	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  01510	8b 45 f4	 mov	 eax, DWORD PTR _nCurOffset$[ebp]
  01513	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  01517	89 4d f4	 mov	 DWORD PTR _nCurOffset$[ebp], ecx

; 693  : 	};

  0151a	eb bf		 jmp	 SHORT $L188161
$L188162:

; 694  : 
; 695  : 	return nRet+1;

  0151c	8b 45 f8	 mov	 eax, DWORD PTR _nRet$[ebp]
  0151f	83 c0 01	 add	 eax, 1

; 696  : }

  01522	8b e5		 mov	 esp, ebp
  01524	5d		 pop	 ebp
  01525	c2 04 00	 ret	 4
?GetSubBlocksLen@CPictureEx@@IBEII@Z ENDP		; CPictureEx::GetSubBlocksLen
; Function compile flags: /Odt /RTCsu
tv74 = -12						; size = 4
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ PROC NEAR ; CPictureEx::GetNextBlock
; _this$ = ecx

; 699  : {

  01530	55		 push	 ebp
  01531	8b ec		 mov	 ebp, esp
  01533	83 ec 0c	 sub	 esp, 12			; 0000000cH
  01536	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0153d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  01544	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0154b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 700  : 	switch(m_pRawData[m_nCurrOffset])

  0154e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01551	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  01554	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01557	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0155a	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  0155d	88 4d f8	 mov	 BYTE PTR tv68[ebp], cl
  01560	80 7d f8 21	 cmp	 BYTE PTR tv68[ebp], 33	; 00000021H
  01564	74 0e		 je	 SHORT $L188170
  01566	80 7d f8 2c	 cmp	 BYTE PTR tv68[ebp], 44	; 0000002cH
  0156a	74 64		 je	 SHORT $L188180
  0156c	80 7d f8 3b	 cmp	 BYTE PTR tv68[ebp], 59	; 0000003bH
  01570	74 57		 je	 SHORT $L188179
  01572	eb 63		 jmp	 SHORT $L188167
$L188170:

; 701  : 	{
; 702  : 	case 0x21:
; 703  : 	// extension block
; 704  : 		switch(m_pRawData[m_nCurrOffset+1])

  01574	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01577	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0157a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0157d	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  01580	0f b6 44 02 01	 movzx	 eax, BYTE PTR [edx+eax+1]
  01585	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  01588	8b 4d f4	 mov	 ecx, DWORD PTR tv74[ebp]
  0158b	83 e9 01	 sub	 ecx, 1
  0158e	89 4d f4	 mov	 DWORD PTR tv74[ebp], ecx
  01591	81 7d f4 fe 00
	00 00		 cmp	 DWORD PTR tv74[ebp], 254 ; 000000feH
  01598	77 2d		 ja	 SHORT $L188172
  0159a	8b 55 f4	 mov	 edx, DWORD PTR tv74[ebp]
  0159d	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $L189750[edx]
  015a4	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L189751[eax*4]
$L188175:

; 705  : 		{
; 706  : 		case 0x01:
; 707  : 		// plain text extension
; 708  : 			return BLOCK_PLAINTEXT;

  015ab	b8 04 00 00 00	 mov	 eax, 4
  015b0	eb 27		 jmp	 SHORT $L188165
$L188176:

; 709  : 			break;
; 710  : 
; 711  : 		case 0xF9:
; 712  : 		// graphic control extension
; 713  : 			return BLOCK_CONTROLEXT;

  015b2	b8 03 00 00 00	 mov	 eax, 3
  015b7	eb 20		 jmp	 SHORT $L188165
$L188177:

; 714  : 			break;
; 715  : 
; 716  : 		case 0xFE:
; 717  : 		// comment extension
; 718  : 			return BLOCK_COMMEXT;

  015b9	b8 02 00 00 00	 mov	 eax, 2
  015be	eb 19		 jmp	 SHORT $L188165
$L188178:

; 719  : 			break;
; 720  : 
; 721  : 		case 0xFF:
; 722  : 		// application extension
; 723  : 			return BLOCK_APPEXT;

  015c0	b8 01 00 00 00	 mov	 eax, 1
  015c5	eb 12		 jmp	 SHORT $L188165
$L188172:

; 724  : 			break;
; 725  : 		};
; 726  : 		break;

  015c7	eb 0e		 jmp	 SHORT $L188167
$L188179:

; 727  : 	
; 728  : 	case 0x3B:
; 729  : 	// trailer
; 730  : 		return BLOCK_TRAILER;

  015c9	b8 06 00 00 00	 mov	 eax, 6
  015ce	eb 09		 jmp	 SHORT $L188165
$L188180:

; 731  : 		break;
; 732  : 
; 733  : 	case 0x2C:
; 734  : 	// image data
; 735  : 		return BLOCK_IMAGE;

  015d0	b8 05 00 00 00	 mov	 eax, 5
  015d5	eb 02		 jmp	 SHORT $L188165
$L188167:

; 736  : 		break;
; 737  : 	};
; 738  : 
; 739  : 	return BLOCK_UNKNOWN;

  015d7	33 c0		 xor	 eax, eax
$L188165:

; 740  : }

  015d9	8b e5		 mov	 esp, ebp
  015db	5d		 pop	 ebp
  015dc	c3		 ret	 0
$L189751:
  015dd	00 00 00 00	 DD	 $L188175
  015e1	00 00 00 00	 DD	 $L188176
  015e5	00 00 00 00	 DD	 $L188177
  015e9	00 00 00 00	 DD	 $L188178
  015ed	00 00 00 00	 DD	 $L188172
$L189750:
  015f1	00		 DB	 0
  015f2	04		 DB	 4
  015f3	04		 DB	 4
  015f4	04		 DB	 4
  015f5	04		 DB	 4
  015f6	04		 DB	 4
  015f7	04		 DB	 4
  015f8	04		 DB	 4
  015f9	04		 DB	 4
  015fa	04		 DB	 4
  015fb	04		 DB	 4
  015fc	04		 DB	 4
  015fd	04		 DB	 4
  015fe	04		 DB	 4
  015ff	04		 DB	 4
  01600	04		 DB	 4
  01601	04		 DB	 4
  01602	04		 DB	 4
  01603	04		 DB	 4
  01604	04		 DB	 4
  01605	04		 DB	 4
  01606	04		 DB	 4
  01607	04		 DB	 4
  01608	04		 DB	 4
  01609	04		 DB	 4
  0160a	04		 DB	 4
  0160b	04		 DB	 4
  0160c	04		 DB	 4
  0160d	04		 DB	 4
  0160e	04		 DB	 4
  0160f	04		 DB	 4
  01610	04		 DB	 4
  01611	04		 DB	 4
  01612	04		 DB	 4
  01613	04		 DB	 4
  01614	04		 DB	 4
  01615	04		 DB	 4
  01616	04		 DB	 4
  01617	04		 DB	 4
  01618	04		 DB	 4
  01619	04		 DB	 4
  0161a	04		 DB	 4
  0161b	04		 DB	 4
  0161c	04		 DB	 4
  0161d	04		 DB	 4
  0161e	04		 DB	 4
  0161f	04		 DB	 4
  01620	04		 DB	 4
  01621	04		 DB	 4
  01622	04		 DB	 4
  01623	04		 DB	 4
  01624	04		 DB	 4
  01625	04		 DB	 4
  01626	04		 DB	 4
  01627	04		 DB	 4
  01628	04		 DB	 4
  01629	04		 DB	 4
  0162a	04		 DB	 4
  0162b	04		 DB	 4
  0162c	04		 DB	 4
  0162d	04		 DB	 4
  0162e	04		 DB	 4
  0162f	04		 DB	 4
  01630	04		 DB	 4
  01631	04		 DB	 4
  01632	04		 DB	 4
  01633	04		 DB	 4
  01634	04		 DB	 4
  01635	04		 DB	 4
  01636	04		 DB	 4
  01637	04		 DB	 4
  01638	04		 DB	 4
  01639	04		 DB	 4
  0163a	04		 DB	 4
  0163b	04		 DB	 4
  0163c	04		 DB	 4
  0163d	04		 DB	 4
  0163e	04		 DB	 4
  0163f	04		 DB	 4
  01640	04		 DB	 4
  01641	04		 DB	 4
  01642	04		 DB	 4
  01643	04		 DB	 4
  01644	04		 DB	 4
  01645	04		 DB	 4
  01646	04		 DB	 4
  01647	04		 DB	 4
  01648	04		 DB	 4
  01649	04		 DB	 4
  0164a	04		 DB	 4
  0164b	04		 DB	 4
  0164c	04		 DB	 4
  0164d	04		 DB	 4
  0164e	04		 DB	 4
  0164f	04		 DB	 4
  01650	04		 DB	 4
  01651	04		 DB	 4
  01652	04		 DB	 4
  01653	04		 DB	 4
  01654	04		 DB	 4
  01655	04		 DB	 4
  01656	04		 DB	 4
  01657	04		 DB	 4
  01658	04		 DB	 4
  01659	04		 DB	 4
  0165a	04		 DB	 4
  0165b	04		 DB	 4
  0165c	04		 DB	 4
  0165d	04		 DB	 4
  0165e	04		 DB	 4
  0165f	04		 DB	 4
  01660	04		 DB	 4
  01661	04		 DB	 4
  01662	04		 DB	 4
  01663	04		 DB	 4
  01664	04		 DB	 4
  01665	04		 DB	 4
  01666	04		 DB	 4
  01667	04		 DB	 4
  01668	04		 DB	 4
  01669	04		 DB	 4
  0166a	04		 DB	 4
  0166b	04		 DB	 4
  0166c	04		 DB	 4
  0166d	04		 DB	 4
  0166e	04		 DB	 4
  0166f	04		 DB	 4
  01670	04		 DB	 4
  01671	04		 DB	 4
  01672	04		 DB	 4
  01673	04		 DB	 4
  01674	04		 DB	 4
  01675	04		 DB	 4
  01676	04		 DB	 4
  01677	04		 DB	 4
  01678	04		 DB	 4
  01679	04		 DB	 4
  0167a	04		 DB	 4
  0167b	04		 DB	 4
  0167c	04		 DB	 4
  0167d	04		 DB	 4
  0167e	04		 DB	 4
  0167f	04		 DB	 4
  01680	04		 DB	 4
  01681	04		 DB	 4
  01682	04		 DB	 4
  01683	04		 DB	 4
  01684	04		 DB	 4
  01685	04		 DB	 4
  01686	04		 DB	 4
  01687	04		 DB	 4
  01688	04		 DB	 4
  01689	04		 DB	 4
  0168a	04		 DB	 4
  0168b	04		 DB	 4
  0168c	04		 DB	 4
  0168d	04		 DB	 4
  0168e	04		 DB	 4
  0168f	04		 DB	 4
  01690	04		 DB	 4
  01691	04		 DB	 4
  01692	04		 DB	 4
  01693	04		 DB	 4
  01694	04		 DB	 4
  01695	04		 DB	 4
  01696	04		 DB	 4
  01697	04		 DB	 4
  01698	04		 DB	 4
  01699	04		 DB	 4
  0169a	04		 DB	 4
  0169b	04		 DB	 4
  0169c	04		 DB	 4
  0169d	04		 DB	 4
  0169e	04		 DB	 4
  0169f	04		 DB	 4
  016a0	04		 DB	 4
  016a1	04		 DB	 4
  016a2	04		 DB	 4
  016a3	04		 DB	 4
  016a4	04		 DB	 4
  016a5	04		 DB	 4
  016a6	04		 DB	 4
  016a7	04		 DB	 4
  016a8	04		 DB	 4
  016a9	04		 DB	 4
  016aa	04		 DB	 4
  016ab	04		 DB	 4
  016ac	04		 DB	 4
  016ad	04		 DB	 4
  016ae	04		 DB	 4
  016af	04		 DB	 4
  016b0	04		 DB	 4
  016b1	04		 DB	 4
  016b2	04		 DB	 4
  016b3	04		 DB	 4
  016b4	04		 DB	 4
  016b5	04		 DB	 4
  016b6	04		 DB	 4
  016b7	04		 DB	 4
  016b8	04		 DB	 4
  016b9	04		 DB	 4
  016ba	04		 DB	 4
  016bb	04		 DB	 4
  016bc	04		 DB	 4
  016bd	04		 DB	 4
  016be	04		 DB	 4
  016bf	04		 DB	 4
  016c0	04		 DB	 4
  016c1	04		 DB	 4
  016c2	04		 DB	 4
  016c3	04		 DB	 4
  016c4	04		 DB	 4
  016c5	04		 DB	 4
  016c6	04		 DB	 4
  016c7	04		 DB	 4
  016c8	04		 DB	 4
  016c9	04		 DB	 4
  016ca	04		 DB	 4
  016cb	04		 DB	 4
  016cc	04		 DB	 4
  016cd	04		 DB	 4
  016ce	04		 DB	 4
  016cf	04		 DB	 4
  016d0	04		 DB	 4
  016d1	04		 DB	 4
  016d2	04		 DB	 4
  016d3	04		 DB	 4
  016d4	04		 DB	 4
  016d5	04		 DB	 4
  016d6	04		 DB	 4
  016d7	04		 DB	 4
  016d8	04		 DB	 4
  016d9	04		 DB	 4
  016da	04		 DB	 4
  016db	04		 DB	 4
  016dc	04		 DB	 4
  016dd	04		 DB	 4
  016de	04		 DB	 4
  016df	04		 DB	 4
  016e0	04		 DB	 4
  016e1	04		 DB	 4
  016e2	04		 DB	 4
  016e3	04		 DB	 4
  016e4	04		 DB	 4
  016e5	04		 DB	 4
  016e6	04		 DB	 4
  016e7	04		 DB	 4
  016e8	04		 DB	 4
  016e9	01		 DB	 1
  016ea	04		 DB	 4
  016eb	04		 DB	 4
  016ec	04		 DB	 4
  016ed	04		 DB	 4
  016ee	02		 DB	 2
  016ef	03		 DB	 3
?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ENDP ; CPictureEx::GetNextBlock
; Function compile flags: /Odt /RTCsu
_nLen$ = -8						; size = 4
_this$ = -4						; size = 4
?SkipNextBlock@CPictureEx@@IAEHXZ PROC NEAR		; CPictureEx::SkipNextBlock
; _this$ = ecx

; 743  : {

  016f0	55		 push	 ebp
  016f1	8b ec		 mov	 ebp, esp
  016f3	83 ec 08	 sub	 esp, 8
  016f6	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  016fd	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  01704	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 	if (!m_pRawData) return FALSE;

  01707	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0170a	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  0170e	75 04		 jne	 SHORT $L188184
  01710	33 c0		 xor	 eax, eax
  01712	eb 3a		 jmp	 SHORT $L188183
$L188184:

; 745  : 
; 746  : 	int nLen = GetNextBlockLen();

  01714	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01717	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  0171c	89 45 f8	 mov	 DWORD PTR _nLen$[ebp], eax

; 747  : 	if ((nLen <= 0) || ((m_nCurrOffset+nLen) > m_nDataSize))

  0171f	83 7d f8 00	 cmp	 DWORD PTR _nLen$[ebp], 0
  01723	7e 11		 jle	 SHORT $L188187
  01725	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01728	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  0172b	03 55 f8	 add	 edx, DWORD PTR _nLen$[ebp]
  0172e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01731	3b 50 30	 cmp	 edx, DWORD PTR [eax+48]
  01734	76 04		 jbe	 SHORT $L188186
$L188187:

; 748  : 		return FALSE;

  01736	33 c0		 xor	 eax, eax
  01738	eb 14		 jmp	 SHORT $L188183
$L188186:

; 749  : 
; 750  : 	m_nCurrOffset += nLen;

  0173a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0173d	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  01740	03 55 f8	 add	 edx, DWORD PTR _nLen$[ebp]
  01743	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01746	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 751  : 	return TRUE;

  01749	b8 01 00 00 00	 mov	 eax, 1
$L188183:

; 752  : }

  0174e	83 c4 08	 add	 esp, 8
  01751	3b ec		 cmp	 ebp, esp
  01753	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01758	8b e5		 mov	 esp, ebp
  0175a	5d		 pop	 ebp
  0175b	c3		 ret	 0
?SkipNextBlock@CPictureEx@@IAEHXZ ENDP			; CPictureEx::SkipNextBlock
_TEXT	ENDS
PUBLIC	?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z ; CPictureEx::TGIFImageDescriptor::GetPackedValue
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv66 = -28						; size = 4
_nTmp$188218 = -24					; size = 4
_nLCTSize$188216 = -20					; size = 4
_pIDescr$188214 = -16					; size = 4
_nTmp$ = -12						; size = 4
_nBlock$ = -8						; size = 4
_this$ = -4						; size = 4
?GetNextBlockLen@CPictureEx@@IBEHXZ PROC NEAR		; CPictureEx::GetNextBlockLen
; _this$ = ecx

; 755  : {

  01760	55		 push	 ebp
  01761	8b ec		 mov	 ebp, esp
  01763	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01766	56		 push	 esi
  01767	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0176c	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0176f	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  01772	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  01775	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  01778	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0177b	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0177e	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  01781	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 756  : 	GIFBlockTypes nBlock = GetNextBlock();

  01784	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01787	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  0178c	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax

; 757  : 
; 758  : 	int nTmp;
; 759  : 
; 760  : 	switch(nBlock)

  0178f	8b 45 f8	 mov	 eax, DWORD PTR _nBlock$[ebp]
  01792	89 45 e4	 mov	 DWORD PTR tv66[ebp], eax
  01795	83 7d e4 06	 cmp	 DWORD PTR tv66[ebp], 6
  01799	0f 87 06 01 00
	00		 ja	 $L188194
  0179f	8b 4d e4	 mov	 ecx, DWORD PTR tv66[ebp]
  017a2	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L189754[ecx*4]
$L188197:

; 761  : 	{
; 762  : 	case BLOCK_UNKNOWN:
; 763  : 		return -1;

  017a9	83 c8 ff	 or	 eax, -1
  017ac	e9 f6 00 00 00	 jmp	 $L188190
$L188198:

; 764  : 		break;
; 765  : 
; 766  : 	case BLOCK_TRAILER:
; 767  : 		return 1;

  017b1	b8 01 00 00 00	 mov	 eax, 1
  017b6	e9 ec 00 00 00	 jmp	 $L188190
$L188199:

; 768  : 		break;
; 769  : 
; 770  : 	case BLOCK_APPEXT:
; 771  : 		nTmp = GetSubBlocksLen(m_nCurrOffset+sizeof(TGIFAppExtension));

  017bb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  017be	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  017c1	83 c0 0e	 add	 eax, 14			; 0000000eH
  017c4	50		 push	 eax
  017c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017c8	e8 00 00 00 00	 call	 ?GetSubBlocksLen@CPictureEx@@IBEII@Z ; CPictureEx::GetSubBlocksLen
  017cd	89 45 f4	 mov	 DWORD PTR _nTmp$[ebp], eax

; 772  : 		if (nTmp > 0)

  017d0	83 7d f4 00	 cmp	 DWORD PTR _nTmp$[ebp], 0
  017d4	7e 0b		 jle	 SHORT $L188201

; 773  : 			return sizeof(TGIFAppExtension)+nTmp;

  017d6	8b 45 f4	 mov	 eax, DWORD PTR _nTmp$[ebp]
  017d9	83 c0 0e	 add	 eax, 14			; 0000000eH
  017dc	e9 c6 00 00 00	 jmp	 $L188190
$L188201:

; 774  : 		break;

  017e1	e9 bf 00 00 00	 jmp	 $L188194
$L188203:

; 775  : 
; 776  : 	case BLOCK_COMMEXT:
; 777  : 		nTmp = GetSubBlocksLen(m_nCurrOffset+sizeof(TGIFCommentExt));

  017e6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017e9	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  017ec	83 c2 02	 add	 edx, 2
  017ef	52		 push	 edx
  017f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  017f3	e8 00 00 00 00	 call	 ?GetSubBlocksLen@CPictureEx@@IBEII@Z ; CPictureEx::GetSubBlocksLen
  017f8	89 45 f4	 mov	 DWORD PTR _nTmp$[ebp], eax

; 778  : 		if (nTmp > 0)

  017fb	83 7d f4 00	 cmp	 DWORD PTR _nTmp$[ebp], 0
  017ff	7e 0b		 jle	 SHORT $L188205

; 779  : 			return sizeof(TGIFCommentExt)+nTmp;

  01801	8b 45 f4	 mov	 eax, DWORD PTR _nTmp$[ebp]
  01804	83 c0 02	 add	 eax, 2
  01807	e9 9b 00 00 00	 jmp	 $L188190
$L188205:

; 780  : 		break;

  0180c	e9 94 00 00 00	 jmp	 $L188194
$L188207:

; 781  : 
; 782  : 	case BLOCK_CONTROLEXT:
; 783  : 		return sizeof(TGIFControlExt);

  01811	b8 08 00 00 00	 mov	 eax, 8
  01816	e9 8c 00 00 00	 jmp	 $L188190
$L188209:

; 784  : 		break;
; 785  : 
; 786  : 	case BLOCK_PLAINTEXT:
; 787  : 		nTmp = GetSubBlocksLen(m_nCurrOffset+sizeof(TGIFPlainTextExt));

  0181b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0181e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01821	83 c1 0f	 add	 ecx, 15			; 0000000fH
  01824	51		 push	 ecx
  01825	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01828	e8 00 00 00 00	 call	 ?GetSubBlocksLen@CPictureEx@@IBEII@Z ; CPictureEx::GetSubBlocksLen
  0182d	89 45 f4	 mov	 DWORD PTR _nTmp$[ebp], eax

; 788  : 		if (nTmp > 0)

  01830	83 7d f4 00	 cmp	 DWORD PTR _nTmp$[ebp], 0
  01834	7e 08		 jle	 SHORT $L188211

; 789  : 			return sizeof(TGIFPlainTextExt)+nTmp;

  01836	8b 45 f4	 mov	 eax, DWORD PTR _nTmp$[ebp]
  01839	83 c0 0f	 add	 eax, 15			; 0000000fH
  0183c	eb 69		 jmp	 SHORT $L188190
$L188211:

; 790  : 		break;

  0183e	eb 65		 jmp	 SHORT $L188194
$L188213:

; 791  : 
; 792  : 	case BLOCK_IMAGE:
; 793  : 		TGIFImageDescriptor *pIDescr = 
; 794  : 			reinterpret_cast<TGIFImageDescriptor *> (&m_pRawData[m_nCurrOffset]);

  01840	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01843	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  01846	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01849	03 41 34	 add	 eax, DWORD PTR [ecx+52]
  0184c	89 45 f0	 mov	 DWORD PTR _pIDescr$188214[ebp], eax

; 795  : 		int nLCTSize = (int)
; 796  : 			(pIDescr->GetPackedValue(ID_PACKED_LOCALCT)*3*
; 797  : 			(1 << (pIDescr->GetPackedValue(ID_PACKED_LOCALCTSIZE)+1)));

  0184f	6a 00		 push	 0
  01851	8b 4d f0	 mov	 ecx, DWORD PTR _pIDescr$188214[ebp]
  01854	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z ; CPictureEx::TGIFImageDescriptor::GetPackedValue
  01859	8b f0		 mov	 esi, eax
  0185b	6b f6 03	 imul	 esi, 3
  0185e	6a 03		 push	 3
  01860	8b 4d f0	 mov	 ecx, DWORD PTR _pIDescr$188214[ebp]
  01863	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z ; CPictureEx::TGIFImageDescriptor::GetPackedValue
  01868	83 c0 01	 add	 eax, 1
  0186b	ba 01 00 00 00	 mov	 edx, 1
  01870	8b c8		 mov	 ecx, eax
  01872	d3 e2		 shl	 edx, cl
  01874	0f af f2	 imul	 esi, edx
  01877	89 75 ec	 mov	 DWORD PTR _nLCTSize$188216[ebp], esi

; 798  : 
; 799  : 		int nTmp = GetSubBlocksLen(m_nCurrOffset+
; 800  : 			sizeof(TGIFImageDescriptor) + nLCTSize + 1);

  0187a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0187d	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01880	8b 55 ec	 mov	 edx, DWORD PTR _nLCTSize$188216[ebp]
  01883	8d 44 11 0b	 lea	 eax, DWORD PTR [ecx+edx+11]
  01887	50		 push	 eax
  01888	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0188b	e8 00 00 00 00	 call	 ?GetSubBlocksLen@CPictureEx@@IBEII@Z ; CPictureEx::GetSubBlocksLen
  01890	89 45 e8	 mov	 DWORD PTR _nTmp$188218[ebp], eax

; 801  : 		if (nTmp > 0)

  01893	83 7d e8 00	 cmp	 DWORD PTR _nTmp$188218[ebp], 0
  01897	7e 0c		 jle	 SHORT $L188194

; 802  : 			return sizeof(TGIFImageDescriptor) + nLCTSize + 1 + nTmp;

  01899	8b 4d e8	 mov	 ecx, DWORD PTR _nTmp$188218[ebp]
  0189c	8b 55 ec	 mov	 edx, DWORD PTR _nLCTSize$188216[ebp]
  0189f	8d 44 0a 0b	 lea	 eax, DWORD PTR [edx+ecx+11]
  018a3	eb 02		 jmp	 SHORT $L188190
$L188194:

; 803  : 		break;
; 804  : 	};
; 805  : 
; 806  : 	return 0;

  018a5	33 c0		 xor	 eax, eax
$L188190:

; 807  : }

  018a7	5e		 pop	 esi
  018a8	83 c4 1c	 add	 esp, 28			; 0000001cH
  018ab	3b ec		 cmp	 ebp, esp
  018ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  018b2	8b e5		 mov	 esp, ebp
  018b4	5d		 pop	 ebp
  018b5	c3		 ret	 0
$L189754:
  018b6	00 00 00 00	 DD	 $L188197
  018ba	00 00 00 00	 DD	 $L188199
  018be	00 00 00 00	 DD	 $L188203
  018c2	00 00 00 00	 DD	 $L188207
  018c6	00 00 00 00	 DD	 $L188209
  018ca	00 00 00 00	 DD	 $L188213
  018ce	00 00 00 00	 DD	 $L188198
?GetNextBlockLen@CPictureEx@@IBEHXZ ENDP		; CPictureEx::GetNextBlockLen
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z
_TEXT	SEGMENT
tv66 = -12						; size = 4
_nRet$ = -8						; size = 4
_this$ = -4						; size = 4
_Value$ = 8						; size = 4
?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z PROC NEAR ; CPictureEx::TGIFImageDescriptor::GetPackedValue, COMDAT
; _this$ = ecx

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 143  : 	int nRet = (int)m_cPacked;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  00025	89 4d f8	 mov	 DWORD PTR _nRet$[ebp], ecx

; 144  : 
; 145  : 	switch (Value)

  00028	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  0002b	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  0002e	83 7d f4 03	 cmp	 DWORD PTR tv66[ebp], 3
  00032	77 3a		 ja	 SHORT $L187780
  00034	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00037	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L189756[eax*4]
$L187783:

; 146  : 	{
; 147  : 	case ID_PACKED_LOCALCT:
; 148  : 		nRet >>= 7;

  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _nRet$[ebp]
  00041	c1 f9 07	 sar	 ecx, 7
  00044	89 4d f8	 mov	 DWORD PTR _nRet$[ebp], ecx

; 149  : 		break;

  00047	eb 25		 jmp	 SHORT $L187780
$L187784:

; 150  : 
; 151  : 	case ID_PACKED_INTERLACE:
; 152  : 		nRet = ((nRet & 0x40) >> 6);

  00049	8b 55 f8	 mov	 edx, DWORD PTR _nRet$[ebp]
  0004c	83 e2 40	 and	 edx, 64			; 00000040H
  0004f	c1 fa 06	 sar	 edx, 6
  00052	89 55 f8	 mov	 DWORD PTR _nRet$[ebp], edx

; 153  : 		break;

  00055	eb 17		 jmp	 SHORT $L187780
$L187785:

; 154  : 
; 155  : 	case ID_PACKED_SORT:
; 156  : 		nRet = (nRet & 0x20) >> 5;

  00057	8b 45 f8	 mov	 eax, DWORD PTR _nRet$[ebp]
  0005a	83 e0 20	 and	 eax, 32			; 00000020H
  0005d	c1 f8 05	 sar	 eax, 5
  00060	89 45 f8	 mov	 DWORD PTR _nRet$[ebp], eax

; 157  : 		break;

  00063	eb 09		 jmp	 SHORT $L187780
$L187786:

; 158  : 
; 159  : 	case ID_PACKED_LOCALCTSIZE:
; 160  : 		nRet &= 7;

  00065	8b 4d f8	 mov	 ecx, DWORD PTR _nRet$[ebp]
  00068	83 e1 07	 and	 ecx, 7
  0006b	89 4d f8	 mov	 DWORD PTR _nRet$[ebp], ecx
$L187780:

; 161  : 		break;
; 162  : 	};
; 163  : 
; 164  : 	return nRet;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _nRet$[ebp]

; 165  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
$L189756:
  00077	00 00 00 00	 DD	 $L187783
  0007b	00 00 00 00	 DD	 $L187784
  0007f	00 00 00 00	 DD	 $L187785
  00083	00 00 00 00	 DD	 $L187786
?GetPackedValue@TGIFImageDescriptor@CPictureEx@@QAEHW4IDPackedValues@2@@Z ENDP ; CPictureEx::TGIFImageDescriptor::GetPackedValue
_TEXT	ENDS
PUBLIC	?ThreadAnimation@CPictureEx@@IAEXXZ		; CPictureEx::ThreadAnimation
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_pPic$ = -4						; size = 4
_pParam$ = 8						; size = 4
?_ThreadAnimation@CPictureEx@@KGIPAX@Z PROC NEAR	; CPictureEx::_ThreadAnimation

; 810  : {

  018e0	55		 push	 ebp
  018e1	8b ec		 mov	 ebp, esp
  018e3	51		 push	 ecx
  018e4	56		 push	 esi
  018e5	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 811  : 	ASSERT(pParam);

  018ec	83 7d 08 00	 cmp	 DWORD PTR _pParam$[ebp], 0
  018f0	75 14		 jne	 SHORT $L189758
  018f2	68 2b 03 00 00	 push	 811			; 0000032bH
  018f7	68 00 00 00 00	 push	 OFFSET FLAT:_THIS_FILE
  018fc	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  01901	85 c0		 test	 eax, eax
  01903	74 01		 je	 SHORT $L189758
  01905	cc		 int	 3
$L189758:

; 812  : 	CPictureEx *pPic = reinterpret_cast<CPictureEx *> (pParam);

  01906	8b 4d 08	 mov	 ecx, DWORD PTR _pParam$[ebp]
  01909	89 4d fc	 mov	 DWORD PTR _pPic$[ebp], ecx

; 813  : 
; 814  : 	pPic->m_bIsPlaying = TRUE;

  0190c	8b 55 fc	 mov	 edx, DWORD PTR _pPic$[ebp]
  0190f	c7 42 40 01 00
	00 00		 mov	 DWORD PTR [edx+64], 1

; 815  : 	pPic->ThreadAnimation();

  01916	8b 4d fc	 mov	 ecx, DWORD PTR _pPic$[ebp]
  01919	e8 00 00 00 00	 call	 ?ThreadAnimation@CPictureEx@@IAEXXZ ; CPictureEx::ThreadAnimation

; 816  : 	pPic->m_bIsPlaying = FALSE;

  0191e	8b 45 fc	 mov	 eax, DWORD PTR _pPic$[ebp]
  01921	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 817  : 
; 818  : 	// this thread has finished its work so we close the handle
; 819  : 	CloseHandle(pPic->m_hThread); 

  01928	8b f4		 mov	 esi, esp
  0192a	8b 4d fc	 mov	 ecx, DWORD PTR _pPic$[ebp]
  0192d	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  01930	52		 push	 edx
  01931	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  01937	3b f4		 cmp	 esi, esp
  01939	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 820  : 	// and init the handle to zero (so that Stop() doesn't Wait on it)
; 821  : 	pPic->m_hThread = 0;

  0193e	8b 45 fc	 mov	 eax, DWORD PTR _pPic$[ebp]
  01941	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 822  : 	return 0;

  01948	33 c0		 xor	 eax, eax

; 823  : }

  0194a	5e		 pop	 esi
  0194b	83 c4 04	 add	 esp, 4
  0194e	3b ec		 cmp	 ebp, esp
  01950	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01955	8b e5		 mov	 esp, ebp
  01957	5d		 pop	 ebp
  01958	c2 04 00	 ret	 4
?_ThreadAnimation@CPictureEx@@KGIPAX@Z ENDP		; CPictureEx::_ThreadAnimation
_TEXT	ENDS
PUBLIC	?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
PUBLIC	??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
EXTRN	__imp__BitBlt@36:NEAR
EXTRN	__imp__CreateCompatibleBitmap@12:NEAR
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	__imp__CreateSolidBrush@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	__imp__FillRect@12:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv331 = -124						; size = 4
tv320 = -120						; size = 4
tv309 = -116						; size = 4
_rect$188264 = -108					; size = 16
_hBrush$188262 = -88					; size = 4
_rect$188257 = -80					; size = 16
_hBrush$188255 = -60					; size = 4
_hmHeight$188247 = -52					; size = 4
_hmWidth$188246 = -40					; size = 4
_rect$188234 = -28					; size = 16
_hBrush$188232 = -8					; size = 4
_this$ = -4						; size = 4
?ThreadAnimation@CPictureEx@@IAEXXZ PROC NEAR		; CPictureEx::ThreadAnimation
; _this$ = ecx

; 826  : {

  01960	55		 push	 ebp
  01961	8b ec		 mov	 ebp, esp
  01963	83 ec 7c	 sub	 esp, 124		; 0000007cH
  01966	56		 push	 esi
  01967	57		 push	 edi
  01968	51		 push	 ecx
  01969	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  0196c	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  01971	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  01976	f3 ab		 rep stosd
  01978	59		 pop	 ecx
  01979	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 827  : 	// first, restore background (for stop/draw support)
; 828  : 	// disposal method #2
; 829  : 	if (m_arrFrames[m_nCurrFrame].m_nDisposal == 2)

  0197c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0197f	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01982	51		 push	 ecx
  01983	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01986	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0198c	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01991	83 78 18 02	 cmp	 DWORD PTR [eax+24], 2
  01995	0f 85 f9 00 00
	00		 jne	 $L188231

; 830  : 	{
; 831  : 		HBRUSH hBrush = CreateSolidBrush(m_clrBackground);

  0199b	8b f4		 mov	 esi, esp
  0199d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  019a0	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  019a3	50		 push	 eax
  019a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  019aa	3b f4		 cmp	 esi, esp
  019ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  019b1	89 45 f8	 mov	 DWORD PTR _hBrush$188232[ebp], eax

; 832  : 		if (hBrush)

  019b4	83 7d f8 00	 cmp	 DWORD PTR _hBrush$188232[ebp], 0
  019b8	0f 84 d1 00 00
	00		 je	 $L188233

; 833  : 		{
; 834  : 			RECT rect = {
; 835  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cx,

  019be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019c1	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  019c4	52		 push	 edx
  019c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019c8	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  019ce	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  019d3	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  019d6	89 45 e4	 mov	 DWORD PTR _rect$188234[ebp], eax

; 836  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cy,

  019d9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019dc	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  019df	52		 push	 edx
  019e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019e3	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  019e9	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  019ee	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  019f1	89 45 e8	 mov	 DWORD PTR _rect$188234[ebp+4], eax

; 837  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cx + m_arrFrames[m_nCurrFrame].m_frameSize.cx,

  019f4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019f7	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  019fa	52		 push	 edx
  019fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  019fe	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01a04	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01a09	8b f0		 mov	 esi, eax
  01a0b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a0e	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01a11	51		 push	 ecx
  01a12	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a15	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01a1b	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01a20	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01a23	03 50 04	 add	 edx, DWORD PTR [eax+4]
  01a26	89 55 ec	 mov	 DWORD PTR _rect$188234[ebp+8], edx

; 838  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cy + m_arrFrames[m_nCurrFrame].m_frameSize.cy };

  01a29	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01a2c	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01a2f	51		 push	 ecx
  01a30	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a33	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01a39	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01a3e	8b f0		 mov	 esi, eax
  01a40	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01a43	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01a46	50		 push	 eax
  01a47	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a4a	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01a50	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01a55	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01a58	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  01a5b	89 4d f0	 mov	 DWORD PTR _rect$188234[ebp+12], ecx

; 839  : 			FillRect(m_hMemDC,&rect,hBrush);

  01a5e	8b f4		 mov	 esi, esp
  01a60	8b 55 f8	 mov	 edx, DWORD PTR _hBrush$188232[ebp]
  01a63	52		 push	 edx
  01a64	8d 45 e4	 lea	 eax, DWORD PTR _rect$188234[ebp]
  01a67	50		 push	 eax
  01a68	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a6b	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  01a6e	52		 push	 edx
  01a6f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12
  01a75	3b f4		 cmp	 esi, esp
  01a77	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 840  : 			DeleteObject(hBrush);

  01a7c	8b f4		 mov	 esi, esp
  01a7e	8b 45 f8	 mov	 eax, DWORD PTR _hBrush$188232[ebp]
  01a81	50		 push	 eax
  01a82	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  01a88	3b f4		 cmp	 esi, esp
  01a8a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188233:

; 841  : 		};
; 842  : 	} 
; 843  : 	else

  01a8f	e9 13 01 00 00	 jmp	 $L188239
$L188231:

; 844  : 		// disposal method #3
; 845  : 		if (m_hDispMemDC && (m_arrFrames[m_nCurrFrame].m_nDisposal == 3) )

  01a94	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01a97	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  01a9b	0f 84 06 01 00
	00		 je	 $L188239
  01aa1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01aa4	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01aa7	50		 push	 eax
  01aa8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01aab	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01ab1	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01ab6	83 78 18 03	 cmp	 DWORD PTR [eax+24], 3
  01aba	0f 85 e7 00 00
	00		 jne	 $L188239

; 846  : 		{
; 847  : 			// put it back
; 848  : 			BitBlt(m_hMemDC,
; 849  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
; 850  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
; 851  : 				m_arrFrames[m_nCurrFrame].m_frameSize.cx,
; 852  : 				m_arrFrames[m_nCurrFrame].m_frameSize.cy,
; 853  : 				m_hDispMemDC,0,0, SRCCOPY);

  01ac0	8b f4		 mov	 esi, esp
  01ac2	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01ac7	6a 00		 push	 0
  01ac9	6a 00		 push	 0
  01acb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ace	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  01ad1	52		 push	 edx
  01ad2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ad5	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01ad8	51		 push	 ecx
  01ad9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01adc	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01ae2	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01ae7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  01aea	52		 push	 edx
  01aeb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01aee	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01af1	51		 push	 ecx
  01af2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01af5	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01afb	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01b00	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01b03	52		 push	 edx
  01b04	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b07	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01b0a	51		 push	 ecx
  01b0b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b0e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01b14	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01b19	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01b1c	52		 push	 edx
  01b1d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b20	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01b23	51		 push	 ecx
  01b24	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b27	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01b2d	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01b32	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01b35	52		 push	 edx
  01b36	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b39	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01b3c	51		 push	 ecx
  01b3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  01b43	3b f4		 cmp	 esi, esp
  01b45	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 854  : 			// init variables
; 855  : 			SelectObject(m_hDispMemDC,m_hDispOldBM);

  01b4a	8b f4		 mov	 esi, esp
  01b4c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01b4f	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  01b52	50		 push	 eax
  01b53	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01b56	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  01b59	52		 push	 edx
  01b5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01b60	3b f4		 cmp	 esi, esp
  01b62	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 856  : 			DeleteDC(m_hDispMemDC); m_hDispMemDC = NULL;

  01b67	8b f4		 mov	 esi, esp
  01b69	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b6c	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01b6f	51		 push	 ecx
  01b70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  01b76	3b f4		 cmp	 esi, esp
  01b78	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01b7d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01b80	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0

; 857  : 			DeleteObject(m_hDispMemBM); m_hDispMemBM = NULL;

  01b87	8b f4		 mov	 esi, esp
  01b89	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01b8c	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  01b8f	51		 push	 ecx
  01b90	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  01b96	3b f4		 cmp	 esi, esp
  01b98	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01b9d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01ba0	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0
$L188239:

; 858  : 		};
; 859  : 
; 860  : 	while (!m_bExitThread)

  01ba7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01baa	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  01bae	0f 85 e0 05 00
	00		 jne	 $L188230

; 861  : 	{
; 862  : 		if (m_arrFrames[m_nCurrFrame].m_pPicture)

  01bb4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bb7	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01bba	52		 push	 edx
  01bbb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bbe	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01bc4	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01bc9	83 38 00	 cmp	 DWORD PTR [eax], 0
  01bcc	0f 84 1e 05 00
	00		 je	 $L188241

; 863  : 		{
; 864  : 		///////////////////////////////////////////////////////
; 865  : 		// Before rendering a frame we should take care of what's 
; 866  : 		// behind that frame. TFrame::m_nDisposal will be our guide:
; 867  : 		//   0 - no disposal specified (do nothing)
; 868  : 		//   1 - do not dispose (again, do nothing)
; 869  : 		//   2 - restore to background color (m_clrBackground)
; 870  : 		//   3 - restore to previous
; 871  : 
; 872  : 			//////// disposal method #3
; 873  : 			if (m_arrFrames[m_nCurrFrame].m_nDisposal == 3)

  01bd2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01bd5	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01bd8	51		 push	 ecx
  01bd9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01bdc	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01be2	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01be7	83 78 18 03	 cmp	 DWORD PTR [eax+24], 3
  01beb	0f 85 31 01 00
	00		 jne	 $L188242

; 874  : 			{
; 875  : 				// prepare a memory DC and store the background in it
; 876  : 				m_hDispMemDC = CreateCompatibleDC(m_hMemDC);

  01bf1	8b f4		 mov	 esi, esp
  01bf3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01bf6	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  01bf9	50		 push	 eax
  01bfa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01c00	3b f4		 cmp	 esi, esp
  01c02	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01c07	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c0a	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 877  : 				m_hDispMemBM = CreateCompatibleBitmap(m_hMemDC,
; 878  : 							m_arrFrames[m_nCurrFrame].m_frameSize.cx,
; 879  : 							m_arrFrames[m_nCurrFrame].m_frameSize.cy);

  01c0d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01c10	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01c13	50		 push	 eax
  01c14	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c17	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01c1d	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01c22	8b f4		 mov	 esi, esp
  01c24	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01c27	51		 push	 ecx
  01c28	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01c2b	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01c2e	50		 push	 eax
  01c2f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c32	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01c38	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01c3d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01c40	51		 push	 ecx
  01c41	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01c44	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  01c47	50		 push	 eax
  01c48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  01c4e	3b f4		 cmp	 esi, esp
  01c50	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01c55	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c58	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 880  : 				
; 881  : 				if (m_hDispMemDC && m_hDispMemBM)

  01c5b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01c5e	83 7a 50 00	 cmp	 DWORD PTR [edx+80], 0
  01c62	0f 84 ba 00 00
	00		 je	 $L188242
  01c68	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01c6b	83 78 54 00	 cmp	 DWORD PTR [eax+84], 0
  01c6f	0f 84 ad 00 00
	00		 je	 $L188242

; 882  : 				{
; 883  : 					m_hDispOldBM = reinterpret_cast<HBITMAP> (SelectObject(m_hDispMemDC,m_hDispMemBM));

  01c75	8b f4		 mov	 esi, esp
  01c77	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01c7a	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  01c7d	52		 push	 edx
  01c7e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01c81	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01c84	51		 push	 ecx
  01c85	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  01c8b	3b f4		 cmp	 esi, esp
  01c8d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01c92	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01c95	89 42 58	 mov	 DWORD PTR [edx+88], eax

; 884  : 					BitBlt(m_hDispMemDC,0,0,
; 885  : 						m_arrFrames[m_nCurrFrame].m_frameSize.cx,
; 886  : 						m_arrFrames[m_nCurrFrame].m_frameSize.cy,
; 887  : 						m_hMemDC,
; 888  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
; 889  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
; 890  : 						SRCCOPY);

  01c98	8b f4		 mov	 esi, esp
  01c9a	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  01c9f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ca2	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01ca5	51		 push	 ecx
  01ca6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ca9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01caf	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01cb4	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01cb7	52		 push	 edx
  01cb8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01cbb	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01cbe	51		 push	 ecx
  01cbf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cc2	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01cc8	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01ccd	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01cd0	52		 push	 edx
  01cd1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01cd4	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01cd7	51		 push	 ecx
  01cd8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01cdb	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01cde	50		 push	 eax
  01cdf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ce2	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01ce8	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01ced	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01cf0	51		 push	 ecx
  01cf1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01cf4	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01cf7	50		 push	 eax
  01cf8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01cfb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01d01	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01d06	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01d09	51		 push	 ecx
  01d0a	6a 00		 push	 0
  01d0c	6a 00		 push	 0
  01d0e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01d11	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  01d14	50		 push	 eax
  01d15	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  01d1b	3b f4		 cmp	 esi, esp
  01d1d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188242:

; 891  : 				};
; 892  : 			};
; 893  : 			///////////////////////
; 894  : 
; 895  : 			long hmWidth;
; 896  : 			long hmHeight;
; 897  : 			m_arrFrames[m_nCurrFrame].m_pPicture->get_Width(&hmWidth);

  01d22	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d25	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01d28	52		 push	 edx
  01d29	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d2c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01d32	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01d37	8b 00		 mov	 eax, DWORD PTR [eax]
  01d39	89 45 8c	 mov	 DWORD PTR tv309[ebp], eax
  01d3c	8b f4		 mov	 esi, esp
  01d3e	8d 4d d8	 lea	 ecx, DWORD PTR _hmWidth$188246[ebp]
  01d41	51		 push	 ecx
  01d42	8b 55 8c	 mov	 edx, DWORD PTR tv309[ebp]
  01d45	52		 push	 edx
  01d46	8b 45 8c	 mov	 eax, DWORD PTR tv309[ebp]
  01d49	8b 08		 mov	 ecx, DWORD PTR [eax]
  01d4b	ff 51 18	 call	 DWORD PTR [ecx+24]
  01d4e	3b f4		 cmp	 esi, esp
  01d50	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 898  : 			m_arrFrames[m_nCurrFrame].m_pPicture->get_Height(&hmHeight);

  01d55	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01d58	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01d5b	50		 push	 eax
  01d5c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d5f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01d65	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01d6a	8b 08		 mov	 ecx, DWORD PTR [eax]
  01d6c	89 4d 88	 mov	 DWORD PTR tv320[ebp], ecx
  01d6f	8b f4		 mov	 esi, esp
  01d71	8d 55 cc	 lea	 edx, DWORD PTR _hmHeight$188247[ebp]
  01d74	52		 push	 edx
  01d75	8b 45 88	 mov	 eax, DWORD PTR tv320[ebp]
  01d78	50		 push	 eax
  01d79	8b 4d 88	 mov	 ecx, DWORD PTR tv320[ebp]
  01d7c	8b 11		 mov	 edx, DWORD PTR [ecx]
  01d7e	ff 52 1c	 call	 DWORD PTR [edx+28]
  01d81	3b f4		 cmp	 esi, esp
  01d83	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 899  : 
; 900  : 			if (m_arrFrames[m_nCurrFrame].m_pPicture->Render(m_hMemDC, 
; 901  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cx, 
; 902  : 				m_arrFrames[m_nCurrFrame].m_frameOffset.cy, 
; 903  : 				m_arrFrames[m_nCurrFrame].m_frameSize.cx, 
; 904  : 				m_arrFrames[m_nCurrFrame].m_frameSize.cy, 
; 905  : 				0, hmHeight, hmWidth, -hmHeight, NULL) == S_OK)

  01d88	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01d8b	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01d8e	51		 push	 ecx
  01d8f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01d92	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01d98	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01d9d	8b 10		 mov	 edx, DWORD PTR [eax]
  01d9f	89 55 84	 mov	 DWORD PTR tv331[ebp], edx
  01da2	8b f4		 mov	 esi, esp
  01da4	6a 00		 push	 0
  01da6	8b 45 cc	 mov	 eax, DWORD PTR _hmHeight$188247[ebp]
  01da9	f7 d8		 neg	 eax
  01dab	50		 push	 eax
  01dac	8b 4d d8	 mov	 ecx, DWORD PTR _hmWidth$188246[ebp]
  01daf	51		 push	 ecx
  01db0	8b 55 cc	 mov	 edx, DWORD PTR _hmHeight$188247[ebp]
  01db3	52		 push	 edx
  01db4	6a 00		 push	 0
  01db6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01db9	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01dbc	51		 push	 ecx
  01dbd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01dc0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01dc6	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01dcb	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  01dce	52		 push	 edx
  01dcf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01dd2	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01dd5	51		 push	 ecx
  01dd6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01dd9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01ddf	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01de4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01de7	52		 push	 edx
  01de8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01deb	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01dee	51		 push	 ecx
  01def	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01df2	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01df8	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01dfd	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01e00	52		 push	 edx
  01e01	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e04	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01e07	51		 push	 ecx
  01e08	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e0b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01e11	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01e16	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01e19	52		 push	 edx
  01e1a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e1d	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  01e20	51		 push	 ecx
  01e21	8b 55 84	 mov	 edx, DWORD PTR tv331[ebp]
  01e24	52		 push	 edx
  01e25	8b 45 84	 mov	 eax, DWORD PTR tv331[ebp]
  01e28	8b 08		 mov	 ecx, DWORD PTR [eax]
  01e2a	ff 51 20	 call	 DWORD PTR [ecx+32]
  01e2d	3b f4		 cmp	 esi, esp
  01e2f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01e34	85 c0		 test	 eax, eax
  01e36	75 0a		 jne	 SHORT $L188249

; 906  : 			{
; 907  : ////				Invalidate(FALSE);
; 908  : 				OnPaint();

  01e38	6a 00		 push	 0
  01e3a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e3d	e8 00 00 00 00	 call	 ?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z ; CPictureEx::OnPaint
$L188249:

; 909  : 			};
; 910  : 			
; 911  : 			if (m_bExitThread) break;

  01e42	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01e45	83 7a 44 00	 cmp	 DWORD PTR [edx+68], 0
  01e49	74 05		 je	 SHORT $L188250
  01e4b	e9 44 03 00 00	 jmp	 $L188230
$L188250:

; 912  : 
; 913  : 			// if the delay time is too short (like in old GIFs), wait for 100ms
; 914  : 			if (m_arrFrames[m_nCurrFrame].m_nDelay < 5) 

  01e50	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01e53	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01e56	51		 push	 ecx
  01e57	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e5a	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01e60	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01e65	83 78 14 05	 cmp	 DWORD PTR [eax+20], 5
  01e69	73 1a		 jae	 SHORT $L188251

; 915  : 				WaitForSingleObject(m_hExitEvent, 100);

  01e6b	8b f4		 mov	 esi, esp
  01e6d	6a 64		 push	 100			; 00000064H
  01e6f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01e72	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  01e75	50		 push	 eax
  01e76	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  01e7c	3b f4		 cmp	 esi, esp
  01e7e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 916  : 			else

  01e83	eb 32		 jmp	 SHORT $L188252
$L188251:

; 917  : 				WaitForSingleObject(m_hExitEvent, 10*m_arrFrames[m_nCurrFrame].m_nDelay);

  01e85	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e88	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01e8b	52		 push	 edx
  01e8c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01e8f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01e95	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01e9a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  01e9d	6b c0 0a	 imul	 eax, 10			; 0000000aH
  01ea0	8b f4		 mov	 esi, esp
  01ea2	50		 push	 eax
  01ea3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ea6	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  01ea9	52		 push	 edx
  01eaa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  01eb0	3b f4		 cmp	 esi, esp
  01eb2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188252:

; 918  : 
; 919  : 			if (m_bExitThread) break;

  01eb7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01eba	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  01ebe	74 05		 je	 SHORT $L188253
  01ec0	e9 cf 02 00 00	 jmp	 $L188230
$L188253:

; 920  : 
; 921  : 			// disposal method #2
; 922  : 			if (m_arrFrames[m_nCurrFrame].m_nDisposal == 2)

  01ec5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ec8	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01ecb	52		 push	 edx
  01ecc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ecf	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01ed5	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01eda	83 78 18 02	 cmp	 DWORD PTR [eax+24], 2
  01ede	0f 85 f9 00 00
	00		 jne	 $L188254

; 923  : 			{
; 924  : 				HBRUSH hBrush = CreateSolidBrush(m_clrBackground);

  01ee4	8b f4		 mov	 esi, esp
  01ee6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01ee9	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  01eec	51		 push	 ecx
  01eed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  01ef3	3b f4		 cmp	 esi, esp
  01ef5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01efa	89 45 c4	 mov	 DWORD PTR _hBrush$188255[ebp], eax

; 925  : 				if (hBrush)

  01efd	83 7d c4 00	 cmp	 DWORD PTR _hBrush$188255[ebp], 0
  01f01	0f 84 d1 00 00
	00		 je	 $L188256

; 926  : 				{
; 927  : 					RECT rect = {
; 928  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cx,

  01f07	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01f0a	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01f0d	50		 push	 eax
  01f0e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f11	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f17	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01f1c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01f1f	89 4d b0	 mov	 DWORD PTR _rect$188257[ebp], ecx

; 929  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cy,

  01f22	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01f25	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01f28	50		 push	 eax
  01f29	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f2c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f32	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01f37	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01f3a	89 4d b4	 mov	 DWORD PTR _rect$188257[ebp+4], ecx

; 930  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cx + m_arrFrames[m_nCurrFrame].m_frameSize.cx,

  01f3d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01f40	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01f43	50		 push	 eax
  01f44	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f47	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f4d	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01f52	8b f0		 mov	 esi, eax
  01f54	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f57	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01f5a	52		 push	 edx
  01f5b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f5e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f64	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01f69	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  01f6c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  01f6f	89 4d b8	 mov	 DWORD PTR _rect$188257[ebp+8], ecx

; 931  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cy + m_arrFrames[m_nCurrFrame].m_frameSize.cy };

  01f72	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01f75	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01f78	50		 push	 eax
  01f79	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f7c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f82	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01f87	8b f0		 mov	 esi, eax
  01f89	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f8c	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01f8f	52		 push	 edx
  01f90	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01f93	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f99	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01f9e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01fa1	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  01fa4	89 4d bc	 mov	 DWORD PTR _rect$188257[ebp+12], ecx

; 932  : 					FillRect(m_hMemDC,&rect,hBrush);

  01fa7	8b f4		 mov	 esi, esp
  01fa9	8b 55 c4	 mov	 edx, DWORD PTR _hBrush$188255[ebp]
  01fac	52		 push	 edx
  01fad	8d 45 b0	 lea	 eax, DWORD PTR _rect$188257[ebp]
  01fb0	50		 push	 eax
  01fb1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01fb4	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  01fb7	52		 push	 edx
  01fb8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12
  01fbe	3b f4		 cmp	 esi, esp
  01fc0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 933  : 					DeleteObject(hBrush);

  01fc5	8b f4		 mov	 esi, esp
  01fc7	8b 45 c4	 mov	 eax, DWORD PTR _hBrush$188255[ebp]
  01fca	50		 push	 eax
  01fcb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  01fd1	3b f4		 cmp	 esi, esp
  01fd3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188256:

; 934  : 				};
; 935  : 			} 
; 936  : 			else

  01fd8	e9 13 01 00 00	 jmp	 $L188241
$L188254:

; 937  : 				if (m_hDispMemDC && (m_arrFrames[m_nCurrFrame].m_nDisposal == 3) )

  01fdd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01fe0	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  01fe4	0f 84 06 01 00
	00		 je	 $L188241
  01fea	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  01fed	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01ff0	50		 push	 eax
  01ff1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  01ff4	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01ffa	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  01fff	83 78 18 03	 cmp	 DWORD PTR [eax+24], 3
  02003	0f 85 e7 00 00
	00		 jne	 $L188241

; 938  : 				{
; 939  : 					// put it back
; 940  : 					BitBlt(m_hMemDC,
; 941  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
; 942  : 						m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
; 943  : 						m_arrFrames[m_nCurrFrame].m_frameSize.cx,
; 944  : 						m_arrFrames[m_nCurrFrame].m_frameSize.cy,
; 945  : 						m_hDispMemDC,0,0, SRCCOPY);

  02009	8b f4		 mov	 esi, esp
  0200b	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  02010	6a 00		 push	 0
  02012	6a 00		 push	 0
  02014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02017	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0201a	52		 push	 edx
  0201b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0201e	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  02021	51		 push	 ecx
  02022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02025	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0202b	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  02030	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  02033	52		 push	 edx
  02034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02037	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0203a	51		 push	 ecx
  0203b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0203e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02044	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  02049	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0204c	52		 push	 edx
  0204d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02050	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  02053	51		 push	 ecx
  02054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02057	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0205d	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  02062	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  02065	52		 push	 edx
  02066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02069	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0206c	51		 push	 ecx
  0206d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02070	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02076	e8 00 00 00 00	 call	 ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
  0207b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0207e	52		 push	 edx
  0207f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02082	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  02085	51		 push	 ecx
  02086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  0208c	3b f4		 cmp	 esi, esp
  0208e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 946  : 					// init variables
; 947  : 					SelectObject(m_hDispMemDC,m_hDispOldBM);

  02093	8b f4		 mov	 esi, esp
  02095	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02098	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  0209b	50		 push	 eax
  0209c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0209f	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  020a2	52		 push	 edx
  020a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  020a9	3b f4		 cmp	 esi, esp
  020ab	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 948  : 					DeleteDC(m_hDispMemDC); m_hDispMemDC = NULL;

  020b0	8b f4		 mov	 esi, esp
  020b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  020b5	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  020b8	51		 push	 ecx
  020b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  020bf	3b f4		 cmp	 esi, esp
  020c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  020c6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  020c9	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], 0

; 949  : 					DeleteObject(m_hDispMemBM); m_hDispMemBM = NULL;

  020d0	8b f4		 mov	 esi, esp
  020d2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  020d5	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  020d8	51		 push	 ecx
  020d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  020df	3b f4		 cmp	 esi, esp
  020e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  020e6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  020e9	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], 0
$L188241:

; 950  : 				};
; 951  : 		};
; 952  : 		m_nCurrFrame++;

  020f0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  020f3	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  020f6	83 c1 01	 add	 ecx, 1
  020f9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  020fc	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 953  : 		if (m_nCurrFrame == m_arrFrames.size())

  020ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02102	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02108	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  0210d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02110	39 41 2c	 cmp	 DWORD PTR [ecx+44], eax
  02113	75 7a		 jne	 SHORT $L188261

; 954  : 		{
; 955  : 			m_nCurrFrame
; 956  : 				= 0; 

  02115	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02118	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 957  : 		// init the screen for the first frame,
; 958  : 			HBRUSH hBrush = CreateSolidBrush(m_clrBackground);

  0211f	8b f4		 mov	 esi, esp
  02121	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02124	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  02127	51		 push	 ecx
  02128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  0212e	3b f4		 cmp	 esi, esp
  02130	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02135	89 45 a8	 mov	 DWORD PTR _hBrush$188262[ebp], eax

; 959  : 			if (hBrush)

  02138	83 7d a8 00	 cmp	 DWORD PTR _hBrush$188262[ebp], 0
  0213c	74 51		 je	 SHORT $L188261

; 960  : 			{
; 961  : 				RECT rect = {0,0,m_PictureSize.cx,m_PictureSize.cy};

  0213e	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _rect$188264[ebp], 0
  02145	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _rect$188264[ebp+4], 0
  0214c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0214f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  02152	89 45 9c	 mov	 DWORD PTR _rect$188264[ebp+8], eax
  02155	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02158	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0215b	89 55 a0	 mov	 DWORD PTR _rect$188264[ebp+12], edx

; 962  : 				FillRect(m_hMemDC,&rect,hBrush);

  0215e	8b f4		 mov	 esi, esp
  02160	8b 45 a8	 mov	 eax, DWORD PTR _hBrush$188262[ebp]
  02163	50		 push	 eax
  02164	8d 4d 94	 lea	 ecx, DWORD PTR _rect$188264[ebp]
  02167	51		 push	 ecx
  02168	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0216b	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  0216e	50		 push	 eax
  0216f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12
  02175	3b f4		 cmp	 esi, esp
  02177	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 963  : 				DeleteObject(hBrush);

  0217c	8b f4		 mov	 esi, esp
  0217e	8b 4d a8	 mov	 ecx, DWORD PTR _hBrush$188262[ebp]
  02181	51		 push	 ecx
  02182	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  02188	3b f4		 cmp	 esi, esp
  0218a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188261:

; 964  : 			};
; 965  : 		};
; 966  : 	};

  0218f	e9 13 fa ff ff	 jmp	 $L188239
$L188230:

; 967  : }

  02194	52		 push	 edx
  02195	8b cd		 mov	 ecx, ebp
  02197	50		 push	 eax
  02198	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189766
  0219e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  021a3	58		 pop	 eax
  021a4	5a		 pop	 edx
  021a5	5f		 pop	 edi
  021a6	5e		 pop	 esi
  021a7	83 c4 7c	 add	 esp, 124		; 0000007cH
  021aa	3b ec		 cmp	 ebp, esp
  021ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  021b1	8b e5		 mov	 esp, ebp
  021b3	5d		 pop	 ebp
  021b4	c3		 ret	 0
$L189766:
  021b5	05 00 00 00	 DD	 5
  021b9	00 00 00 00	 DD	 $L189765
$L189765:
  021bd	e4 ff ff ff	 DD	 -28			; ffffffe4H
  021c1	10 00 00 00	 DD	 16			; 00000010H
  021c5	00 00 00 00	 DD	 $L189760
  021c9	d8 ff ff ff	 DD	 -40			; ffffffd8H
  021cd	04 00 00 00	 DD	 4
  021d1	00 00 00 00	 DD	 $L189761
  021d5	cc ff ff ff	 DD	 -52			; ffffffccH
  021d9	04 00 00 00	 DD	 4
  021dd	00 00 00 00	 DD	 $L189762
  021e1	b0 ff ff ff	 DD	 -80			; ffffffb0H
  021e5	10 00 00 00	 DD	 16			; 00000010H
  021e9	00 00 00 00	 DD	 $L189763
  021ed	94 ff ff ff	 DD	 -108			; ffffff94H
  021f1	10 00 00 00	 DD	 16			; 00000010H
  021f5	00 00 00 00	 DD	 $L189764
$L189764:
  021f9	72		 DB	 114			; 00000072H
  021fa	65		 DB	 101			; 00000065H
  021fb	63		 DB	 99			; 00000063H
  021fc	74		 DB	 116			; 00000074H
  021fd	00		 DB	 0
$L189763:
  021fe	72		 DB	 114			; 00000072H
  021ff	65		 DB	 101			; 00000065H
  02200	63		 DB	 99			; 00000063H
  02201	74		 DB	 116			; 00000074H
  02202	00		 DB	 0
$L189762:
  02203	68		 DB	 104			; 00000068H
  02204	6d		 DB	 109			; 0000006dH
  02205	48		 DB	 72			; 00000048H
  02206	65		 DB	 101			; 00000065H
  02207	69		 DB	 105			; 00000069H
  02208	67		 DB	 103			; 00000067H
  02209	68		 DB	 104			; 00000068H
  0220a	74		 DB	 116			; 00000074H
  0220b	00		 DB	 0
$L189761:
  0220c	68		 DB	 104			; 00000068H
  0220d	6d		 DB	 109			; 0000006dH
  0220e	57		 DB	 87			; 00000057H
  0220f	69		 DB	 105			; 00000069H
  02210	64		 DB	 100			; 00000064H
  02211	74		 DB	 116			; 00000074H
  02212	68		 DB	 104			; 00000068H
  02213	00		 DB	 0
$L189760:
  02214	72		 DB	 114			; 00000072H
  02215	65		 DB	 101			; 00000065H
  02216	63		 DB	 99			; 00000063H
  02217	74		 DB	 116			; 00000074H
  02218	00		 DB	 0
?ThreadAnimation@CPictureEx@@IAEXXZ ENDP		; CPictureEx::ThreadAnimation
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ		; CArray<CRect,CRect>::RemoveAll
EXTRN	__imp__SetEvent@4:NEAR
EXTRN	__imp__ResetEvent@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Stop@CPictureEx@@QAEXXZ PROC NEAR			; CPictureEx::Stop
; _this$ = ecx

; 970  : {

  02220	55		 push	 ebp
  02221	8b ec		 mov	 ebp, esp
  02223	51		 push	 ecx
  02224	56		 push	 esi
  02225	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0222c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 971  : 	m_bIsPlaying = FALSE;

  0222f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02232	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 972  : 	m_bExitThread = TRUE;

  02239	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0223c	c7 41 44 01 00
	00 00		 mov	 DWORD PTR [ecx+68], 1

; 973  : 	this->m_aryPoint->RemoveAll();

  02243	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02246	8b 8a 90 00 00
	00		 mov	 ecx, DWORD PTR [edx+144]
  0224c	e8 00 00 00 00	 call	 ?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ ; CArray<CRect,CRect>::RemoveAll

; 974  : 	SetEvent(m_hExitEvent);

  02251	8b f4		 mov	 esi, esp
  02253	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02256	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  02259	51		 push	 ecx
  0225a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  02260	3b f4		 cmp	 esi, esp
  02262	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 975  : 	if (m_hThread)

  02267	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0226a	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  0226e	74 44		 je	 SHORT $L188268

; 976  : 	{
; 977  : 		// we'll wait for 5 seconds then continue execution
; 978  : 		WaitForSingleObject(m_hThread,5000);	

  02270	8b f4		 mov	 esi, esp
  02272	68 88 13 00 00	 push	 5000			; 00001388H
  02277	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0227a	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0227d	51		 push	 ecx
  0227e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  02284	3b f4		 cmp	 esi, esp
  02286	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 979  : 		if( m_hThread != NULL )

  0228b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0228e	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  02292	74 16		 je	 SHORT $L188269

; 980  : 		{
; 981  : 			CloseHandle(m_hThread);

  02294	8b f4		 mov	 esi, esp
  02296	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02299	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0229c	51		 push	 ecx
  0229d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  022a3	3b f4		 cmp	 esi, esp
  022a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188269:

; 982  : 		}
; 983  : 
; 984  : 		m_hThread = NULL;

  022aa	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  022ad	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0
$L188268:

; 985  : 	}
; 986  : 
; 987  : 	// make it possible to Draw() again
; 988  : 	ResetEvent(m_hExitEvent);

  022b4	8b f4		 mov	 esi, esp
  022b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  022b9	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  022bc	51		 push	 ecx
  022bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4
  022c3	3b f4		 cmp	 esi, esp
  022c5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 989  : 	m_bExitThread = FALSE;

  022ca	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  022cd	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 990  : }

  022d4	5e		 pop	 esi
  022d5	83 c4 04	 add	 esp, 4
  022d8	3b ec		 cmp	 ebp, esp
  022da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  022df	8b e5		 mov	 esp, ebp
  022e1	5d		 pop	 ebp
  022e2	c3		 ret	 0
?Stop@CPictureEx@@QAEXXZ ENDP				; CPictureEx::Stop
_TEXT	ENDS
PUBLIC	?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z ; CPictureEx::TGIFControlExt::GetPackedValue
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_pGlobal$ = -36						; size = 4
_nOffset$ = -32						; size = 4
_hGlobal$ = -28						; size = 4
_pImage$188301 = -24					; size = 4
_pControl$188290 = -20					; size = 4
_nBlockLen$ = -16					; size = 4
_nStart$ = -12						; size = 4
_nBlock$ = -8						; size = 4
_this$ = -4						; size = 4
_pBlockLen$ = 8						; size = 4
_pDelay$ = 12						; size = 4
_pBlockSize$ = 16					; size = 4
_pBlockOffset$ = 20					; size = 4
_pDisposal$ = 24					; size = 4
?GetNextGraphicBlock@CPictureEx@@IAEPAXPAI0PAUtagSIZE@@10@Z PROC NEAR ; CPictureEx::GetNextGraphicBlock
; _this$ = ecx

; 995  : {

  022f0	55		 push	 ebp
  022f1	8b ec		 mov	 ebp, esp
  022f3	83 ec 24	 sub	 esp, 36			; 00000024H
  022f6	56		 push	 esi
  022f7	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  022fc	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  022ff	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  02302	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  02305	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  02308	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0230b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0230e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  02311	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  02314	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  02317	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 996  : 	if (!m_pRawData) return NULL;

  0231a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0231d	83 78 78 00	 cmp	 DWORD PTR [eax+120], 0
  02321	75 07		 jne	 SHORT $L188278
  02323	33 c0		 xor	 eax, eax
  02325	e9 4d 02 00 00	 jmp	 $L188277
$L188278:

; 997  : 
; 998  : 	// GIF header + LSDescriptor [+ GCT] [+ Control block] + Data
; 999  : 
; 1000 : 	*pDisposal = 0;

  0232a	8b 4d 18	 mov	 ecx, DWORD PTR _pDisposal$[ebp]
  0232d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1001 : 	enum GIFBlockTypes nBlock;
; 1002 : 	nBlock = GetNextBlock();

  02333	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02336	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  0233b	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax
$L188281:

; 1003 : 
; 1004 : 	while (
; 1005 : 		(nBlock != BLOCK_CONTROLEXT) &&
; 1006 : 		(nBlock != BLOCK_IMAGE) &&
; 1007 : 		(nBlock != BLOCK_PLAINTEXT) &&
; 1008 : 		(nBlock != BLOCK_UNKNOWN) &&
; 1009 : 		(nBlock != BLOCK_TRAILER)
; 1010 : 		)

  0233e	83 7d f8 03	 cmp	 DWORD PTR _nBlock$[ebp], 3
  02342	74 38		 je	 SHORT $L188282
  02344	83 7d f8 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  02348	74 32		 je	 SHORT $L188282
  0234a	83 7d f8 04	 cmp	 DWORD PTR _nBlock$[ebp], 4
  0234e	74 2c		 je	 SHORT $L188282
  02350	83 7d f8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  02354	74 26		 je	 SHORT $L188282
  02356	83 7d f8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  0235a	74 20		 je	 SHORT $L188282

; 1011 : 	{
; 1012 : 		if (!SkipNextBlock()) return NULL;

  0235c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0235f	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  02364	85 c0		 test	 eax, eax
  02366	75 07		 jne	 SHORT $L188283
  02368	33 c0		 xor	 eax, eax
  0236a	e9 08 02 00 00	 jmp	 $L188277
$L188283:

; 1013 : 		nBlock = GetNextBlock();

  0236f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02372	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  02377	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax

; 1014 : 	};

  0237a	eb c2		 jmp	 SHORT $L188281
$L188282:

; 1015 : 
; 1016 : 	if ((nBlock == BLOCK_UNKNOWN) ||
; 1017 : 		(nBlock == BLOCK_TRAILER))

  0237c	83 7d f8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  02380	74 06		 je	 SHORT $L188285
  02382	83 7d f8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  02386	75 07		 jne	 SHORT $L188284
$L188285:

; 1018 : 		return NULL;

  02388	33 c0		 xor	 eax, eax
  0238a	e9 e8 01 00 00	 jmp	 $L188277
$L188284:

; 1019 : 
; 1020 : 	// it's either a control ext.block, an image or a plain text
; 1021 : 
; 1022 : 	int nStart = m_nCurrOffset;

  0238f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02392	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  02395	89 45 f4	 mov	 DWORD PTR _nStart$[ebp], eax

; 1023 : 	int nBlockLen = GetNextBlockLen();

  02398	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0239b	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  023a0	89 45 f0	 mov	 DWORD PTR _nBlockLen$[ebp], eax

; 1024 : 
; 1025 : 	if (nBlockLen <= 0) return NULL;

  023a3	83 7d f0 00	 cmp	 DWORD PTR _nBlockLen$[ebp], 0
  023a7	7f 07		 jg	 SHORT $L188288
  023a9	33 c0		 xor	 eax, eax
  023ab	e9 c7 01 00 00	 jmp	 $L188277
$L188288:

; 1026 : 
; 1027 : 	if (nBlock == BLOCK_CONTROLEXT)

  023b0	83 7d f8 03	 cmp	 DWORD PTR _nBlock$[ebp], 3
  023b4	0f 85 b1 00 00
	00		 jne	 $L188289

; 1028 : 	{
; 1029 : 		// get the following data
; 1030 : 		TGIFControlExt *pControl = 
; 1031 : 			reinterpret_cast<TGIFControlExt *> (&m_pRawData[m_nCurrOffset]);

  023ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  023bd	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  023c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  023c3	03 50 34	 add	 edx, DWORD PTR [eax+52]
  023c6	89 55 ec	 mov	 DWORD PTR _pControl$188290[ebp], edx

; 1032 : 		// store delay time
; 1033 : 		*pDelay = pControl->m_wDelayTime;

  023c9	8b 4d ec	 mov	 ecx, DWORD PTR _pControl$188290[ebp]
  023cc	0f b7 51 04	 movzx	 edx, WORD PTR [ecx+4]
  023d0	8b 45 0c	 mov	 eax, DWORD PTR _pDelay$[ebp]
  023d3	89 10		 mov	 DWORD PTR [eax], edx

; 1034 : 		// store disposal method
; 1035 : 		*pDisposal = pControl->GetPackedValue(GCX_PACKED_DISPOSAL);

  023d5	6a 00		 push	 0
  023d7	8b 4d ec	 mov	 ecx, DWORD PTR _pControl$188290[ebp]
  023da	e8 00 00 00 00	 call	 ?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z ; CPictureEx::TGIFControlExt::GetPackedValue
  023df	8b 4d 18	 mov	 ecx, DWORD PTR _pDisposal$[ebp]
  023e2	89 01		 mov	 DWORD PTR [ecx], eax

; 1036 : 
; 1037 : 		if (!SkipNextBlock()) return NULL;

  023e4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  023e7	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  023ec	85 c0		 test	 eax, eax
  023ee	75 07		 jne	 SHORT $L188292
  023f0	33 c0		 xor	 eax, eax
  023f2	e9 80 01 00 00	 jmp	 $L188277
$L188292:

; 1038 : 		nBlock = GetNextBlock();

  023f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  023fa	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  023ff	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax
$L188294:

; 1039 : 		
; 1040 : 		// skip everything until we find data to display 
; 1041 : 		// (image block or plain-text block)
; 1042 : 		
; 1043 : 		while (
; 1044 : 			(nBlock != BLOCK_IMAGE) &&
; 1045 : 			(nBlock != BLOCK_PLAINTEXT) &&
; 1046 : 			(nBlock != BLOCK_UNKNOWN) &&
; 1047 : 			(nBlock != BLOCK_TRAILER)
; 1048 : 			)

  02402	83 7d f8 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  02406	74 40		 je	 SHORT $L188295
  02408	83 7d f8 04	 cmp	 DWORD PTR _nBlock$[ebp], 4
  0240c	74 3a		 je	 SHORT $L188295
  0240e	83 7d f8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  02412	74 34		 je	 SHORT $L188295
  02414	83 7d f8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  02418	74 2e		 je	 SHORT $L188295

; 1049 : 		{
; 1050 : 			if (!SkipNextBlock()) return NULL;

  0241a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0241d	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  02422	85 c0		 test	 eax, eax
  02424	75 07		 jne	 SHORT $L188296
  02426	33 c0		 xor	 eax, eax
  02428	e9 4a 01 00 00	 jmp	 $L188277
$L188296:

; 1051 : 			nBlock = GetNextBlock();

  0242d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02430	e8 00 00 00 00	 call	 ?GetNextBlock@CPictureEx@@IBE?AW4GIFBlockTypes@1@XZ ; CPictureEx::GetNextBlock
  02435	89 45 f8	 mov	 DWORD PTR _nBlock$[ebp], eax

; 1052 : 			nBlockLen += GetNextBlockLen();

  02438	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0243b	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  02440	03 45 f0	 add	 eax, DWORD PTR _nBlockLen$[ebp]
  02443	89 45 f0	 mov	 DWORD PTR _nBlockLen$[ebp], eax

; 1053 : 		};

  02446	eb ba		 jmp	 SHORT $L188294
$L188295:

; 1054 : 
; 1055 : 		if ((nBlock == BLOCK_UNKNOWN) || (nBlock == BLOCK_TRAILER))

  02448	83 7d f8 00	 cmp	 DWORD PTR _nBlock$[ebp], 0
  0244c	74 06		 je	 SHORT $L188298
  0244e	83 7d f8 06	 cmp	 DWORD PTR _nBlock$[ebp], 6
  02452	75 07		 jne	 SHORT $L188297
$L188298:

; 1056 : 			return NULL;

  02454	33 c0		 xor	 eax, eax
  02456	e9 1c 01 00 00	 jmp	 $L188277
$L188297:

; 1057 : 		nBlockLen += GetNextBlockLen();

  0245b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0245e	e8 00 00 00 00	 call	 ?GetNextBlockLen@CPictureEx@@IBEHXZ ; CPictureEx::GetNextBlockLen
  02463	03 45 f0	 add	 eax, DWORD PTR _nBlockLen$[ebp]
  02466	89 45 f0	 mov	 DWORD PTR _nBlockLen$[ebp], eax

; 1058 : 	}
; 1059 : 	else

  02469	eb 09		 jmp	 SHORT $L188299
$L188289:

; 1060 : 		*pDelay = -1; // to indicate that there was no delay value

  0246b	8b 55 0c	 mov	 edx, DWORD PTR _pDelay$[ebp]
  0246e	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
$L188299:

; 1061 : 
; 1062 : 	if (nBlock == BLOCK_IMAGE)

  02474	83 7d f8 05	 cmp	 DWORD PTR _nBlock$[ebp], 5
  02478	75 41		 jne	 SHORT $L188300

; 1063 : 	{
; 1064 : 		// store size and offsets
; 1065 : 		TGIFImageDescriptor *pImage = 
; 1066 : 			reinterpret_cast<TGIFImageDescriptor *> (&m_pRawData[m_nCurrOffset]);

  0247a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0247d	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  02480	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02483	03 4a 34	 add	 ecx, DWORD PTR [edx+52]
  02486	89 4d e8	 mov	 DWORD PTR _pImage$188301[ebp], ecx

; 1067 : 		pBlockSize->cx = pImage->m_wWidth;

  02489	8b 45 e8	 mov	 eax, DWORD PTR _pImage$188301[ebp]
  0248c	0f b7 48 05	 movzx	 ecx, WORD PTR [eax+5]
  02490	8b 55 10	 mov	 edx, DWORD PTR _pBlockSize$[ebp]
  02493	89 0a		 mov	 DWORD PTR [edx], ecx

; 1068 : 		pBlockSize->cy = pImage->m_wHeight;

  02495	8b 45 e8	 mov	 eax, DWORD PTR _pImage$188301[ebp]
  02498	0f b7 48 07	 movzx	 ecx, WORD PTR [eax+7]
  0249c	8b 55 10	 mov	 edx, DWORD PTR _pBlockSize$[ebp]
  0249f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1069 : 		pBlockOffset->cx = pImage->m_wLeftPos;

  024a2	8b 45 e8	 mov	 eax, DWORD PTR _pImage$188301[ebp]
  024a5	0f b7 48 01	 movzx	 ecx, WORD PTR [eax+1]
  024a9	8b 55 14	 mov	 edx, DWORD PTR _pBlockOffset$[ebp]
  024ac	89 0a		 mov	 DWORD PTR [edx], ecx

; 1070 : 		pBlockOffset->cy = pImage->m_wTopPos;

  024ae	8b 45 e8	 mov	 eax, DWORD PTR _pImage$188301[ebp]
  024b1	0f b7 48 03	 movzx	 ecx, WORD PTR [eax+3]
  024b5	8b 55 14	 mov	 edx, DWORD PTR _pBlockOffset$[ebp]
  024b8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$L188300:

; 1071 : 	};
; 1072 : 
; 1073 : 	if (!SkipNextBlock()) return NULL;

  024bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  024be	e8 00 00 00 00	 call	 ?SkipNextBlock@CPictureEx@@IAEHXZ ; CPictureEx::SkipNextBlock
  024c3	85 c0		 test	 eax, eax
  024c5	75 07		 jne	 SHORT $L188303
  024c7	33 c0		 xor	 eax, eax
  024c9	e9 a9 00 00 00	 jmp	 $L188277
$L188303:

; 1074 : 
; 1075 : 	HGLOBAL hGlobal = GlobalAlloc(GMEM_FIXED,
; 1076 : 		sizeof(TGIFHeader) +
; 1077 : 		sizeof(TGIFLSDescriptor) +
; 1078 : 		m_nGlobalCTSize +
; 1079 : 		nBlockLen + 
; 1080 : 		1);  // for the trailer

  024ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  024d1	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  024d4	8b 55 f0	 mov	 edx, DWORD PTR _nBlockLen$[ebp]
  024d7	8d 44 11 0e	 lea	 eax, DWORD PTR [ecx+edx+14]
  024db	8b f4		 mov	 esi, esp
  024dd	50		 push	 eax
  024de	6a 00		 push	 0
  024e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  024e6	3b f4		 cmp	 esi, esp
  024e8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  024ed	89 45 e4	 mov	 DWORD PTR _hGlobal$[ebp], eax

; 1081 : 
; 1082 : 	if (!hGlobal) return NULL;

  024f0	83 7d e4 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  024f4	75 04		 jne	 SHORT $L188307
  024f6	33 c0		 xor	 eax, eax
  024f8	eb 7d		 jmp	 SHORT $L188277
$L188307:

; 1083 : 
; 1084 : 	int nOffset = 0; 

  024fa	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _nOffset$[ebp], 0

; 1085 : 
; 1086 : 	// GMEM_FIXED means we get a pointer
; 1087 : 	unsigned char *pGlobal = reinterpret_cast<unsigned char *> (hGlobal);

  02501	8b 4d e4	 mov	 ecx, DWORD PTR _hGlobal$[ebp]
  02504	89 4d dc	 mov	 DWORD PTR _pGlobal$[ebp], ecx

; 1088 : 
; 1089 : 	CopyMemory(pGlobal,m_pRawData, 
; 1090 : 		sizeof(TGIFHeader)+sizeof(TGIFLSDescriptor)+m_nGlobalCTSize);

  02507	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0250a	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0250d	83 c0 0d	 add	 eax, 13			; 0000000dH
  02510	50		 push	 eax
  02511	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02514	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  02517	52		 push	 edx
  02518	8b 45 dc	 mov	 eax, DWORD PTR _pGlobal$[ebp]
  0251b	50		 push	 eax
  0251c	e8 00 00 00 00	 call	 _memcpy
  02521	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1091 : 	nOffset += sizeof(TGIFHeader)+sizeof(TGIFLSDescriptor)+m_nGlobalCTSize;

  02524	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02527	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0252a	8b 45 e0	 mov	 eax, DWORD PTR _nOffset$[ebp]
  0252d	8d 4c 10 0d	 lea	 ecx, DWORD PTR [eax+edx+13]
  02531	89 4d e0	 mov	 DWORD PTR _nOffset$[ebp], ecx

; 1092 : 
; 1093 : 	CopyMemory(pGlobal + nOffset,&m_pRawData[nStart], nBlockLen);

  02534	8b 55 f0	 mov	 edx, DWORD PTR _nBlockLen$[ebp]
  02537	52		 push	 edx
  02538	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0253b	8b 48 78	 mov	 ecx, DWORD PTR [eax+120]
  0253e	03 4d f4	 add	 ecx, DWORD PTR _nStart$[ebp]
  02541	51		 push	 ecx
  02542	8b 55 dc	 mov	 edx, DWORD PTR _pGlobal$[ebp]
  02545	03 55 e0	 add	 edx, DWORD PTR _nOffset$[ebp]
  02548	52		 push	 edx
  02549	e8 00 00 00 00	 call	 _memcpy
  0254e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1094 : 	nOffset += nBlockLen;

  02551	8b 45 e0	 mov	 eax, DWORD PTR _nOffset$[ebp]
  02554	03 45 f0	 add	 eax, DWORD PTR _nBlockLen$[ebp]
  02557	89 45 e0	 mov	 DWORD PTR _nOffset$[ebp], eax

; 1095 : 
; 1096 : 	pGlobal[nOffset] = 0x3B; // trailer

  0255a	8b 4d dc	 mov	 ecx, DWORD PTR _pGlobal$[ebp]
  0255d	03 4d e0	 add	 ecx, DWORD PTR _nOffset$[ebp]
  02560	c6 01 3b	 mov	 BYTE PTR [ecx], 59	; 0000003bH

; 1097 : 	nOffset++;

  02563	8b 55 e0	 mov	 edx, DWORD PTR _nOffset$[ebp]
  02566	83 c2 01	 add	 edx, 1
  02569	89 55 e0	 mov	 DWORD PTR _nOffset$[ebp], edx

; 1098 : 
; 1099 : 	*pBlockLen = nOffset;

  0256c	8b 45 08	 mov	 eax, DWORD PTR _pBlockLen$[ebp]
  0256f	8b 4d e0	 mov	 ecx, DWORD PTR _nOffset$[ebp]
  02572	89 08		 mov	 DWORD PTR [eax], ecx

; 1100 : 
; 1101 : 	return hGlobal;

  02574	8b 45 e4	 mov	 eax, DWORD PTR _hGlobal$[ebp]
$L188277:

; 1102 : }

  02577	5e		 pop	 esi
  02578	83 c4 24	 add	 esp, 36			; 00000024H
  0257b	3b ec		 cmp	 ebp, esp
  0257d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02582	8b e5		 mov	 esp, ebp
  02584	5d		 pop	 ebp
  02585	c2 14 00	 ret	 20			; 00000014H
?GetNextGraphicBlock@CPictureEx@@IAEPAXPAI0PAUtagSIZE@@10@Z ENDP ; CPictureEx::GetNextGraphicBlock
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z
_TEXT	SEGMENT
tv66 = -12						; size = 4
_nRet$ = -8						; size = 4
_this$ = -4						; size = 4
_Value$ = 8						; size = 4
?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z PROC NEAR ; CPictureEx::TGIFControlExt::GetPackedValue, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   : 	int nRet = (int)m_cPacked;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00025	89 4d f8	 mov	 DWORD PTR _nRet$[ebp], ecx

; 97   : 	switch (Value)

  00028	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  0002b	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  0002e	83 7d f4 00	 cmp	 DWORD PTR tv66[ebp], 0
  00032	74 0e		 je	 SHORT $L187756
  00034	83 7d f4 01	 cmp	 DWORD PTR tv66[ebp], 1
  00038	74 16		 je	 SHORT $L187757
  0003a	83 7d f4 02	 cmp	 DWORD PTR tv66[ebp], 2
  0003e	74 1d		 je	 SHORT $L187758
  00040	eb 24		 jmp	 SHORT $L187753
$L187756:

; 98   : 	{
; 99   : 	case GCX_PACKED_DISPOSAL:
; 100  : 		nRet = (nRet & 28) >> 2;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _nRet$[ebp]
  00045	83 e0 1c	 and	 eax, 28			; 0000001cH
  00048	c1 f8 02	 sar	 eax, 2
  0004b	89 45 f8	 mov	 DWORD PTR _nRet$[ebp], eax

; 101  : 		break;

  0004e	eb 16		 jmp	 SHORT $L187753
$L187757:

; 102  : 
; 103  : 	case GCX_PACKED_USERINPUT:
; 104  : 		nRet = (nRet & 2) >> 1;

  00050	8b 4d f8	 mov	 ecx, DWORD PTR _nRet$[ebp]
  00053	83 e1 02	 and	 ecx, 2
  00056	d1 f9		 sar	 ecx, 1
  00058	89 4d f8	 mov	 DWORD PTR _nRet$[ebp], ecx

; 105  : 		break;

  0005b	eb 09		 jmp	 SHORT $L187753
$L187758:

; 106  : 
; 107  : 	case GCX_PACKED_TRANSPCOLOR:
; 108  : 		nRet &= 1;

  0005d	8b 55 f8	 mov	 edx, DWORD PTR _nRet$[ebp]
  00060	83 e2 01	 and	 edx, 1
  00063	89 55 f8	 mov	 DWORD PTR _nRet$[ebp], edx
$L187753:

; 109  : 		break;
; 110  : 	};
; 111  : 
; 112  : 	return nRet;

  00066	8b 45 f8	 mov	 eax, DWORD PTR _nRet$[ebp]

; 113  : }

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
?GetPackedValue@TGIFControlExt@CPictureEx@@QAEHW4ControlExtValues@2@@Z ENDP ; CPictureEx::TGIFControlExt::GetPackedValue
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltrace.h
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC NEAR	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 158  : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 45 0c	 mov	 eax, DWORD PTR _nLineNo$[ebp]
  0001c	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
PUBLIC	?IsGIF@CPictureEx@@QBEHXZ			; CPictureEx::IsGIF
; Function compile flags: /Odt /RTCsu
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\pictureex.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGIF@CPictureEx@@QBEHXZ PROC NEAR			; CPictureEx::IsGIF
; _this$ = ecx

; 1105 : {

  02590	55		 push	 ebp
  02591	8b ec		 mov	 ebp, esp
  02593	51		 push	 ecx
  02594	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0259b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1106 : 	return m_bIsGIF;

  0259e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  025a1	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]

; 1107 : }

  025a4	8b e5		 mov	 esp, ebp
  025a6	5d		 pop	 ebp
  025a7	c3		 ret	 0
?IsGIF@CPictureEx@@QBEHXZ ENDP				; CPictureEx::IsGIF
; Function compile flags: /Odt /RTCsu
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?IsAnimatedGIF@CPictureEx@@QBEHXZ PROC NEAR		; CPictureEx::IsAnimatedGIF
; _this$ = ecx

; 1110 : {

  025b0	55		 push	 ebp
  025b1	8b ec		 mov	 ebp, esp
  025b3	83 ec 08	 sub	 esp, 8
  025b6	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  025bd	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  025c4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1111 : 	return (m_bIsGIF && (m_arrFrames.size() > 1));

  025c7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  025ca	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  025ce	74 1c		 je	 SHORT $L189773
  025d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  025d3	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  025d9	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  025de	83 f8 01	 cmp	 eax, 1
  025e1	76 09		 jbe	 SHORT $L189773
  025e3	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  025ea	eb 07		 jmp	 SHORT $L189774
$L189773:
  025ec	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$L189774:
  025f3	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 1112 : }

  025f6	83 c4 08	 add	 esp, 8
  025f9	3b ec		 cmp	 ebp, esp
  025fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02600	8b e5		 mov	 esp, ebp
  02602	5d		 pop	 ebp
  02603	c3		 ret	 0
?IsAnimatedGIF@CPictureEx@@QBEHXZ ENDP			; CPictureEx::IsAnimatedGIF
_TEXT	ENDS
PUBLIC	?IsPlaying@CPictureEx@@QBEHXZ			; CPictureEx::IsPlaying
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlaying@CPictureEx@@QBEHXZ PROC NEAR			; CPictureEx::IsPlaying
; _this$ = ecx

; 1115 : {

  02610	55		 push	 ebp
  02611	8b ec		 mov	 ebp, esp
  02613	51		 push	 ecx
  02614	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0261b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1116 : 	return m_bIsPlaying;

  0261e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02621	8b 40 40	 mov	 eax, DWORD PTR [eax+64]

; 1117 : }

  02624	8b e5		 mov	 esp, ebp
  02626	5d		 pop	 ebp
  02627	c3		 ret	 0
?IsPlaying@CPictureEx@@QBEHXZ ENDP			; CPictureEx::IsPlaying
_TEXT	ENDS
PUBLIC	?GetFrameCount@CPictureEx@@QBEHXZ		; CPictureEx::GetFrameCount
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFrameCount@CPictureEx@@QBEHXZ PROC NEAR		; CPictureEx::GetFrameCount
; _this$ = ecx

; 1120 : {

  02630	55		 push	 ebp
  02631	8b ec		 mov	 ebp, esp
  02633	51		 push	 ecx
  02634	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0263b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1121 : 	if (!IsAnimatedGIF())

  0263e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02641	e8 00 00 00 00	 call	 ?IsAnimatedGIF@CPictureEx@@QBEHXZ ; CPictureEx::IsAnimatedGIF
  02646	85 c0		 test	 eax, eax
  02648	75 04		 jne	 SHORT $L188327

; 1122 : 		return 0;

  0264a	33 c0		 xor	 eax, eax
  0264c	eb 0e		 jmp	 SHORT $L188326
$L188327:

; 1123 : 
; 1124 : 	return (int)(m_arrFrames.size());

  0264e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02651	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02657	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
$L188326:

; 1125 : }

  0265c	83 c4 04	 add	 esp, 4
  0265f	3b ec		 cmp	 ebp, esp
  02661	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02666	8b e5		 mov	 esp, ebp
  02668	5d		 pop	 ebp
  02669	c3		 ret	 0
?GetFrameCount@CPictureEx@@QBEHXZ ENDP			; CPictureEx::GetFrameCount
_TEXT	ENDS
PUBLIC	??BCTraceCategory@ATL@@QBEKXZ			; ATL::CTraceCategory::operator unsigned long
PUBLIC	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z		; ATL::CTrace::TraceV
EXTRN	?s_trace@CTrace@ATL@@2V12@A:QWORD		; ATL::CTrace::s_trace
EXTRN	?atlTraceGeneral@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceGeneral
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltrace.h
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ
_TEXT	SEGMENT
_ptr$ = -4						; size = 4
_this$ = 8						; size = 4
_pszFmt$ = 12						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ PROC NEAR	; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 173  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 174  : 		va_list ptr; va_start(ptr, pszFmt);

  0000b	8d 45 10	 lea	 eax, DWORD PTR _pszFmt$[ebp+4]
  0000e	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 175  : 		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, atlTraceGeneral, 0, pszFmt, ptr);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00014	51		 push	 ecx
  00015	8b 55 0c	 mov	 edx, DWORD PTR _pszFmt$[ebp]
  00018	52		 push	 edx
  00019	6a 00		 push	 0
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?atlTraceGeneral@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceGeneral
  00020	e8 00 00 00 00	 call	 ??BCTraceCategory@ATL@@QBEKXZ ; ATL::CTraceCategory::operator unsigned long
  00025	50		 push	 eax
  00026	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	51		 push	 ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET FLAT:?s_trace@CTrace@ATL@@2V12@A
  00038	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z ; ATL::CTrace::TraceV
  0003d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 176  : 		va_end(ptr);

  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], 0

; 177  : 	}

  00047	83 c4 04	 add	 esp, 4
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
EXTRN	_AtlTraceVA:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pszFileName$ = 12					; size = 4
_nLine$ = 16						; size = 4
_dwCategory$ = 20					; size = 4
_nLevel$ = 24						; size = 4
_pszFmt$ = 28						; size = 4
_args$ = 32						; size = 4
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z PROC NEAR		; ATL::CTrace::TraceV, COMDAT

; 121  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  : 		AtlTraceVA(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);

  00003	8b 45 20	 mov	 eax, DWORD PTR _args$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 1c	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 18	 mov	 edx, DWORD PTR _nLevel$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 14	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  00012	50		 push	 eax
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 0c	 mov	 edx, DWORD PTR _pszFileName$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _AtlTraceVA
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH

; 123  : 	}

  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z ENDP		; ATL::CTrace::TraceV
_TEXT	ENDS
PUBLIC	?GetBkColor@CPictureEx@@QBEKXZ			; CPictureEx::GetBkColor
; Function compile flags: /Odt /RTCsu
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\pictureex.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBkColor@CPictureEx@@QBEKXZ PROC NEAR		; CPictureEx::GetBkColor
; _this$ = ecx

; 1128 : {

  02670	55		 push	 ebp
  02671	8b ec		 mov	 ebp, esp
  02673	51		 push	 ecx
  02674	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0267b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1129 : 	return m_clrBackground;

  0267e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02681	8b 40 28	 mov	 eax, DWORD PTR [eax+40]

; 1130 : }

  02684	8b e5		 mov	 esp, ebp
  02686	5d		 pop	 ebp
  02687	c3		 ret	 0
?GetBkColor@CPictureEx@@QBEKXZ ENDP			; CPictureEx::GetBkColor
_TEXT	ENDS
PUBLIC	?HitTest@CPictureEx@@QAEHVCPoint@@@Z		; CPictureEx::HitTest
PUBLIC	?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ		; CArray<CRect,CRect>::GetSize
PUBLIC	?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z	; CArray<CRect,CRect>::GetAt
EXTRN	?Offset@CPoint@@QAEXHH@Z:NEAR			; CPoint::Offset
EXTRN	??0CRect@@QAE@HHHH@Z:NEAR			; CRect::CRect
EXTRN	?CenterPoint@CRect@@QBE?AVCPoint@@XZ:NEAR	; CRect::CenterPoint
EXTRN	?PtInRect@CRect@@QBEHUtagPOINT@@@Z:NEAR		; CRect::PtInRect
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T189781 = -80						; size = 8
_r$188343 = -68						; size = 16
_p1$188341 = -44					; size = 8
_rc$188340 = -28					; size = 16
_i$188336 = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 8
?HitTest@CPictureEx@@QAEHVCPoint@@@Z PROC NEAR		; CPictureEx::HitTest
; _this$ = ecx

; 1133 : {

  02690	55		 push	 ebp
  02691	8b ec		 mov	 ebp, esp
  02693	83 ec 50	 sub	 esp, 80			; 00000050H
  02696	57		 push	 edi
  02697	51		 push	 ecx
  02698	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0269b	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  026a0	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  026a5	f3 ab		 rep stosd
  026a7	59		 pop	 ecx
  026a8	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1134 : 	for(int i = 0 ; i<m_aryPoint->GetSize(); i++)

  026ab	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$188336[ebp], 0
  026b2	eb 09		 jmp	 SHORT $L188337
$L188338:
  026b4	8b 45 f8	 mov	 eax, DWORD PTR _i$188336[ebp]
  026b7	83 c0 01	 add	 eax, 1
  026ba	89 45 f8	 mov	 DWORD PTR _i$188336[ebp], eax
$L188337:
  026bd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  026c0	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [ecx+144]
  026c6	e8 00 00 00 00	 call	 ?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ ; CArray<CRect,CRect>::GetSize
  026cb	39 45 f8	 cmp	 DWORD PTR _i$188336[ebp], eax
  026ce	0f 8d a9 00 00
	00		 jge	 $L188339

; 1135 : 	{
; 1136 : 		
; 1137 : 		CRect rc = m_aryPoint->GetAt(i);

  026d4	8b 55 f8	 mov	 edx, DWORD PTR _i$188336[ebp]
  026d7	52		 push	 edx
  026d8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  026db	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  026e1	e8 00 00 00 00	 call	 ?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z ; CArray<CRect,CRect>::GetAt
  026e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  026e8	89 4d e4	 mov	 DWORD PTR _rc$188340[ebp], ecx
  026eb	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  026ee	89 55 e8	 mov	 DWORD PTR _rc$188340[ebp+4], edx
  026f1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  026f4	89 4d ec	 mov	 DWORD PTR _rc$188340[ebp+8], ecx
  026f7	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  026fa	89 55 f0	 mov	 DWORD PTR _rc$188340[ebp+12], edx

; 1138 : 		CPoint p1 = rc.CenterPoint();

  026fd	8d 45 d4	 lea	 eax, DWORD PTR _p1$188341[ebp]
  02700	50		 push	 eax
  02701	8d 4d e4	 lea	 ecx, DWORD PTR _rc$188340[ebp]
  02704	e8 00 00 00 00	 call	 ?CenterPoint@CRect@@QBE?AVCPoint@@XZ ; CRect::CenterPoint

; 1139 : 		p1.Offset(-m_PictureSize.cx/2 , - m_PictureSize.cy/2);

  02709	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0270c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0270f	f7 d8		 neg	 eax
  02711	99		 cdq
  02712	2b c2		 sub	 eax, edx
  02714	d1 f8		 sar	 eax, 1
  02716	50		 push	 eax
  02717	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0271a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0271d	f7 d8		 neg	 eax
  0271f	99		 cdq
  02720	2b c2		 sub	 eax, edx
  02722	d1 f8		 sar	 eax, 1
  02724	50		 push	 eax
  02725	8d 4d d4	 lea	 ecx, DWORD PTR _p1$188341[ebp]
  02728	e8 00 00 00 00	 call	 ?Offset@CPoint@@QAEXHH@Z ; CPoint::Offset

; 1140 : 		CRect r(p1.x, p1.y, p1.x + m_PictureSize.cx , p1.y + m_PictureSize.cy);

  0272d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02730	8b 4d d8	 mov	 ecx, DWORD PTR _p1$188341[ebp+4]
  02733	03 48 24	 add	 ecx, DWORD PTR [eax+36]
  02736	51		 push	 ecx
  02737	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0273a	8b 45 d4	 mov	 eax, DWORD PTR _p1$188341[ebp]
  0273d	03 42 20	 add	 eax, DWORD PTR [edx+32]
  02740	50		 push	 eax
  02741	8b 4d d8	 mov	 ecx, DWORD PTR _p1$188341[ebp+4]
  02744	51		 push	 ecx
  02745	8b 55 d4	 mov	 edx, DWORD PTR _p1$188341[ebp]
  02748	52		 push	 edx
  02749	8d 4d bc	 lea	 ecx, DWORD PTR _r$188343[ebp]
  0274c	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect

; 1141 : 
; 1142 : 		if(r.PtInRect(p))

  02751	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  02754	89 45 b0	 mov	 DWORD PTR $T189781[ebp], eax
  02757	8b 4d 0c	 mov	 ecx, DWORD PTR _p$[ebp+4]
  0275a	89 4d b4	 mov	 DWORD PTR $T189781[ebp+4], ecx
  0275d	8b 55 b4	 mov	 edx, DWORD PTR $T189781[ebp+4]
  02760	52		 push	 edx
  02761	8b 45 b0	 mov	 eax, DWORD PTR $T189781[ebp]
  02764	50		 push	 eax
  02765	8d 4d bc	 lea	 ecx, DWORD PTR _r$188343[ebp]
  02768	e8 00 00 00 00	 call	 ?PtInRect@CRect@@QBEHUtagPOINT@@@Z ; CRect::PtInRect
  0276d	85 c0		 test	 eax, eax
  0276f	74 07		 je	 SHORT $L188345

; 1143 : 			return TRUE;

  02771	b8 01 00 00 00	 mov	 eax, 1
  02776	eb 07		 jmp	 SHORT $L188335
$L188345:

; 1144 : 	}

  02778	e9 37 ff ff ff	 jmp	 $L188338
$L188339:

; 1145 : 
; 1146 : 	return FALSE;

  0277d	33 c0		 xor	 eax, eax
$L188335:

; 1147 : }

  0277f	52		 push	 edx
  02780	8b cd		 mov	 ecx, ebp
  02782	50		 push	 eax
  02783	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189786
  02789	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0278e	58		 pop	 eax
  0278f	5a		 pop	 edx
  02790	5f		 pop	 edi
  02791	83 c4 50	 add	 esp, 80			; 00000050H
  02794	3b ec		 cmp	 ebp, esp
  02796	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0279b	8b e5		 mov	 esp, ebp
  0279d	5d		 pop	 ebp
  0279e	c2 08 00	 ret	 8
$L189786:
  027a1	03 00 00 00	 DD	 3
  027a5	00 00 00 00	 DD	 $L189785
$L189785:
  027a9	e4 ff ff ff	 DD	 -28			; ffffffe4H
  027ad	10 00 00 00	 DD	 16			; 00000010H
  027b1	00 00 00 00	 DD	 $L189782
  027b5	d4 ff ff ff	 DD	 -44			; ffffffd4H
  027b9	08 00 00 00	 DD	 8
  027bd	00 00 00 00	 DD	 $L189783
  027c1	bc ff ff ff	 DD	 -68			; ffffffbcH
  027c5	10 00 00 00	 DD	 16			; 00000010H
  027c9	00 00 00 00	 DD	 $L189784
$L189784:
  027cd	72		 DB	 114			; 00000072H
  027ce	00		 DB	 0
$L189783:
  027cf	70		 DB	 112			; 00000070H
  027d0	31		 DB	 49			; 00000031H
  027d1	00		 DB	 0
$L189782:
  027d2	72		 DB	 114			; 00000072H
  027d3	63		 DB	 99			; 00000063H
  027d4	00		 DB	 0
?HitTest@CPictureEx@@QAEHVCPoint@@@Z ENDP		; CPictureEx::HitTest
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\atltrace.h
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCTraceCategory@ATL@@QBEKXZ PROC NEAR			; ATL::CTraceCategory::operator unsigned long, COMDAT
; _this$ = ecx

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 203  : 	return( m_dwCategory );

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 204  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??BCTraceCategory@ATL@@QBEKXZ ENDP			; ATL::CTraceCategory::operator unsigned long
_TEXT	ENDS
EXTRN	__imp__RestoreDC@8:NEAR
EXTRN	__imp__SaveDC@4:NEAR
EXTRN	__imp__StretchBlt@44:NEAR
EXTRN	__imp__SetStretchBltMode@8:NEAR
EXTRN	__imp__TransparentBlt@44:NEAR
EXTRN	?Width@CRect@@QBEHXZ:NEAR			; CRect::Width
EXTRN	?Height@CRect@@QBEHXZ:NEAR			; CRect::Height
; Function compile flags: /Odt /RTCsu
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\pictureex.cpp
_TEXT	SEGMENT
_nPaintHeight$188362 = -60				; size = 4
_p$188360 = -52						; size = 8
_rc$188359 = -36					; size = 16
_i$188355 = -16						; size = 4
_iSaveDC$ = -12						; size = 4
_dc$ = -8						; size = 4
_this$ = -4						; size = 4
_memdc$ = 8						; size = 4
?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z PROC NEAR		; CPictureEx::OnPaint
; _this$ = ecx

; 1149 : {

  027e0	55		 push	 ebp
  027e1	8b ec		 mov	 ebp, esp
  027e3	83 ec 3c	 sub	 esp, 60			; 0000003cH
  027e6	56		 push	 esi
  027e7	57		 push	 edi
  027e8	51		 push	 ecx
  027e9	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  027ec	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  027f1	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  027f6	f3 ab		 rep stosd
  027f8	59		 pop	 ecx
  027f9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1150 : 	//CPaintDC dc(this); // device context for painting
; 1151 : 	////Lock lock(_csGifOnPaint);;
; 1152 : 	if(m_bPause)

  027fc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  027ff	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  02803	85 c9		 test	 ecx, ecx
  02805	74 05		 je	 SHORT $L188350

; 1153 : 		return;

  02807	e9 58 02 00 00	 jmp	 $L188349
$L188350:

; 1154 : 	HDC dc = NULL;

  0280c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dc$[ebp], 0

; 1155 : 	int iSaveDC = 0;

  02813	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iSaveDC$[ebp], 0

; 1156 : 
; 1157 : 	if(memdc == NULL)

  0281a	83 7d 08 00	 cmp	 DWORD PTR _memdc$[ebp], 0
  0281e	75 31		 jne	 SHORT $L188353

; 1158 : 	{
; 1159 : 		dc = ::GetDC(m_hWnd);

  02820	8b f4		 mov	 esi, esp
  02822	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02825	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02828	50		 push	 eax
  02829	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  0282f	3b f4		 cmp	 esi, esp
  02831	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02836	89 45 f8	 mov	 DWORD PTR _dc$[ebp], eax

; 1160 : 		iSaveDC = SaveDC( dc );

  02839	8b f4		 mov	 esi, esp
  0283b	8b 4d f8	 mov	 ecx, DWORD PTR _dc$[ebp]
  0283e	51		 push	 ecx
  0283f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SaveDC@4
  02845	3b f4		 cmp	 esi, esp
  02847	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0284c	89 45 f4	 mov	 DWORD PTR _iSaveDC$[ebp], eax

; 1161 : 	}
; 1162 : 	else

  0284f	eb 06		 jmp	 SHORT $L188354
$L188353:

; 1163 : 	  dc = memdc;

  02851	8b 55 08	 mov	 edx, DWORD PTR _memdc$[ebp]
  02854	89 55 f8	 mov	 DWORD PTR _dc$[ebp], edx
$L188354:

; 1164 : 
; 1165 : 	for(int i = 0 ; i<m_aryPoint->GetSize(); i++)

  02857	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$188355[ebp], 0
  0285e	eb 09		 jmp	 SHORT $L188356
$L188357:
  02860	8b 45 f0	 mov	 eax, DWORD PTR _i$188355[ebp]
  02863	83 c0 01	 add	 eax, 1
  02866	89 45 f0	 mov	 DWORD PTR _i$188355[ebp], eax
$L188356:
  02869	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0286c	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [ecx+144]
  02872	e8 00 00 00 00	 call	 ?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ ; CArray<CRect,CRect>::GetSize
  02877	39 45 f0	 cmp	 DWORD PTR _i$188355[ebp], eax
  0287a	0f 8d ad 01 00
	00		 jge	 $L188358

; 1166 : 	{
; 1167 : 		CRect rc = m_aryPoint->GetAt(i);

  02880	8b 55 f0	 mov	 edx, DWORD PTR _i$188355[ebp]
  02883	52		 push	 edx
  02884	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02887	8b 88 90 00 00
	00		 mov	 ecx, DWORD PTR [eax+144]
  0288d	e8 00 00 00 00	 call	 ?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z ; CArray<CRect,CRect>::GetAt
  02892	8b 08		 mov	 ecx, DWORD PTR [eax]
  02894	89 4d dc	 mov	 DWORD PTR _rc$188359[ebp], ecx
  02897	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0289a	89 55 e0	 mov	 DWORD PTR _rc$188359[ebp+4], edx
  0289d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  028a0	89 4d e4	 mov	 DWORD PTR _rc$188359[ebp+8], ecx
  028a3	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  028a6	89 55 e8	 mov	 DWORD PTR _rc$188359[ebp+12], edx

; 1168 : 		CPoint p = rc.CenterPoint();

  028a9	8d 45 cc	 lea	 eax, DWORD PTR _p$188360[ebp]
  028ac	50		 push	 eax
  028ad	8d 4d dc	 lea	 ecx, DWORD PTR _rc$188359[ebp]
  028b0	e8 00 00 00 00	 call	 ?CenterPoint@CRect@@QBE?AVCPoint@@XZ ; CRect::CenterPoint

; 1169 : 		p.Offset(-m_PictureSize.cx/2 , - m_PictureSize.cy/2);

  028b5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  028b8	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  028bb	f7 d8		 neg	 eax
  028bd	99		 cdq
  028be	2b c2		 sub	 eax, edx
  028c0	d1 f8		 sar	 eax, 1
  028c2	50		 push	 eax
  028c3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  028c6	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  028c9	f7 d8		 neg	 eax
  028cb	99		 cdq
  028cc	2b c2		 sub	 eax, edx
  028ce	d1 f8		 sar	 eax, 1
  028d0	50		 push	 eax
  028d1	8d 4d cc	 lea	 ecx, DWORD PTR _p$188360[ebp]
  028d4	e8 00 00 00 00	 call	 ?Offset@CPoint@@QAEXHH@Z ; CPoint::Offset

; 1170 : 				
; 1171 : 		LONG nPaintHeight = m_PaintRect.bottom - m_PaintRect.top;

  028d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  028dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  028df	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  028e2	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  028e5	89 55 c4	 mov	 DWORD PTR _nPaintHeight$188362[ebp], edx

; 1172 : 		if(!m_bStretch)

  028e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  028eb	0f b6 48 5c	 movzx	 ecx, BYTE PTR [eax+92]
  028ef	85 c9		 test	 ecx, ecx
  028f1	0f 85 d1 00 00
	00		 jne	 $L188363

; 1173 : 		{
; 1174 : 			if(m_bHasMask)

  028f7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  028fa	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  028fe	0f 84 89 00 00
	00		 je	 $L188364

; 1175 : 			{
; 1176 : 				StretchBlt(dc, p.x, p.y,  m_PictureSize.cx, m_PictureSize.cy,
; 1177 : 					dc, rc.right, p.y, 1, m_PictureSize.cy, SRCCOPY);

  02904	8b f4		 mov	 esi, esp
  02906	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0290b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0290e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  02911	51		 push	 ecx
  02912	6a 01		 push	 1
  02914	8b 55 d0	 mov	 edx, DWORD PTR _p$188360[ebp+4]
  02917	52		 push	 edx
  02918	8b 45 e4	 mov	 eax, DWORD PTR _rc$188359[ebp+8]
  0291b	50		 push	 eax
  0291c	8b 4d f8	 mov	 ecx, DWORD PTR _dc$[ebp]
  0291f	51		 push	 ecx
  02920	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02923	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  02926	50		 push	 eax
  02927	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0292a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0292d	52		 push	 edx
  0292e	8b 45 d0	 mov	 eax, DWORD PTR _p$188360[ebp+4]
  02931	50		 push	 eax
  02932	8b 4d cc	 mov	 ecx, DWORD PTR _p$188360[ebp]
  02935	51		 push	 ecx
  02936	8b 55 f8	 mov	 edx, DWORD PTR _dc$[ebp]
  02939	52		 push	 edx
  0293a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchBlt@44
  02940	3b f4		 cmp	 esi, esp
  02942	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1178 : 
; 1179 : 				::TransparentBlt(dc, p.x, p.y, m_PictureSize.cx, m_PictureSize.cy,
; 1180 : 					m_hMemDC, 0, 0, m_PictureSize.cx, m_PictureSize.cy,RGB(0,0,0));

  02947	8b f4		 mov	 esi, esp
  02949	6a 00		 push	 0
  0294b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0294e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  02951	51		 push	 ecx
  02952	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02955	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  02958	50		 push	 eax
  02959	6a 00		 push	 0
  0295b	6a 00		 push	 0
  0295d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02960	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  02963	52		 push	 edx
  02964	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02967	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0296a	51		 push	 ecx
  0296b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0296e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  02971	50		 push	 eax
  02972	8b 4d d0	 mov	 ecx, DWORD PTR _p$188360[ebp+4]
  02975	51		 push	 ecx
  02976	8b 55 cc	 mov	 edx, DWORD PTR _p$188360[ebp]
  02979	52		 push	 edx
  0297a	8b 45 f8	 mov	 eax, DWORD PTR _dc$[ebp]
  0297d	50		 push	 eax
  0297e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TransparentBlt@44
  02984	3b f4		 cmp	 esi, esp
  02986	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1181 : 			}
; 1182 : 			else

  0298b	eb 39		 jmp	 SHORT $L188372
$L188364:

; 1183 : 			{
; 1184 : 				BitBlt(dc, p.x, p.y, m_PictureSize.cx, m_PictureSize.cy, m_hMemDC, 0, 0,SRCCOPY);

  0298d	8b f4		 mov	 esi, esp
  0298f	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  02994	6a 00		 push	 0
  02996	6a 00		 push	 0
  02998	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0299b	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  0299e	52		 push	 edx
  0299f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  029a2	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  029a5	51		 push	 ecx
  029a6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  029a9	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  029ac	50		 push	 eax
  029ad	8b 4d d0	 mov	 ecx, DWORD PTR _p$188360[ebp+4]
  029b0	51		 push	 ecx
  029b1	8b 55 cc	 mov	 edx, DWORD PTR _p$188360[ebp]
  029b4	52		 push	 edx
  029b5	8b 45 f8	 mov	 eax, DWORD PTR _dc$[ebp]
  029b8	50		 push	 eax
  029b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  029bf	3b f4		 cmp	 esi, esp
  029c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188372:

; 1185 : 			}
; 1186 : 		}
; 1187 : 		else

  029c6	eb 60		 jmp	 SHORT $L188374
$L188363:

; 1188 : 		{
; 1189 : 			SetStretchBltMode(dc,STRETCH_DELETESCANS); 

  029c8	8b f4		 mov	 esi, esp
  029ca	6a 03		 push	 3
  029cc	8b 4d f8	 mov	 ecx, DWORD PTR _dc$[ebp]
  029cf	51		 push	 ecx
  029d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetStretchBltMode@8
  029d6	3b f4		 cmp	 esi, esp
  029d8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1190 : 			StretchBlt(dc, rc.left, rc.top, rc.Width(), rc.Height(), m_hMemDC, 0, 0,m_PictureSize.cx, m_PictureSize.cy, SRCCOPY);

  029dd	8b f4		 mov	 esi, esp
  029df	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  029e4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  029e7	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  029ea	50		 push	 eax
  029eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  029ee	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  029f1	52		 push	 edx
  029f2	6a 00		 push	 0
  029f4	6a 00		 push	 0
  029f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  029f9	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  029fc	51		 push	 ecx
  029fd	8d 4d dc	 lea	 ecx, DWORD PTR _rc$188359[ebp]
  02a00	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  02a05	50		 push	 eax
  02a06	8d 4d dc	 lea	 ecx, DWORD PTR _rc$188359[ebp]
  02a09	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  02a0e	50		 push	 eax
  02a0f	8b 55 e0	 mov	 edx, DWORD PTR _rc$188359[ebp+4]
  02a12	52		 push	 edx
  02a13	8b 45 dc	 mov	 eax, DWORD PTR _rc$188359[ebp]
  02a16	50		 push	 eax
  02a17	8b 4d f8	 mov	 ecx, DWORD PTR _dc$[ebp]
  02a1a	51		 push	 ecx
  02a1b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchBlt@44
  02a21	3b f4		 cmp	 esi, esp
  02a23	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188374:

; 1191 : 		}		
; 1192 : 	}

  02a28	e9 33 fe ff ff	 jmp	 $L188357
$L188358:

; 1193 : 
; 1194 : 	if(memdc == NULL)

  02a2d	83 7d 08 00	 cmp	 DWORD PTR _memdc$[ebp], 0
  02a31	75 31		 jne	 SHORT $L188349

; 1195 : 	{
; 1196 : 		RestoreDC( dc, iSaveDC );

  02a33	8b f4		 mov	 esi, esp
  02a35	8b 55 f4	 mov	 edx, DWORD PTR _iSaveDC$[ebp]
  02a38	52		 push	 edx
  02a39	8b 45 f8	 mov	 eax, DWORD PTR _dc$[ebp]
  02a3c	50		 push	 eax
  02a3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RestoreDC@8
  02a43	3b f4		 cmp	 esi, esp
  02a45	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1197 : 		::ReleaseDC(m_hWnd, dc);

  02a4a	8b f4		 mov	 esi, esp
  02a4c	8b 4d f8	 mov	 ecx, DWORD PTR _dc$[ebp]
  02a4f	51		 push	 ecx
  02a50	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02a53	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02a56	50		 push	 eax
  02a57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  02a5d	3b f4		 cmp	 esi, esp
  02a5f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188349:

; 1198 : 	}
; 1199 : }

  02a64	52		 push	 edx
  02a65	8b cd		 mov	 ecx, ebp
  02a67	50		 push	 eax
  02a68	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189792
  02a6e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  02a73	58		 pop	 eax
  02a74	5a		 pop	 edx
  02a75	5f		 pop	 edi
  02a76	5e		 pop	 esi
  02a77	83 c4 3c	 add	 esp, 60			; 0000003cH
  02a7a	3b ec		 cmp	 ebp, esp
  02a7c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02a81	8b e5		 mov	 esp, ebp
  02a83	5d		 pop	 ebp
  02a84	c2 04 00	 ret	 4
$L189792:
  02a87	02 00 00 00	 DD	 2
  02a8b	00 00 00 00	 DD	 $L189791
$L189791:
  02a8f	dc ff ff ff	 DD	 -36			; ffffffdcH
  02a93	10 00 00 00	 DD	 16			; 00000010H
  02a97	00 00 00 00	 DD	 $L189789
  02a9b	cc ff ff ff	 DD	 -52			; ffffffccH
  02a9f	08 00 00 00	 DD	 8
  02aa3	00 00 00 00	 DD	 $L189790
$L189790:
  02aa7	70		 DB	 112			; 00000070H
  02aa8	00		 DB	 0
$L189789:
  02aa9	72		 DB	 114			; 00000072H
  02aaa	63		 DB	 99			; 00000063H
  02aab	00		 DB	 0
?OnPaint@CPictureEx@@QAEXPAUHDC__@@@Z ENDP		; CPictureEx::OnPaint
_TEXT	ENDS
EXTRN	__imp__GetSysColor@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_rect$ = -28						; size = 16
_hWinDC$ = -8						; size = 4
_this$ = -4						; size = 4
_nWidth$ = 8						; size = 4
_nHeight$ = 12						; size = 4
?PrepareDC@CPictureEx@@IAEHHH@Z PROC NEAR		; CPictureEx::PrepareDC
; _this$ = ecx

; 1202 : {

  02ab0	55		 push	 ebp
  02ab1	8b ec		 mov	 ebp, esp
  02ab3	83 ec 20	 sub	 esp, 32			; 00000020H
  02ab6	56		 push	 esi
  02ab7	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02abc	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  02abf	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  02ac2	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  02ac5	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  02ac8	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  02acb	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  02ace	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  02ad1	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  02ad4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1203 : //	SetWindowPos(NULL,0,0,nWidth,nHeight,SWP_NOMOVE | SWP_NOZORDER);
; 1204 : 
; 1205 : 	HDC hWinDC = ::GetDC(m_hWnd);

  02ad7	8b f4		 mov	 esi, esp
  02ad9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02adc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02adf	51		 push	 ecx
  02ae0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  02ae6	3b f4		 cmp	 esi, esp
  02ae8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02aed	89 45 f8	 mov	 DWORD PTR _hWinDC$[ebp], eax

; 1206 : 	if (!hWinDC) return FALSE;

  02af0	83 7d f8 00	 cmp	 DWORD PTR _hWinDC$[ebp], 0
  02af4	75 07		 jne	 SHORT $L188383
  02af6	33 c0		 xor	 eax, eax
  02af8	e9 3d 01 00 00	 jmp	 $L188381
$L188383:

; 1207 : 	
; 1208 : 	m_hMemDC = CreateCompatibleDC(hWinDC);

  02afd	8b f4		 mov	 esi, esp
  02aff	8b 55 f8	 mov	 edx, DWORD PTR _hWinDC$[ebp]
  02b02	52		 push	 edx
  02b03	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  02b09	3b f4		 cmp	 esi, esp
  02b0b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02b10	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b13	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1209 : 	if (!m_hMemDC) 

  02b16	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02b19	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  02b1d	75 21		 jne	 SHORT $L188384

; 1210 : 	{
; 1211 : 		::ReleaseDC(m_hWnd,hWinDC);

  02b1f	8b f4		 mov	 esi, esp
  02b21	8b 45 f8	 mov	 eax, DWORD PTR _hWinDC$[ebp]
  02b24	50		 push	 eax
  02b25	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b28	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  02b2b	52		 push	 edx
  02b2c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  02b32	3b f4		 cmp	 esi, esp
  02b34	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1212 : 		return FALSE;

  02b39	33 c0		 xor	 eax, eax
  02b3b	e9 fa 00 00 00	 jmp	 $L188381
$L188384:

; 1213 : 	};
; 1214 : 
; 1215 : 	m_hBitmap  = CreateCompatibleBitmap(hWinDC,nWidth,nHeight);

  02b40	8b f4		 mov	 esi, esp
  02b42	8b 45 0c	 mov	 eax, DWORD PTR _nHeight$[ebp]
  02b45	50		 push	 eax
  02b46	8b 4d 08	 mov	 ecx, DWORD PTR _nWidth$[ebp]
  02b49	51		 push	 ecx
  02b4a	8b 55 f8	 mov	 edx, DWORD PTR _hWinDC$[ebp]
  02b4d	52		 push	 edx
  02b4e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  02b54	3b f4		 cmp	 esi, esp
  02b56	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02b5b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b5e	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 1216 : 	if (!m_hBitmap) 

  02b61	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02b64	83 7a 60 00	 cmp	 DWORD PTR [edx+96], 0
  02b68	75 37		 jne	 SHORT $L188385

; 1217 : 	{
; 1218 : 		::ReleaseDC(m_hWnd,hWinDC);

  02b6a	8b f4		 mov	 esi, esp
  02b6c	8b 45 f8	 mov	 eax, DWORD PTR _hWinDC$[ebp]
  02b6f	50		 push	 eax
  02b70	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02b73	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  02b76	52		 push	 edx
  02b77	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  02b7d	3b f4		 cmp	 esi, esp
  02b7f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1219 : 		::DeleteDC(m_hMemDC);

  02b84	8b f4		 mov	 esi, esp
  02b86	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02b89	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  02b8c	51		 push	 ecx
  02b8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  02b93	3b f4		 cmp	 esi, esp
  02b95	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1220 : 		return FALSE;

  02b9a	33 c0		 xor	 eax, eax
  02b9c	e9 99 00 00 00	 jmp	 $L188381
$L188385:

; 1221 : 	};
; 1222 : 
; 1223 : 	m_hOldBitmap = reinterpret_cast<HBITMAP> 
; 1224 : 						(SelectObject(m_hMemDC,m_hBitmap));

  02ba1	8b f4		 mov	 esi, esp
  02ba3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02ba6	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  02ba9	50		 push	 eax
  02baa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02bad	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  02bb0	52		 push	 edx
  02bb1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  02bb7	3b f4		 cmp	 esi, esp
  02bb9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02bbe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02bc1	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 1225 : 	
; 1226 : 	// fill the background
; 1227 : 	m_clrBackground = GetSysColor(COLOR_3DFACE);

  02bc4	8b f4		 mov	 esi, esp
  02bc6	6a 0f		 push	 15			; 0000000fH
  02bc8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  02bce	3b f4		 cmp	 esi, esp
  02bd0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02bd5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02bd8	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 1228 : 	RECT rect = {0,0,nWidth,nHeight};

  02bdb	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _rect$[ebp], 0
  02be2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rect$[ebp+4], 0
  02be9	8b 45 08	 mov	 eax, DWORD PTR _nWidth$[ebp]
  02bec	89 45 ec	 mov	 DWORD PTR _rect$[ebp+8], eax
  02bef	8b 4d 0c	 mov	 ecx, DWORD PTR _nHeight$[ebp]
  02bf2	89 4d f0	 mov	 DWORD PTR _rect$[ebp+12], ecx

; 1229 : 	FillRect(m_hMemDC,&rect,(HBRUSH)(COLOR_WINDOW));

  02bf5	8b f4		 mov	 esi, esp
  02bf7	6a 05		 push	 5
  02bf9	8d 55 e4	 lea	 edx, DWORD PTR _rect$[ebp]
  02bfc	52		 push	 edx
  02bfd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02c00	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  02c03	51		 push	 ecx
  02c04	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12
  02c0a	3b f4		 cmp	 esi, esp
  02c0c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1230 : 
; 1231 : 	::ReleaseDC(m_hWnd,hWinDC);

  02c11	8b f4		 mov	 esi, esp
  02c13	8b 55 f8	 mov	 edx, DWORD PTR _hWinDC$[ebp]
  02c16	52		 push	 edx
  02c17	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02c1a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02c1d	51		 push	 ecx
  02c1e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  02c24	3b f4		 cmp	 esi, esp
  02c26	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1232 : 	m_bIsInitialized = TRUE;

  02c2b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  02c2e	c7 42 48 01 00
	00 00		 mov	 DWORD PTR [edx+72], 1

; 1233 : 	return TRUE;

  02c35	b8 01 00 00 00	 mov	 eax, 1
$L188381:

; 1234 : }

  02c3a	52		 push	 edx
  02c3b	8b cd		 mov	 ecx, ebp
  02c3d	50		 push	 eax
  02c3e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189796
  02c44	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  02c49	58		 pop	 eax
  02c4a	5a		 pop	 edx
  02c4b	5e		 pop	 esi
  02c4c	83 c4 20	 add	 esp, 32			; 00000020H
  02c4f	3b ec		 cmp	 ebp, esp
  02c51	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02c56	8b e5		 mov	 esp, ebp
  02c58	5d		 pop	 ebp
  02c59	c2 08 00	 ret	 8
$L189796:
  02c5c	01 00 00 00	 DD	 1
  02c60	00 00 00 00	 DD	 $L189795
$L189795:
  02c64	e4 ff ff ff	 DD	 -28			; ffffffe4H
  02c68	10 00 00 00	 DD	 16			; 00000010H
  02c6c	00 00 00 00	 DD	 $L189794
$L189794:
  02c70	72		 DB	 114			; 00000072H
  02c71	65		 DB	 101			; 00000065H
  02c72	63		 DB	 99			; 00000063H
  02c73	74		 DB	 116			; 00000074H
  02c74	00		 DB	 0
?PrepareDC@CPictureEx@@IAEHHH@Z ENDP			; CPictureEx::PrepareDC
_TEXT	ENDS
PUBLIC	?SetBkColor@CPictureEx@@QAEXK@Z			; CPictureEx::SetBkColor
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_rect$188396 = -28					; size = 16
_hBrush$ = -8						; size = 4
_this$ = -4						; size = 4
_clr$ = 8						; size = 4
?SetBkColor@CPictureEx@@QAEXK@Z PROC NEAR		; CPictureEx::SetBkColor
; _this$ = ecx

; 1243 : {

  02c80	55		 push	 ebp
  02c81	8b ec		 mov	 ebp, esp
  02c83	83 ec 20	 sub	 esp, 32			; 00000020H
  02c86	56		 push	 esi
  02c87	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02c8c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  02c8f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  02c92	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  02c95	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  02c98	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  02c9b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  02c9e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  02ca1	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  02ca4	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1244 : 	if (!m_bIsInitialized) return;

  02ca7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02caa	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  02cae	75 02		 jne	 SHORT $L188393
  02cb0	eb 76		 jmp	 SHORT $L188392
$L188393:

; 1245 : 
; 1246 : 	m_clrBackground = clr;

  02cb2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02cb5	8b 55 08	 mov	 edx, DWORD PTR _clr$[ebp]
  02cb8	89 51 28	 mov	 DWORD PTR [ecx+40], edx

; 1247 : 
; 1248 : 	HBRUSH hBrush = CreateSolidBrush(clr);

  02cbb	8b f4		 mov	 esi, esp
  02cbd	8b 45 08	 mov	 eax, DWORD PTR _clr$[ebp]
  02cc0	50		 push	 eax
  02cc1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSolidBrush@4
  02cc7	3b f4		 cmp	 esi, esp
  02cc9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02cce	89 45 f8	 mov	 DWORD PTR _hBrush$[ebp], eax

; 1249 : 	if (hBrush)

  02cd1	83 7d f8 00	 cmp	 DWORD PTR _hBrush$[ebp], 0
  02cd5	74 51		 je	 SHORT $L188392

; 1250 : 	{
; 1251 : 		RECT rect = {0,0,m_PictureSize.cx,m_PictureSize.cy};

  02cd7	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _rect$188396[ebp], 0
  02cde	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rect$188396[ebp+4], 0
  02ce5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02ce8	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  02ceb	89 55 ec	 mov	 DWORD PTR _rect$188396[ebp+8], edx
  02cee	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02cf1	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  02cf4	89 4d f0	 mov	 DWORD PTR _rect$188396[ebp+12], ecx

; 1252 : 		FillRect(m_hMemDC,&rect,hBrush);

  02cf7	8b f4		 mov	 esi, esp
  02cf9	8b 55 f8	 mov	 edx, DWORD PTR _hBrush$[ebp]
  02cfc	52		 push	 edx
  02cfd	8d 45 e4	 lea	 eax, DWORD PTR _rect$188396[ebp]
  02d00	50		 push	 eax
  02d01	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02d04	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  02d07	52		 push	 edx
  02d08	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12
  02d0e	3b f4		 cmp	 esi, esp
  02d10	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1253 : 		DeleteObject(hBrush);

  02d15	8b f4		 mov	 esi, esp
  02d17	8b 45 f8	 mov	 eax, DWORD PTR _hBrush$[ebp]
  02d1a	50		 push	 eax
  02d1b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  02d21	3b f4		 cmp	 esi, esp
  02d23	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L188392:

; 1254 : 	};
; 1255 : }

  02d28	52		 push	 edx
  02d29	8b cd		 mov	 ecx, ebp
  02d2b	50		 push	 eax
  02d2c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189800
  02d32	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  02d37	58		 pop	 eax
  02d38	5a		 pop	 edx
  02d39	5e		 pop	 esi
  02d3a	83 c4 20	 add	 esp, 32			; 00000020H
  02d3d	3b ec		 cmp	 ebp, esp
  02d3f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02d44	8b e5		 mov	 esp, ebp
  02d46	5d		 pop	 ebp
  02d47	c2 04 00	 ret	 4
$L189800:
  02d4a	01 00 00 00	 DD	 1
  02d4e	00 00 00 00	 DD	 $L189799
$L189799:
  02d52	e4 ff ff ff	 DD	 -28			; ffffffe4H
  02d56	10 00 00 00	 DD	 16			; 00000010H
  02d5a	00 00 00 00	 DD	 $L189798
$L189798:
  02d5e	72		 DB	 114			; 00000072H
  02d5f	65		 DB	 101			; 00000065H
  02d60	63		 DB	 99			; 00000063H
  02d61	74		 DB	 116			; 00000074H
  02d62	00		 DB	 0
?SetBkColor@CPictureEx@@QAEXK@Z ENDP			; CPictureEx::SetBkColor
_TEXT	ENDS
PUBLIC	?SetPaintRect@CPictureEx@@QAEHPBUtagRECT@@@Z	; CPictureEx::SetPaintRect
EXTRN	__imp__CopyRect@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?SetPaintRect@CPictureEx@@QAEHPBUtagRECT@@@Z PROC NEAR	; CPictureEx::SetPaintRect
; _this$ = ecx

; 1356 : {

  02d70	55		 push	 ebp
  02d71	8b ec		 mov	 ebp, esp
  02d73	51		 push	 ecx
  02d74	56		 push	 esi
  02d75	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  02d7c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1357 : 	return CopyRect(&m_PaintRect, lpRect);

  02d7f	8b f4		 mov	 esi, esp
  02d81	8b 45 08	 mov	 eax, DWORD PTR _lpRect$[ebp]
  02d84	50		 push	 eax
  02d85	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  02d88	83 c1 10	 add	 ecx, 16			; 00000010H
  02d8b	51		 push	 ecx
  02d8c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyRect@8
  02d92	3b f4		 cmp	 esi, esp
  02d94	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1358 : }

  02d99	5e		 pop	 esi
  02d9a	83 c4 04	 add	 esp, 4
  02d9d	3b ec		 cmp	 ebp, esp
  02d9f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02da4	8b e5		 mov	 esp, ebp
  02da6	5d		 pop	 ebp
  02da7	c2 04 00	 ret	 4
?SetPaintRect@CPictureEx@@QAEHPBUtagRECT@@@Z ENDP	; CPictureEx::SetPaintRect
_TEXT	ENDS
PUBLIC	?GetPaintRect@CPictureEx@@QAEHPAUtagRECT@@@Z	; CPictureEx::GetPaintRect
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpRect$ = 8						; size = 4
?GetPaintRect@CPictureEx@@QAEHPAUtagRECT@@@Z PROC NEAR	; CPictureEx::GetPaintRect
; _this$ = ecx

; 1361 : {

  02db0	55		 push	 ebp
  02db1	8b ec		 mov	 ebp, esp
  02db3	51		 push	 ecx
  02db4	56		 push	 esi
  02db5	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  02dbc	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1362 : 	return CopyRect(lpRect, &m_PaintRect);

  02dbf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  02dc2	83 c0 10	 add	 eax, 16			; 00000010H
  02dc5	8b f4		 mov	 esi, esp
  02dc7	50		 push	 eax
  02dc8	8b 4d 08	 mov	 ecx, DWORD PTR _lpRect$[ebp]
  02dcb	51		 push	 ecx
  02dcc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyRect@8
  02dd2	3b f4		 cmp	 esi, esp
  02dd4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1363 : }

  02dd9	5e		 pop	 esi
  02dda	83 c4 04	 add	 esp, 4
  02ddd	3b ec		 cmp	 ebp, esp
  02ddf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02de4	8b e5		 mov	 esp, ebp
  02de6	5d		 pop	 ebp
  02de7	c2 04 00	 ret	 4
?GetPaintRect@CPictureEx@@QAEHPAUtagRECT@@@Z ENDP	; CPictureEx::GetPaintRect
_TEXT	ENDS
PUBLIC	??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ	; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
PUBLIC	?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Buy
PUBLIC	??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z ; std::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	51		 push	 ecx
  00018	8b cc		 mov	 ecx, esp
  0001a	e8 00 00 00 00	 call	 ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z ; std::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >

; 300  : 		_Buy(0);

  00027	6a 00		 push	 0
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Buy

; 301  : 		}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c4 08	 add	 esp, 8
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy

; 389  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::~vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00014	51		 push	 ecx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00018	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00014	51		 push	 ecx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00018	e8 00 00 00 00	 call	 ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001e	75 09		 jne	 SHORT $L189809
  00020	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00027	eb 17		 jmp	 SHORT $L189810
$L189809:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00032	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00035	99		 cdq
  00036	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0003b	f7 f9		 idiv	 ecx
  0003d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L189810:
  00040	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::empty, COMDAT
; _this$ = ecx

; 525  : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 526  : 		return (size() == 0);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00016	f7 d8		 neg	 eax
  00018	1b c0		 sbb	 eax, eax
  0001a	40		 inc	 eax

; 527  : 		}

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?empty@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::empty
_TEXT	ENDS
PUBLIC	??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+
; Function compile flags: /Odt /RTCsu
;	COMDAT ??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT
$T189814 = -12						; size = 4
$T189813 = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00021	50		 push	 eax
  00022	8d 4d f4	 lea	 ecx, DWORD PTR $T189814[ebp]
  00025	51		 push	 ecx
  00026	8d 55 f8	 lea	 edx, DWORD PTR $T189813[ebp]
  00029	52		 push	 edx
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 ??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*

; 556  : 		}

  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
??A?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAUTFrame@CPictureEx@@I@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::operator[]
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity
PUBLIC	?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::insert
PUBLIC	?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
; Function compile flags: /Odt /RTCsu
;	COMDAT ?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
$T189817 = -12						; size = 4
$T189816 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00027	8b f0		 mov	 esi, eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity
  00031	3b f0		 cmp	 esi, eax
  00033	73 1d		 jae	 SHORT $L188489

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00035	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00041	52		 push	 edx
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  00050	eb 1f		 jmp	 SHORT $L188488
$L188489:

; 583  : 			insert(end(), _Val);

  00052	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00055	52		 push	 edx
  00056	8d 45 f8	 lea	 eax, DWORD PTR $T189816[ebp]
  00059	50		 push	 eax
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?end@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::end
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	51		 push	 ecx
  00065	8d 55 f4	 lea	 edx, DWORD PTR $T189817[ebp]
  00068	52		 push	 edx
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::insert
$L188488:

; 584  : 		}

  00071	5e		 pop	 esi
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
?push_back@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXABUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::push_back
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy

; 745  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?clear@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::clear
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator, COMDAT
; _this$ = ecx

; 209  : 		iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator

; 210  : 			{	// construct with null vector pointer
; 211  : 			}

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator*

; 221  : 			}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??Diterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEAAUTFrame@CPictureEx@@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 236  : 			iterator _Tmp = *this;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 4d f4	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 237  : 			++*this;

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++

; 238  : 			return (_Tmp);

  0002a	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Tmp$[ebp]
  00030	89 02		 mov	 DWORD PTR [edx], eax
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 239  : 			}

  00035	52		 push	 edx
  00036	8b cd		 mov	 ecx, ebp
  00038	50		 push	 eax
  00039	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189824
  0003f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00044	58		 pop	 eax
  00045	5a		 pop	 edx
  00046	83 c4 10	 add	 esp, 16			; 00000010H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$L189824:
  00056	01 00 00 00	 DD	 1
  0005a	00 00 00 00	 DD	 $L189823
$L189823:
  0005e	f4 ff ff ff	 DD	 -12			; fffffff4H
  00062	04 00 00 00	 DD	 4
  00066	00 00 00 00	 DD	 $L189822
$L189822:
  0006a	5f		 DB	 95			; 0000005fH
  0006b	54		 DB	 84			; 00000054H
  0006c	6d		 DB	 109			; 0000006dH
  0006d	70		 DB	 112			; 00000070H
  0006e	00		 DB	 0
??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator<, COMDAT
; _this$ = ecx

; 164  : 			{	// test if this < _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 165  : 
; 166  : 
; 167  : 			return (_Myptr < _Right._Myptr);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00014	8b 10		 mov	 edx, DWORD PTR [eax]
  00016	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00018	1b c0		 sbb	 eax, eax
  0001a	f7 d8		 neg	 eax

; 168  : 			}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??Mconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator<
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001e	75 09		 jne	 SHORT $L189827
  00020	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00027	eb 17		 jmp	 SHORT $L189828
$L189827:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00032	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00035	99		 cdq
  00036	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0003b	f7 f9		 idiv	 ecx
  0003d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
$L189828:
  00040	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Insert_n
PUBLIC	??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator-
; Function compile flags: /Odt /RTCsu
;	COMDAT ?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
$T189833 = -16						; size = 4
$T189830 = -12						; size = 4
__Off$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00025	85 c0		 test	 eax, eax
  00027	75 09		 jne	 SHORT $L189831
  00029	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00030	eb 18		 jmp	 SHORT $L189832
$L189831:
  00032	8d 45 f4	 lea	 eax, DWORD PTR $T189830[ebp]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
  0003e	50		 push	 eax
  0003f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00042	e8 00 00 00 00	 call	 ??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator-
  00047	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$L189832:
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  0004d	89 4d f8	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  00050	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  00053	52		 push	 edx
  00054	6a 01		 push	 1
  00056	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00062	8b 4d f8	 mov	 ecx, DWORD PTR __Off$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00069	52		 push	 edx
  0006a	8d 45 f0	 lea	 eax, DWORD PTR $T189833[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?begin@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::begin
  00076	8b c8		 mov	 ecx, eax
  00078	e8 00 00 00 00	 call	 ??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+
  0007d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE?AViterator@12@V312@ABUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::allocate
PUBLIC	?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
PUBLIC	?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00022	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00025	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  0002c	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  00030	75 04		 jne	 SHORT $L188529

; 773  : 			return (false);

  00032	32 c0		 xor	 al, al
  00034	eb 49		 jmp	 SHORT $L188528
$L188529:

; 774  : 		else if (max_size() < _Capacity)

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
  0003e	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  00041	73 0a		 jae	 SHORT $L188531

; 775  : 			_Xlen();	// result too long

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen

; 776  : 		else

  0004b	eb 30		 jmp	 SHORT $L188530
$L188531:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::allocate
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

  0006b	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0006e	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$L188530:

; 781  : 			}
; 782  : 		return (true);

  0007d	b0 01		 mov	 al, 1
$L188528:

; 783  : 		}

  0007f	83 c4 04	 add	 esp, 4
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?_Buy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::deallocate
PUBLIC	?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00015	74 3c		 je	 SHORT $L188535

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	52		 push	 edx
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00024	51		 push	 ecx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00036	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00039	8b c1		 mov	 eax, ecx
  0003b	99		 cdq
  0003c	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00041	f7 f9		 idiv	 ecx
  00043	50		 push	 eax
  00044	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00047	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004a	50		 push	 eax
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::deallocate
$L188535:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0005d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00060	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 798  : 		}

  00071	83 c4 04	 add	 esp, 4
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?_Tidy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Uninitialized_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Uninitialized_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00029	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0002c	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]

; 880  : 		}

  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z PROC NEAR ; std::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>

; 22   : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Vector_val@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAE@V?$allocator@UTFrame@CPictureEx@@@1@@Z ENDP ; std::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Vector_val<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ PROC NEAR ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@XZ ENDP	; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator

; 216  : 			}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++, COMDAT
; _this$ = ecx

; 229  : 			{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 			++this->_Myptr;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	89 0a		 mov	 DWORD PTR [edx], ecx

; 231  : 			return (*this);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 232  : 			}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??Eiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+=
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	89 4d f4	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00022	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00025	52		 push	 edx
  00026	8d 4d f4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00029	e8 00 00 00 00	 call	 ??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+=
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax
  00035	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  00038	52		 push	 edx
  00039	8b cd		 mov	 ecx, ebp
  0003b	50		 push	 eax
  0003c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189844
  00042	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00047	58		 pop	 eax
  00048	5a		 pop	 edx
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
$L189844:
  00059	01 00 00 00	 DD	 1
  0005d	00 00 00 00	 DD	 $L189843
$L189843:
  00061	f4 ff ff ff	 DD	 -12			; fffffff4H
  00065	04 00 00 00	 DD	 4
  00069	00 00 00 00	 DD	 $L189842
$L189842:
  0006d	5f		 DB	 95			; 0000005fH
  0006e	54		 DB	 84			; 00000054H
  0006f	6d		 DB	 109			; 0000006dH
  00070	70		 DB	 112			; 00000070H
  00071	00		 DB	 0
??Hiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 68   : 		const_iterator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : 			{	// construct with null pointer
; 70   : 			_Myptr = 0;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 71   : 			}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??Dconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEABUTFrame@CPictureEx@@XZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ ; std::allocator<CPictureEx::TFrame>::max_size
; Function compile flags: /Odt /RTCsu
;	COMDAT ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ ; std::allocator<CPictureEx::TFrame>::max_size

; 522  : 		}

  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
PUBLIC	??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>
PUBLIC	??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z ; std::copy_backward<CPictureEx::TFrame *,CPictureEx::TFrame *>
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T189863 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T189865 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L189854
$T189866 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L189856
$T189864 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T189865
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T189866
$T189858 DD	019930520H
	DD	04H
	DD	FLAT:$T189863
	DD	02H
	DD	FLAT:$T189864
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
tv241 = -84						; size = 4
tv240 = -80						; size = 4
tv86 = -76						; size = 4
__Oldend$188646 = -72					; size = 4
__Ptr$188626 = -68					; size = 4
__Newvec$188625 = -64					; size = 4
__Capacity$ = -60					; size = 4
__Tmp$ = -52						; size = 28
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 44	 sub	 esp, 68			; 00000044H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	51		 push	 ecx
  00020	8d 7d ac	 lea	 edi, DWORD PTR [ebp-84]
  00023	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  00028	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002d	f3 ab		 rep stosd
  0002f	59		 pop	 ecx
  00030	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00033	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00036	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
  00039	b9 07 00 00 00	 mov	 ecx, 7
  0003e	8d 7d cc	 lea	 edi, DWORD PTR __Tmp$[ebp]
  00041	f3 a5		 rep movsd

; 811  : 		size_type _Capacity = capacity();

  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?capacity@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::capacity
  0004b	89 45 c4	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  0004e	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00052	75 05		 jne	 SHORT $L188619

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  00054	e9 d7 02 00 00	 jmp	 $L189849
$L188619:
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00061	8b f0		 mov	 esi, eax
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
  0006b	2b c6		 sub	 eax, esi
  0006d	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  00070	73 0d		 jae	 SHORT $L188621

; 816  : 			_Xlen();	// result too long

  00072	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  0007a	e9 b1 02 00 00	 jmp	 $L189849
$L188621:
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00087	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0008a	39 45 c4	 cmp	 DWORD PTR __Capacity$[ebp], eax
  0008d	0f 83 6d 01 00
	00		 jae	 $L188623

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00093	8b 75 c4	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00096	d1 ee		 shr	 esi, 1
  00098	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?max_size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::max_size
  000a0	2b c6		 sub	 eax, esi
  000a2	3b 45 c4	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  000a5	73 09		 jae	 SHORT $L189850
  000a7	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  000ae	eb 0b		 jmp	 SHORT $L189851
$L189850:
  000b0	8b 45 c4	 mov	 eax, DWORD PTR __Capacity$[ebp]
  000b3	d1 e8		 shr	 eax, 1
  000b5	03 45 c4	 add	 eax, DWORD PTR __Capacity$[ebp]
  000b8	89 45 b4	 mov	 DWORD PTR tv86[ebp], eax
$L189851:
  000bb	8b 4d b4	 mov	 ecx, DWORD PTR tv86[ebp]
  000be	89 4d c4	 mov	 DWORD PTR __Capacity$[ebp], ecx

; 821  : 			if (_Capacity < size() + _Count)

  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  000c9	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000cc	39 45 c4	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000cf	73 0e		 jae	 SHORT $L188624

; 822  : 				_Capacity = size() + _Count;

  000d1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  000d9	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000dc	89 45 c4	 mov	 DWORD PTR __Capacity$[ebp], eax
$L188624:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000df	8b 55 c4	 mov	 edx, DWORD PTR __Capacity$[ebp]
  000e2	52		 push	 edx
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::allocate
  000eb	89 45 c0	 mov	 DWORD PTR __Newvec$188625[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000ee	8b 45 c0	 mov	 eax, DWORD PTR __Newvec$188625[ebp]
  000f1	89 45 bc	 mov	 DWORD PTR __Ptr$188626[ebp], eax

; 825  : 
; 826  : 			_TRY_BEGIN

  000f4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000fb	8b 4d c0	 mov	 ecx, DWORD PTR __Newvec$188625[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00102	52		 push	 edx
  00103	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00106	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00109	51		 push	 ecx
  0010a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
  00112	89 45 b0	 mov	 DWORD PTR tv240[ebp], eax
  00115	8b 55 b0	 mov	 edx, DWORD PTR tv240[ebp]
  00118	89 55 bc	 mov	 DWORD PTR __Ptr$188626[ebp], edx

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  0011b	8d 45 cc	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0011e	50		 push	 eax
  0011f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00122	51		 push	 ecx
  00123	8b 55 bc	 mov	 edx, DWORD PTR __Ptr$188626[ebp]
  00126	52		 push	 edx
  00127	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
  0012f	89 45 ac	 mov	 DWORD PTR tv241[ebp], eax
  00132	8b 45 ac	 mov	 eax, DWORD PTR tv241[ebp]
  00135	89 45 bc	 mov	 DWORD PTR __Ptr$188626[ebp], eax

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00138	8b 4d bc	 mov	 ecx, DWORD PTR __Ptr$188626[ebp]
  0013b	51		 push	 ecx
  0013c	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0013f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00142	50		 push	 eax
  00143	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00146	51		 push	 ecx
  00147	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
  0014f	eb 29		 jmp	 SHORT $L189853
$L189854:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  00151	8b 55 bc	 mov	 edx, DWORD PTR __Ptr$188626[ebp]
  00154	52		 push	 edx
  00155	8b 45 c0	 mov	 eax, DWORD PTR __Newvec$188625[ebp]
  00158	50		 push	 eax
  00159	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00161	8b 4d c4	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00164	51		 push	 ecx
  00165	8b 55 c0	 mov	 edx, DWORD PTR __Newvec$188625[ebp]
  00168	52		 push	 edx
  00169	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::deallocate

; 834  : 			_RERAISE;

  00171	6a 00		 push	 0
  00173	6a 00		 push	 0
  00175	e8 00 00 00 00	 call	 __CxxThrowException@8
$L189853:

; 835  : 			_CATCH_END

  0017a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 836  : 
; 837  : 			_Count += size();

  00181	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00184	e8 00 00 00 00	 call	 ?size@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEIXZ ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::size
  00189	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0018c	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  0018f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00192	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00196	74 3c		 je	 SHORT $L188633

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00198	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0019b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0019e	52		 push	 edx
  0019f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001a2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a5	51		 push	 ecx
  001a6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a9	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  001ae	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001b1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  001b7	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  001ba	8b c1		 mov	 eax, ecx
  001bc	99		 cdq
  001bd	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  001c2	f7 f9		 idiv	 ecx
  001c4	50		 push	 eax
  001c5	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001c8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001cb	50		 push	 eax
  001cc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001cf	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ; std::allocator<CPictureEx::TFrame>::deallocate
$L188633:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001d4	8b 4d c4	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  001d7	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  001da	03 4d c0	 add	 ecx, DWORD PTR __Newvec$188625[ebp]
  001dd	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001e0	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 844  : 			_Mylast = _Newvec + _Count;

  001e3	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001e6	6b c0 1c	 imul	 eax, 28			; 0000001cH
  001e9	03 45 c0	 add	 eax, DWORD PTR __Newvec$188625[ebp]
  001ec	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

  001f2	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001f5	8b 45 c0	 mov	 eax, DWORD PTR __Newvec$188625[ebp]
  001f8	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001fb	e9 30 01 00 00	 jmp	 $L189849
$L188623:
  00200	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00203	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00206	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  00209	99		 cdq
  0020a	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0020f	f7 f9		 idiv	 ecx
  00211	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  00214	0f 83 b2 00 00
	00		 jae	 $L188636

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  0021a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0021d	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00220	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00223	52		 push	 edx
  00224	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00227	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0022a	51		 push	 ecx
  0022b	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  0022e	52		 push	 edx
  0022f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00232	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00237	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0023e	8d 45 cc	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00241	50		 push	 eax
  00242	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00245	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00248	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  0024b	99		 cdq
  0024c	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00251	f7 f9		 idiv	 ecx
  00253	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00256	2b d0		 sub	 edx, eax
  00258	52		 push	 edx
  00259	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0025c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0025f	51		 push	 ecx
  00260	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00263	e8 00 00 00 00	 call	 ?_Ufill@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU34@IABU34@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ufill
  00268	eb 28		 jmp	 SHORT $L189855
$L189856:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  0026a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0026d	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00270	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00273	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00276	52		 push	 edx
  00277	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0027a	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  0027d	03 4d 08	 add	 ecx, DWORD PTR __Where$[ebp]
  00280	51		 push	 ecx
  00281	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00284	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXPAUTFrame@CPictureEx@@0@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Destroy

; 857  : 			_RERAISE;

  00289	6a 00		 push	 0
  0028b	6a 00		 push	 0
  0028d	e8 00 00 00 00	 call	 __CxxThrowException@8
$L189855:

; 858  : 			_CATCH_END

  00292	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 859  : 
; 860  : 			_Mylast += _Count;

  00299	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0029c	6b d2 1c	 imul	 edx, 28			; 0000001cH
  0029f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002a2	03 50 08	 add	 edx, DWORD PTR [eax+8]
  002a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002a8	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  002ab	8d 55 cc	 lea	 edx, DWORD PTR __Tmp$[ebp]
  002ae	52		 push	 edx
  002af	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002b2	6b c0 1c	 imul	 eax, 28			; 0000001cH
  002b5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002b8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002bb	2b d0		 sub	 edx, eax
  002bd	52		 push	 edx
  002be	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002c1	50		 push	 eax
  002c2	e8 00 00 00 00	 call	 ??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>
  002c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002ca	eb 64		 jmp	 SHORT $L189849
$L188636:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002cc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002cf	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  002d2	89 55 b8	 mov	 DWORD PTR __Oldend$188646[ebp], edx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002d5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002d8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002db	51		 push	 ecx
  002dc	8b 55 b8	 mov	 edx, DWORD PTR __Oldend$188646[ebp]
  002df	52		 push	 edx
  002e0	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002e3	6b c0 1c	 imul	 eax, 28			; 0000001cH
  002e6	8b 4d b8	 mov	 ecx, DWORD PTR __Oldend$188646[ebp]
  002e9	2b c8		 sub	 ecx, eax
  002eb	51		 push	 ecx
  002ec	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002ef	e8 00 00 00 00	 call	 ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
  002f4	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002f7	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002fa	8b 45 b8	 mov	 eax, DWORD PTR __Oldend$188646[ebp]
  002fd	50		 push	 eax
  002fe	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00301	6b c9 1c	 imul	 ecx, 28			; 0000001cH
  00304	8b 55 b8	 mov	 edx, DWORD PTR __Oldend$188646[ebp]
  00307	2b d1		 sub	 edx, ecx
  00309	52		 push	 edx
  0030a	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 ??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z ; std::copy_backward<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00313	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  00316	8d 4d cc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00319	51		 push	 ecx
  0031a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0031d	6b d2 1c	 imul	 edx, 28			; 0000001cH
  00320	03 55 08	 add	 edx, DWORD PTR __Where$[ebp]
  00323	52		 push	 edx
  00324	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L189849:

; 873  : 			}
; 874  : 		}

  00330	52		 push	 edx
  00331	8b cd		 mov	 ecx, ebp
  00333	50		 push	 eax
  00334	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189862
  0033a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0033f	58		 pop	 eax
  00340	5a		 pop	 edx
  00341	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00344	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0034b	5f		 pop	 edi
  0034c	5e		 pop	 esi
  0034d	5b		 pop	 ebx
  0034e	83 c4 54	 add	 esp, 84			; 00000054H
  00351	3b ec		 cmp	 ebp, esp
  00353	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00358	8b e5		 mov	 esp, ebp
  0035a	5d		 pop	 ebp
  0035b	c2 0c 00	 ret	 12			; 0000000cH
$L189862:
  0035e	01 00 00 00	 DD	 1
  00362	00 00 00 00	 DD	 $L189861
$L189861:
  00366	cc ff ff ff	 DD	 -52			; ffffffccH
  0036a	1c 00 00 00	 DD	 28			; 0000001cH
  0036e	00 00 00 00	 DD	 $L189859
$L189859:
  00372	5f		 DB	 95			; 0000005fH
  00373	54		 DB	 84			; 00000054H
  00374	6d		 DB	 109			; 0000006dH
  00375	70		 DB	 112			; 00000070H
  00376	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T189858
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEXViterator@12@IABUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Insert_n
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
$T189876 DD	0ffffffffH
	DD	FLAT:$L189872
$T189874 DD	019930520H
	DD	01H
	DD	FLAT:$T189876
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
	ORG $-31
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
	ORG $-30
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
	ORG $-24
	DD	FLAT:??_7type_info@@6B@
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T189871 = -84						; size = 28
$T189870 = -56						; size = 40
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 48	 sub	 esp, 72			; 00000048H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	51		 push	 ecx
  0001e	8d 7d ac	 lea	 edi, DWORD PTR [ebp-84]
  00021	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  00031	8b f4		 mov	 esi, esp
  00033	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00038	8d 4d ac	 lea	 ecx, DWORD PTR $T189871[ebp]
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	8d 45 ac	 lea	 eax, DWORD PTR $T189871[ebp]
  00052	50		 push	 eax
  00053	8d 4d c8	 lea	 ecx, DWORD PTR $T189870[ebp]
  00056	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  00060	8d 4d c8	 lea	 ecx, DWORD PTR $T189870[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$L189869:

; 885  : 		}

  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	83 c4 54	 add	 esp, 84			; 00000054H
  00078	3b ec		 cmp	 ebp, esp
  0007a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L189872:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d ac	 lea	 ecx, DWORD PTR $T189871[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T189874
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IBEXXZ ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Xlen
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??0?$allocator@UTFrame@CPictureEx@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CPictureEx::TFrame>::allocator<CPictureEx::TFrame>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4

; 133  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@I@Z ENDP ; std::allocator<CPictureEx::TFrame>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z ; std::_Allocate<CPictureEx::TFrame>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  0000e	6a 00		 push	 0
  00010	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z ; std::_Allocate<CPictureEx::TFrame>
  00019	83 c4 08	 add	 esp, 8

; 138  : 		}

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@UTFrame@CPictureEx@@@std@@QAEPAUTFrame@CPictureEx@@I@Z ENDP ; std::allocator<CPictureEx::TFrame>::allocate
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00011	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	03 01		 add	 eax, DWORD PTR [ecx]
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	89 02		 mov	 DWORD PTR [edx], eax

; 257  : 			return (*this);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??Yiterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator-
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
$T189884 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 4d f8	 mov	 DWORD PTR $T189884[ebp], ecx
  0001f	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00022	52		 push	 edx
  00023	8d 4d f8	 lea	 ecx, DWORD PTR $T189884[ebp]
  00026	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator-

; 280  : 			}

  0002b	83 c4 08	 add	 esp, 8
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??Giterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::iterator::operator-
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??0const_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QAE@PAUTFrame@CPictureEx@@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt /RTCsu
rdata$r	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ PROC NEAR ; std::allocator<CPictureEx::TFrame>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0001e	c7 45 f8 49 92
	24 09		 mov	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H

; 158  : 		return (0 < _Count ? _Count : 1);

  00025	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00029	76 08		 jbe	 SHORT $L189889
  0002b	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00031	eb 07		 jmp	 SHORT $L189890
$L189889:
  00033	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L189890:
  0003a	8b 45 f4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$allocator@UTFrame@CPictureEx@@@std@@QBEIXZ ENDP ; std::allocator<CPictureEx::TFrame>::max_size
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	2b 01		 sub	 eax, DWORD PTR [ecx]
  00018	99		 cdq
  00019	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0001e	f7 f9		 idiv	 ecx

; 144  : 			}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z ; CArray<CRect,CRect>::Serialize
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?Dump@?$CArray@VCRect@@V1@@@UBEXAAVCDumpContext@@@Z ; CArray<CRect,CRect>::Dump
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	?AssertValid@?$CArray@VCRect@@V1@@@UBEXXZ	; CArray<CRect,CRect>::AssertValid
PUBLIC	??_7?$CArray@VCRect@@V1@@@6B@			; CArray<CRect,CRect>::`vftable'
PUBLIC	??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z		; CArray<CRect,CRect>::`scalar deleting destructor'
PUBLIC	??_R4?$CArray@VCRect@@V1@@@6B@			; CArray<CRect,CRect>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CArray@VCRect@@V1@@@@8		; CArray<CRect,CRect> `RTTI Type Descriptor'
PUBLIC	??_R3?$CArray@VCRect@@V1@@@8			; CArray<CRect,CRect>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CArray@VCRect@@V1@@@8			; CArray<CRect,CRect>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8		; CArray<CRect,CRect>::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	??_E?$CArray@VCRect@@V1@@@UAEPAXI@Z:NEAR	; CArray<CRect,CRect>::`vector deleting destructor'
EXTRN	?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ:NEAR ; CObject::GetRuntimeClass
EXTRN	??0CObject@@IAE@XZ:NEAR				; CObject::CObject
;	COMDAT ??_7?$CArray@VCRect@@V1@@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
CONST	SEGMENT
??_7?$CArray@VCRect@@V1@@@6B@ DD FLAT:??_R4?$CArray@VCRect@@V1@@@6B@ ; CArray<CRect,CRect>::`vftable'
	DD	FLAT:?GetRuntimeClass@CObject@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_E?$CArray@VCRect@@V1@@@UAEPAXI@Z
	DD	FLAT:?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@?$CArray@VCRect@@V1@@@UBEXXZ
	DD	FLAT:?Dump@?$CArray@VCRect@@V1@@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4?$CArray@VCRect@@V1@@@6B@
rdata$r	SEGMENT
??_R4?$CArray@VCRect@@V1@@@6B@ DD 00H			; CArray<CRect,CRect>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CArray@VCRect@@V1@@@@8
	DD	FLAT:??_R3?$CArray@VCRect@@V1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CArray@VCRect@@V1@@@@8
_DATA	SEGMENT
??_R0?AV?$CArray@VCRect@@V1@@@@8 DD FLAT:??_7type_info@@6B@ ; CArray<CRect,CRect> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CArray@VCRect@@V1@@@', 00H
_DATA	ENDS
;	COMDAT ??_R3?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT
??_R3?$CArray@VCRect@@V1@@@8 DD 00H			; CArray<CRect,CRect>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$CArray@VCRect@@V1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT
??_R2?$CArray@VCRect@@V1@@@8 DD FLAT:??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8 ; CArray<CRect,CRect>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8
rdata$r	SEGMENT
??_R1A@?0A@A@?$CArray@VCRect@@V1@@@8 DD FLAT:??_R0?AV?$CArray@VCRect@@V1@@@@8 ; CArray<CRect,CRect>::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ??0?$CArray@VCRect@@V1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CArray@VCRect@@V1@@@QAE@XZ PROC NEAR		; CArray<CRect,CRect>::CArray<CRect,CRect>, COMDAT
; _this$ = ecx

; 349  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0CObject@@IAE@XZ	; CObject::CObject
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@VCRect@@V1@@@6B@

; 350  : 	m_pData = NULL;

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 351  : 	m_nSize = m_nMaxSize = m_nGrowBy = 0;

  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 352  : }

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 c4 04	 add	 esp, 4
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??0?$CArray@VCRect@@V1@@@QAE@XZ ENDP			; CArray<CRect,CRect>::CArray<CRect,CRect>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ PROC NEAR		; CArray<CRect,CRect>::GetSize, COMDAT
; _this$ = ecx

; 272  : 	{ return m_nSize; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetSize@?$CArray@VCRect@@V1@@@QBEHXZ ENDP		; CArray<CRect,CRect>::GetSize
_TEXT	ENDS
PUBLIC	?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z		; CArray<CRect,CRect>::SetSize
; Function compile flags: /Odt /RTCsu
;	COMDAT ?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ PROC NEAR	; CArray<CRect,CRect>::RemoveAll, COMDAT
; _this$ = ecx

; 284  : 	{ SetSize(0, -1); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	6a ff		 push	 -1
  00010	6a 00		 push	 0
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z ; CArray<CRect,CRect>::SetSize
  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?RemoveAll@?$CArray@VCRect@@V1@@@QAEXXZ ENDP		; CArray<CRect,CRect>::RemoveAll
_TEXT	ENDS
PUBLIC	??_C@_0FH@BMBEKJNI@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@ ; `string'
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:NEAR	; AfxThrowInvalidArgException
;	COMDAT ??_C@_0FH@BMBEKJNI@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT
??_C@_0FH@BMBEKJNI@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@ DB 'D:\Pr'
	DB	'ogram Files (x86)\Microsoft Visual Studio .NET 2003\Vc7\atlmf'
	DB	'c\include\afxtempl.h', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z PROC NEAR	; CArray<CRect,CRect>::GetAt, COMDAT
; _this$ = ecx

; 287  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  : 	ASSERT(nIndex >= 0 && nIndex < m_nSize);

  0000e	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00012	7c 0b		 jl	 SHORT $L189897
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0001a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0001d	7c 14		 jl	 SHORT $L189898
$L189897:
  0001f	68 20 01 00 00	 push	 288			; 00000120H
  00024	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0FH@BMBEKJNI@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
  00029	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0002e	85 c0		 test	 eax, eax
  00030	74 01		 je	 SHORT $L189898
  00032	cc		 int	 3
$L189898:

; 289  : 	if(nIndex >= 0 && nIndex < m_nSize)

  00033	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00037	7c 19		 jl	 SHORT $L188725
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0003f	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00042	7d 0e		 jge	 SHORT $L188725

; 290  : 		return m_pData[nIndex]; 

  00044	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  00047	c1 e0 04	 shl	 eax, 4
  0004a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00050	eb 05		 jmp	 SHORT $L189896
$L188725:

; 291  : 	AfxThrowInvalidArgException();		

  00052	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L189896:

; 292  : }

  00057	83 c4 04	 add	 esp, 4
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?GetAt@?$CArray@VCRect@@V1@@@QAEAAVCRect@@H@Z ENDP	; CArray<CRect,CRect>::GetAt
_TEXT	ENDS
PUBLIC	??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z ; SerializeElements<CRect>
EXTRN	?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z:NEAR ; AfxAssertValidObject
EXTRN	?Serialize@CObject@@UAEXAAVCArchive@@@Z:NEAR	; CObject::Serialize
EXTRN	?IsStoring@CArchive@@QBEHXZ:NEAR		; CArchive::IsStoring
EXTRN	?ReadCount@CArchive@@QAEKXZ:NEAR		; CArchive::ReadCount
EXTRN	?WriteCount@CArchive@@QAEXK@Z:NEAR		; CArchive::WriteCount
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT
_nOldSize$188755 = -8					; size = 4
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z PROC NEAR ; CArray<CRect,CRect>::Serialize, COMDAT
; _this$ = ecx

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 630  : 	ASSERT_VALID(this);

  00017	68 76 02 00 00	 push	 630			; 00000276H
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:$SG188752
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 631  : 
; 632  : 	CObject::Serialize(ar);

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?Serialize@CObject@@UAEXAAVCArchive@@@Z ; CObject::Serialize

; 633  : 	if (ar.IsStoring())

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00039	e8 00 00 00 00	 call	 ?IsStoring@CArchive@@QBEHXZ ; CArchive::IsStoring
  0003e	85 c0		 test	 eax, eax
  00040	74 11		 je	 SHORT $L188753

; 634  : 	{
; 635  : 		ar.WriteCount(m_nSize);

  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0004c	e8 00 00 00 00	 call	 ?WriteCount@CArchive@@QAEXK@Z ; CArchive::WriteCount

; 636  : 	}
; 637  : 	else

  00051	eb 19		 jmp	 SHORT $L188754
$L188753:

; 638  : 	{
; 639  : 		DWORD_PTR nOldSize = ar.ReadCount();

  00053	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00056	e8 00 00 00 00	 call	 ?ReadCount@CArchive@@QAEKXZ ; CArchive::ReadCount
  0005b	89 45 f8	 mov	 DWORD PTR _nOldSize$188755[ebp], eax

; 640  : 		SetSize(nOldSize, -1);

  0005e	6a ff		 push	 -1
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _nOldSize$188755[ebp]
  00063	51		 push	 ecx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z ; CArray<CRect,CRect>::SetSize
$L188754:

; 641  : 	}
; 642  : 	SerializeElements<TYPE>(ar, m_pData, m_nSize);

  0006c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00072	50		 push	 eax
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00079	52		 push	 edx
  0007a	8b 45 08	 mov	 eax, DWORD PTR _ar$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z ; SerializeElements<CRect>

; 643  : }

  00083	83 c4 08	 add	 esp, 8
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
?Serialize@?$CArray@VCRect@@V1@@@UAEXAAVCArchive@@@Z ENDP ; CArray<CRect,CRect>::Serialize
_TEXT	ENDS
PUBLIC	??$DumpElements@VCRect@@@@YGXAAVCDumpContext@@PBVCRect@@H@Z ; DumpElements<CRect>
EXTRN	?Dump@CObject@@UBEXAAVCDumpContext@@@Z:NEAR	; CObject::Dump
EXTRN	?GetDepth@CDumpContext@@QBEHXZ:NEAR		; CDumpContext::GetDepth
EXTRN	??6CDumpContext@@QAEAAV0@PBD@Z:NEAR		; CDumpContext::operator<<
EXTRN	??6CDumpContext@@QAEAAV0@H@Z:NEAR		; CDumpContext::operator<<
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Dump@?$CArray@VCRect@@V1@@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dc$ = 8						; size = 4
?Dump@?$CArray@VCRect@@V1@@@UBEXAAVCDumpContext@@@Z PROC NEAR ; CArray<CRect,CRect>::Dump, COMDAT
; _this$ = ecx

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 649  : 	CObject::Dump(dc);

  0000e	8b 45 08	 mov	 eax, DWORD PTR _dc$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Dump@CObject@@UBEXAAVCDumpContext@@@Z ; CObject::Dump

; 650  : 
; 651  : 	dc << "with " << m_nSize << " elements";

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:$SG188769
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00025	52		 push	 edx
  00026	68 00 00 00 00	 push	 OFFSET FLAT:$SG188768
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _dc$[ebp]
  0002e	e8 00 00 00 00	 call	 ??6CDumpContext@@QAEAAV0@PBD@Z ; CDumpContext::operator<<
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 ??6CDumpContext@@QAEAAV0@H@Z ; CDumpContext::operator<<
  0003a	8b c8		 mov	 ecx, eax
  0003c	e8 00 00 00 00	 call	 ??6CDumpContext@@QAEAAV0@PBD@Z ; CDumpContext::operator<<

; 652  : 	if (dc.GetDepth() > 0)

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _dc$[ebp]
  00044	e8 00 00 00 00	 call	 ?GetDepth@CDumpContext@@QBEHXZ ; CDumpContext::GetDepth
  00049	85 c0		 test	 eax, eax
  0004b	7e 24		 jle	 SHORT $L188770

; 653  : 	{
; 654  : 		dc << "\n";

  0004d	68 00 00 00 00	 push	 OFFSET FLAT:$SG188771
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _dc$[ebp]
  00055	e8 00 00 00 00	 call	 ??6CDumpContext@@QAEAAV0@PBD@Z ; CDumpContext::operator<<

; 655  : 		DumpElements<TYPE>(dc, m_pData, m_nSize);

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00060	51		 push	 ecx
  00061	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00064	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00067	50		 push	 eax
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _dc$[ebp]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$DumpElements@VCRect@@@@YGXAAVCDumpContext@@PBVCRect@@H@Z ; DumpElements<CRect>
$L188770:

; 656  : 	}
; 657  : 
; 658  : 	dc << "\n";

  00071	68 00 00 00 00	 push	 OFFSET FLAT:$SG188778
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _dc$[ebp]
  00079	e8 00 00 00 00	 call	 ??6CDumpContext@@QAEAAV0@PBD@Z ; CDumpContext::operator<<

; 659  : }

  0007e	83 c4 04	 add	 esp, 4
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
?Dump@?$CArray@VCRect@@V1@@@UBEXAAVCDumpContext@@@Z ENDP ; CArray<CRect,CRect>::Dump
_TEXT	ENDS
EXTRN	?AssertValid@CObject@@UBEXXZ:NEAR		; CObject::AssertValid
EXTRN	?AfxIsValidAddress@@YGHPBXIH@Z:NEAR		; AfxIsValidAddress
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AssertValid@?$CArray@VCRect@@V1@@@UBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AssertValid@?$CArray@VCRect@@V1@@@UBEXXZ PROC NEAR	; CArray<CRect,CRect>::AssertValid, COMDAT
; _this$ = ecx

; 663  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 664  : 	CObject::AssertValid();

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?AssertValid@CObject@@UBEXXZ ; CObject::AssertValid

; 665  : 
; 666  : 	if (m_pData == NULL)

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001d	75 3f		 jne	 SHORT $L188784

; 667  : 	{
; 668  : 		ASSERT(m_nSize == 0);

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00026	74 14		 je	 SHORT $L189902
  00028	68 9c 02 00 00	 push	 668			; 0000029cH
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:$SG188786
  00032	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00037	85 c0		 test	 eax, eax
  00039	74 01		 je	 SHORT $L189902
  0003b	cc		 int	 3
$L189902:

; 669  : 		ASSERT(m_nMaxSize == 0);

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00043	74 14		 je	 SHORT $L189903
  00045	68 9d 02 00 00	 push	 669			; 0000029dH
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:$SG188788
  0004f	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00054	85 c0		 test	 eax, eax
  00056	74 01		 je	 SHORT $L189903
  00058	cc		 int	 3
$L189903:

; 670  : 	}
; 671  : 	else

  00059	e9 8c 00 00 00	 jmp	 $L188783
$L188784:

; 672  : 	{
; 673  : 		ASSERT(m_nSize >= 0);

  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00065	7d 14		 jge	 SHORT $L189904
  00067	68 a1 02 00 00	 push	 673			; 000002a1H
  0006c	68 00 00 00 00	 push	 OFFSET FLAT:$SG188791
  00071	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00076	85 c0		 test	 eax, eax
  00078	74 01		 je	 SHORT $L189904
  0007a	cc		 int	 3
$L189904:

; 674  : 		ASSERT(m_nMaxSize >= 0);

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00082	7d 14		 jge	 SHORT $L189905
  00084	68 a2 02 00 00	 push	 674			; 000002a2H
  00089	68 00 00 00 00	 push	 OFFSET FLAT:$SG188793
  0008e	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00093	85 c0		 test	 eax, eax
  00095	74 01		 je	 SHORT $L189905
  00097	cc		 int	 3
$L189905:

; 675  : 		ASSERT(m_nSize <= m_nMaxSize);

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a1	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  000a4	7e 14		 jle	 SHORT $L189906
  000a6	68 a3 02 00 00	 push	 675			; 000002a3H
  000ab	68 00 00 00 00	 push	 OFFSET FLAT:$SG188795
  000b0	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000b5	85 c0		 test	 eax, eax
  000b7	74 01		 je	 SHORT $L189906
  000b9	cc		 int	 3
$L189906:

; 676  : 		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));

  000ba	6a 01		 push	 1
  000bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000c2	c1 e2 04	 shl	 edx, 4
  000c5	52		 push	 edx
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 ?AfxIsValidAddress@@YGHPBXIH@Z ; AfxIsValidAddress
  000d2	85 c0		 test	 eax, eax
  000d4	75 14		 jne	 SHORT $L188783
  000d6	68 a4 02 00 00	 push	 676			; 000002a4H
  000db	68 00 00 00 00	 push	 OFFSET FLAT:$SG188798
  000e0	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000e5	85 c0		 test	 eax, eax
  000e7	74 01		 je	 SHORT $L188783
  000e9	cc		 int	 3
$L188783:

; 677  : 	}
; 678  : }

  000ea	83 c4 04	 add	 esp, 4
  000ed	3b ec		 cmp	 ebp, esp
  000ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?AssertValid@?$CArray@VCRect@@V1@@@UBEXXZ ENDP		; CArray<CRect,CRect>::AssertValid
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
PUBLIC	??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT
$T189909 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  0000b	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T189909[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T189909[ebp]
  00021	52		 push	 edx
  00022	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  00037	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$_Uninitialized_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT
$T189911 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z PROC NEAR ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0000b	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T189911[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T189911[ebp]
  00021	52		 push	 edx
  00022	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
  00033	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ENDP ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Uninitialized_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z PROC NEAR ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ; std::_Uninitialized_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAUTFrame@CPictureEx@@@?$vector@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@IAEPAUTFrame@CPictureEx@@PAU23@00@Z ENDP ; std::vector<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >::_Ucopy<CPictureEx::TFrame *>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z PROC NEAR ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1135 : 	for (; _First != _Last; ++_First)

  00005	eb 09		 jmp	 SHORT $L188939
$L188940:
  00007	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000a	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000d	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L188939:
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00013	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00016	74 0f		 je	 SHORT $L188938

; 1136 : 		*_First = _Val;

  00018	8b 75 10	 mov	 esi, DWORD PTR __Val$[ebp]
  0001b	b9 07 00 00 00	 mov	 ecx, 7
  00020	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00023	f3 a5		 rep movsd
  00025	eb e0		 jmp	 SHORT $L188940
$L188938:

; 1137 : 	}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$fill@PAUTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@0ABU12@@Z ENDP ; std::fill<CPictureEx::TFrame *,CPictureEx::TFrame>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CPictureEx::TFrame *,CPictureEx::TFrame *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z
_TEXT	SEGMENT
$T189915 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z PROC NEAR ; std::copy_backward<CPictureEx::TFrame *,CPictureEx::TFrame *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  0000b	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T189915[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T189915[ebp]
  00021	52		 push	 edx
  00022	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00033	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$copy_backward@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00@Z ENDP ; std::copy_backward<CPictureEx::TFrame *,CPictureEx::TFrame *>
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z PROC NEAR ; std::_Allocate<CPictureEx::TFrame>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 35   : 	}

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Allocate@UTFrame@CPictureEx@@@std@@YAPAUTFrame@CPictureEx@@IPAU12@@Z ENDP ; std::_Allocate<CPictureEx::TFrame>
_TEXT	ENDS
PUBLIC	??1?$CArray@VCRect@@V1@@@UAE@XZ			; CArray<CRect,CRect>::~CArray<CRect,CRect>
EXTRN	??3CObject@@SGXPAX@Z:NEAR			; CObject::operator delete
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z PROC NEAR		; CArray<CRect,CRect>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$CArray@VCRect@@V1@@@UAE@XZ ; CArray<CRect,CRect>::~CArray<CRect,CRect>
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 09		 je	 SHORT $L188966
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L188966:
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??_G?$CArray@VCRect@@V1@@@UAEPAXI@Z ENDP		; CArray<CRect,CRect>::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	??1CObject@@UAE@XZ:NEAR				; CObject::~CObject
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
xdata$x	SEGMENT
$T189924 DD	0ffffffffH
	DD	FLAT:$L189920
$T189922 DD	019930520H
	DD	01H
	DD	FLAT:$T189924
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1?$CArray@VCRect@@V1@@@UAE@XZ
_TEXT	SEGMENT
$T189919 = -24						; size = 4
_i$188740 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CArray@VCRect@@V1@@@UAE@XZ PROC NEAR		; CArray<CRect,CRect>::~CArray<CRect,CRect>, COMDAT
; _this$ = ecx

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CArray@VCRect@@V1@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  00022	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00029	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00030	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7?$CArray@VCRect@@V1@@@6B@
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 357  : 	ASSERT_VALID(this);

  00043	68 65 01 00 00	 push	 357			; 00000165H
  00048	68 00 00 00 00	 push	 OFFSET FLAT:$SG188738
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 358  : 
; 359  : 	if (m_pData != NULL)

  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0005d	74 34		 je	 SHORT $L188737

; 360  : 	{
; 361  : 		for( int i = 0; i < m_nSize; i++ )

  0005f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$188740[ebp], 0
  00066	eb 09		 jmp	 SHORT $L188741
$L188742:
  00068	8b 45 ec	 mov	 eax, DWORD PTR _i$188740[ebp]
  0006b	83 c0 01	 add	 eax, 1
  0006e	89 45 ec	 mov	 DWORD PTR _i$188740[ebp], eax
$L188741:
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	8b 55 ec	 mov	 edx, DWORD PTR _i$188740[ebp]
  00077	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0007a	7d 02		 jge	 SHORT $L188743

; 362  : 			(m_pData + i)->~TYPE();

  0007c	eb ea		 jmp	 SHORT $L188742
$L188743:

; 363  : 		delete[] (BYTE*)m_pData;

  0007e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00084	89 4d e8	 mov	 DWORD PTR $T189919[ebp], ecx
  00087	8b 55 e8	 mov	 edx, DWORD PTR $T189919[ebp]
  0008a	52		 push	 edx
  0008b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00090	83 c4 04	 add	 esp, 4
$L188737:

; 364  : 	}
; 365  : }

  00093	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ??1CObject@@UAE@XZ	; CObject::~CObject
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ac	83 c4 18	 add	 esp, 24			; 00000018H
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L189920:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CObject@@UAE@XZ	; CObject::~CObject
__ehhandler$??1?$CArray@VCRect@@V1@@@UAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T189922
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1?$CArray@VCRect@@V1@@@UAE@XZ ENDP			; CArray<CRect,CRect>::~CArray<CRect,CRect>
PUBLIC	??2@YAPAXIPAX@Z					; operator new
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??0CRect@@QAE@XZ:NEAR				; CRect::CRect
EXTRN	??_U@YAPAXIPBDH@Z:NEAR				; operator new[]
EXTRN	_memset:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z
_TEXT	SEGMENT
tv262 = -88						; size = 4
tv200 = -84						; size = 4
tv201 = -80						; size = 4
tv186 = -76						; size = 4
tv153 = -72						; size = 4
tv130 = -68						; size = 4
$T189951 = -64						; size = 4
$T189948 = -60						; size = 4
$T189946 = -56						; size = 4
$T189937 = -52						; size = 4
$T189934 = -48						; size = 4
$T189933 = -44						; size = 4
$T189929 = -40						; size = 4
_i$189052 = -36						; size = 4
_pNewData$189039 = -32					; size = 4
_nNewMax$189030 = -28					; size = 4
_i$189024 = -24						; size = 4
_i$189015 = -20						; size = 4
_i$189002 = -16						; size = 4
_nAllocSize$188992 = -12				; size = 4
_i$188981 = -8						; size = 4
_this$ = -4						; size = 4
_nNewSize$ = 8						; size = 4
_nGrowBy$ = 12						; size = 4
?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z PROC NEAR	; CArray<CRect,CRect>::SetSize, COMDAT
; _this$ = ecx

; 369  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	57		 push	 edi
  00007	51		 push	 ecx
  00008	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0000b	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	59		 pop	 ecx
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 370  : 	ASSERT_VALID(this);

  0001b	68 72 01 00 00	 push	 370			; 00000172H
  00020	68 00 00 00 00	 push	 OFFSET FLAT:$SG188974
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?AfxAssertValidObject@@YGXPBVCObject@@PBDH@Z ; AfxAssertValidObject

; 371  : 	ASSERT(nNewSize >= 0);

  0002e	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  00032	7d 14		 jge	 SHORT $L189928
  00034	68 73 01 00 00	 push	 371			; 00000173H
  00039	68 00 00 00 00	 push	 OFFSET FLAT:$SG188976
  0003e	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00043	85 c0		 test	 eax, eax
  00045	74 01		 je	 SHORT $L189928
  00047	cc		 int	 3
$L189928:

; 372  : 
; 373  : 	if(nNewSize < 0 )

  00048	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  0004c	7d 05		 jge	 SHORT $L188977

; 374  : 		AfxThrowInvalidArgException();

  0004e	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L188977:

; 375  : 
; 376  : 	if (nGrowBy >= 0)

  00053	83 7d 0c 00	 cmp	 DWORD PTR _nGrowBy$[ebp], 0
  00057	7c 09		 jl	 SHORT $L188978

; 377  : 		m_nGrowBy = nGrowBy;  // set new size

  00059	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  0005f	89 42 10	 mov	 DWORD PTR [edx+16], eax
$L188978:

; 378  : 
; 379  : 	if (nNewSize == 0)

  00062	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  00066	75 60		 jne	 SHORT $L188979

; 380  : 	{
; 381  : 		// shrink to nothing
; 382  : 		if (m_pData != NULL)

  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0006f	74 3e		 je	 SHORT $L188980

; 383  : 		{
; 384  : 			for( int i = 0; i < m_nSize; i++ )

  00071	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$188981[ebp], 0
  00078	eb 09		 jmp	 SHORT $L188982
$L188983:
  0007a	8b 55 f8	 mov	 edx, DWORD PTR _i$188981[ebp]
  0007d	83 c2 01	 add	 edx, 1
  00080	89 55 f8	 mov	 DWORD PTR _i$188981[ebp], edx
$L188982:
  00083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _i$188981[ebp]
  00089	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0008c	7d 02		 jge	 SHORT $L188984

; 385  : 				(m_pData + i)->~TYPE();

  0008e	eb ea		 jmp	 SHORT $L188983
$L188984:

; 386  : 			delete[] (BYTE*)m_pData;

  00090	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00093	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00096	89 45 d8	 mov	 DWORD PTR $T189929[ebp], eax
  00099	8b 4d d8	 mov	 ecx, DWORD PTR $T189929[ebp]
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000a2	83 c4 04	 add	 esp, 4

; 387  : 			m_pData = NULL;

  000a5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L188980:

; 388  : 		}
; 389  : 		m_nSize = m_nMaxSize = 0;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 390  : 	}
; 391  : 	else if (m_pData == NULL)

  000c3	e9 9d 03 00 00	 jmp	 $L189927
$L188979:
  000c8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cb	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000cf	0f 85 e3 00 00
	00		 jne	 $L188988

; 392  : 	{
; 393  : 		// create buffer big enough to hold number of requested elements or
; 394  : 		// m_nGrowBy elements, whichever is larger.
; 395  : #ifdef SIZE_T_MAX
; 396  : 		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow

  000d5	81 7d 08 ff ff
	ff 0f		 cmp	 DWORD PTR _nNewSize$[ebp], 268435455 ; 0fffffffH
  000dc	76 14		 jbe	 SHORT $L189930
  000de	68 8c 01 00 00	 push	 396			; 0000018cH
  000e3	68 00 00 00 00	 push	 OFFSET FLAT:$SG188991
  000e8	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000ed	85 c0		 test	 eax, eax
  000ef	74 01		 je	 SHORT $L189930
  000f1	cc		 int	 3
$L189930:

; 397  : #endif
; 398  : 		size_t nAllocSize = max(nNewSize, m_nGrowBy);

  000f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000f8	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  000fb	7e 08		 jle	 SHORT $L189931
  000fd	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00100	89 45 bc	 mov	 DWORD PTR tv130[ebp], eax
  00103	eb 09		 jmp	 SHORT $L189932
$L189931:
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0010b	89 55 bc	 mov	 DWORD PTR tv130[ebp], edx
$L189932:
  0010e	8b 45 bc	 mov	 eax, DWORD PTR tv130[ebp]
  00111	89 45 f4	 mov	 DWORD PTR _nAllocSize$188992[ebp], eax

; 399  : 		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];

  00114	68 8f 01 00 00	 push	 399			; 0000018fH
  00119	68 00 00 00 00	 push	 OFFSET FLAT:$SG188998
  0011e	8b 4d f4	 mov	 ecx, DWORD PTR _nAllocSize$188992[ebp]
  00121	c1 e1 04	 shl	 ecx, 4
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ??_U@YAPAXIPBDH@Z	; operator new[]
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012d	89 45 d4	 mov	 DWORD PTR $T189933[ebp], eax
  00130	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00133	8b 45 d4	 mov	 eax, DWORD PTR $T189933[ebp]
  00136	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 400  : 		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));

  00139	8b 4d f4	 mov	 ecx, DWORD PTR _nAllocSize$188992[ebp]
  0013c	c1 e1 04	 shl	 ecx, 4
  0013f	51		 push	 ecx
  00140	6a 00		 push	 0
  00142	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00145	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _memset
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 401  : 		for( int i = 0; i < nNewSize; i++ )

  00151	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$189002[ebp], 0
  00158	eb 09		 jmp	 SHORT $L189003
$L189004:
  0015a	8b 4d f0	 mov	 ecx, DWORD PTR _i$189002[ebp]
  0015d	83 c1 01	 add	 ecx, 1
  00160	89 4d f0	 mov	 DWORD PTR _i$189002[ebp], ecx
$L189003:
  00163	8b 55 f0	 mov	 edx, DWORD PTR _i$189002[ebp]
  00166	3b 55 08	 cmp	 edx, DWORD PTR _nNewSize$[ebp]
  00169	7d 36		 jge	 SHORT $L189005

; 402  : #pragma push_macro("new")
; 403  : #undef new
; 404  : 			::new( (void*)( m_pData + i ) ) TYPE;

  0016b	8b 45 f0	 mov	 eax, DWORD PTR _i$189002[ebp]
  0016e	c1 e0 04	 shl	 eax, 4
  00171	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00177	50		 push	 eax
  00178	6a 10		 push	 16			; 00000010H
  0017a	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0017f	83 c4 08	 add	 esp, 8
  00182	89 45 d0	 mov	 DWORD PTR $T189934[ebp], eax
  00185	83 7d d0 00	 cmp	 DWORD PTR $T189934[ebp], 0
  00189	74 0d		 je	 SHORT $L189935
  0018b	8b 4d d0	 mov	 ecx, DWORD PTR $T189934[ebp]
  0018e	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  00193	89 45 b8	 mov	 DWORD PTR tv153[ebp], eax
  00196	eb 07		 jmp	 SHORT $L189936
$L189935:
  00198	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv153[ebp], 0
$L189936:
  0019f	eb b9		 jmp	 SHORT $L189004
$L189005:

; 405  : #pragma pop_macro("new")
; 406  : 		m_nSize = nNewSize;

  001a1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001a4	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  001a7	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 407  : 		m_nMaxSize = nAllocSize;

  001aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ad	8b 55 f4	 mov	 edx, DWORD PTR _nAllocSize$188992[ebp]
  001b0	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 408  : 	}
; 409  : 	else if (nNewSize <= m_nMaxSize)

  001b3	e9 ad 02 00 00	 jmp	 $L189927
$L188988:
  001b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001bb	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  001be	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  001c1	0f 8f d6 00 00
	00		 jg	 $L189010

; 410  : 	{
; 411  : 		// it fits
; 412  : 		if (nNewSize > m_nSize)

  001c7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001ca	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  001cd	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  001d0	0f 8e 8c 00 00
	00		 jle	 $L189011

; 413  : 		{
; 414  : 			// initialize the new elements
; 415  : 			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  001d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  001dc	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  001df	c1 e2 04	 shl	 edx, 4
  001e2	52		 push	 edx
  001e3	6a 00		 push	 0
  001e5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001eb	c1 e1 04	 shl	 ecx, 4
  001ee	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f1	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _memset
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 416  : 			for( int i = 0; i < nNewSize-m_nSize; i++ )

  001fd	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$189015[ebp], 0
  00204	eb 09		 jmp	 SHORT $L189016
$L189017:
  00206	8b 45 ec	 mov	 eax, DWORD PTR _i$189015[ebp]
  00209	83 c0 01	 add	 eax, 1
  0020c	89 45 ec	 mov	 DWORD PTR _i$189015[ebp], eax
$L189016:
  0020f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00212	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00215	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  00218	39 55 ec	 cmp	 DWORD PTR _i$189015[ebp], edx
  0021b	7d 43		 jge	 SHORT $L189018

; 417  : #pragma push_macro("new")
; 418  : #undef new
; 419  : 				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;

  0021d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00220	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00223	c1 e1 04	 shl	 ecx, 4
  00226	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00229	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0022c	03 c1		 add	 eax, ecx
  0022e	8b 4d ec	 mov	 ecx, DWORD PTR _i$189015[ebp]
  00231	c1 e1 04	 shl	 ecx, 4
  00234	03 c1		 add	 eax, ecx
  00236	50		 push	 eax
  00237	6a 10		 push	 16			; 00000010H
  00239	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0023e	83 c4 08	 add	 esp, 8
  00241	89 45 cc	 mov	 DWORD PTR $T189937[ebp], eax
  00244	83 7d cc 00	 cmp	 DWORD PTR $T189937[ebp], 0
  00248	74 0d		 je	 SHORT $L189938
  0024a	8b 4d cc	 mov	 ecx, DWORD PTR $T189937[ebp]
  0024d	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  00252	89 45 b4	 mov	 DWORD PTR tv186[ebp], eax
  00255	eb 07		 jmp	 SHORT $L189939
$L189938:
  00257	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv186[ebp], 0
$L189939:
  0025e	eb a6		 jmp	 SHORT $L189017
$L189018:

; 420  : #pragma pop_macro("new")
; 421  : 		}
; 422  : 		else if (m_nSize > nNewSize)

  00260	eb 2d		 jmp	 SHORT $L189022
$L189011:
  00262	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00265	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00268	3b 45 08	 cmp	 eax, DWORD PTR _nNewSize$[ebp]
  0026b	7e 22		 jle	 SHORT $L189022

; 423  : 		{
; 424  : 			// destroy the old elements
; 425  : 			for( int i = 0; i < m_nSize-nNewSize; i++ )

  0026d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$189024[ebp], 0
  00274	eb 09		 jmp	 SHORT $L189025
$L189026:
  00276	8b 4d e8	 mov	 ecx, DWORD PTR _i$189024[ebp]
  00279	83 c1 01	 add	 ecx, 1
  0027c	89 4d e8	 mov	 DWORD PTR _i$189024[ebp], ecx
$L189025:
  0027f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00282	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00285	2b 45 08	 sub	 eax, DWORD PTR _nNewSize$[ebp]
  00288	39 45 e8	 cmp	 DWORD PTR _i$189024[ebp], eax
  0028b	7d 02		 jge	 SHORT $L189022

; 426  : 				(m_pData + nNewSize + i)->~TYPE();

  0028d	eb e7		 jmp	 SHORT $L189026
$L189022:

; 427  : 		}
; 428  : 		m_nSize = nNewSize;

  0028f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00292	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00295	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 429  : 	}
; 430  : 	else

  00298	e9 c8 01 00 00	 jmp	 $L189927
$L189010:

; 431  : 	{
; 432  : 		// otherwise, grow array
; 433  : 		nGrowBy = m_nGrowBy;

  0029d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002a0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  002a3	89 4d 0c	 mov	 DWORD PTR _nGrowBy$[ebp], ecx

; 434  : 		if (nGrowBy == 0)

  002a6	83 7d 0c 00	 cmp	 DWORD PTR _nGrowBy$[ebp], 0
  002aa	75 45		 jne	 SHORT $L189029

; 435  : 		{
; 436  : 			// heuristically determine growth when nGrowBy == 0
; 437  : 			//  (this avoids heap fragmentation in many situations)
; 438  : 			nGrowBy = m_nSize / 8;

  002ac	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002af	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002b2	99		 cdq
  002b3	83 e2 07	 and	 edx, 7
  002b6	03 c2		 add	 eax, edx
  002b8	c1 f8 03	 sar	 eax, 3
  002bb	89 45 0c	 mov	 DWORD PTR _nGrowBy$[ebp], eax

; 439  : 			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);

  002be	83 7d 0c 04	 cmp	 DWORD PTR _nGrowBy$[ebp], 4
  002c2	7d 09		 jge	 SHORT $L189942
  002c4	c7 45 b0 04 00
	00 00		 mov	 DWORD PTR tv201[ebp], 4
  002cb	eb 1e		 jmp	 SHORT $L189943
$L189942:
  002cd	81 7d 0c 00 04
	00 00		 cmp	 DWORD PTR _nGrowBy$[ebp], 1024 ; 00000400H
  002d4	7e 09		 jle	 SHORT $L189940
  002d6	c7 45 ac 00 04
	00 00		 mov	 DWORD PTR tv200[ebp], 1024 ; 00000400H
  002dd	eb 06		 jmp	 SHORT $L189941
$L189940:
  002df	8b 45 0c	 mov	 eax, DWORD PTR _nGrowBy$[ebp]
  002e2	89 45 ac	 mov	 DWORD PTR tv200[ebp], eax
$L189941:
  002e5	8b 4d ac	 mov	 ecx, DWORD PTR tv200[ebp]
  002e8	89 4d b0	 mov	 DWORD PTR tv201[ebp], ecx
$L189943:
  002eb	8b 55 b0	 mov	 edx, DWORD PTR tv201[ebp]
  002ee	89 55 0c	 mov	 DWORD PTR _nGrowBy$[ebp], edx
$L189029:

; 440  : 		}
; 441  : 		INT_PTR nNewMax;
; 442  : 		if (nNewSize < m_nMaxSize + nGrowBy)

  002f1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002f4	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002f7	03 4d 0c	 add	 ecx, DWORD PTR _nGrowBy$[ebp]
  002fa	39 4d 08	 cmp	 DWORD PTR _nNewSize$[ebp], ecx
  002fd	7d 0e		 jge	 SHORT $L189031

; 443  : 			nNewMax = m_nMaxSize + nGrowBy;  // granularity

  002ff	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00302	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00305	03 45 0c	 add	 eax, DWORD PTR _nGrowBy$[ebp]
  00308	89 45 e4	 mov	 DWORD PTR _nNewMax$189030[ebp], eax

; 444  : 		else

  0030b	eb 06		 jmp	 SHORT $L189032
$L189031:

; 445  : 			nNewMax = nNewSize;  // no slush

  0030d	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00310	89 4d e4	 mov	 DWORD PTR _nNewMax$189030[ebp], ecx
$L189032:

; 446  : 
; 447  : 		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around

  00313	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00316	8b 45 e4	 mov	 eax, DWORD PTR _nNewMax$189030[ebp]
  00319	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0031c	7d 14		 jge	 SHORT $L189944
  0031e	68 bf 01 00 00	 push	 447			; 000001bfH
  00323	68 00 00 00 00	 push	 OFFSET FLAT:$SG189034
  00328	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0032d	85 c0		 test	 eax, eax
  0032f	74 01		 je	 SHORT $L189944
  00331	cc		 int	 3
$L189944:

; 448  : 		
; 449  : 		if(nNewMax  < m_nMaxSize)

  00332	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00335	8b 45 e4	 mov	 eax, DWORD PTR _nNewMax$189030[ebp]
  00338	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  0033b	7d 05		 jge	 SHORT $L189035

; 450  : 			AfxThrowInvalidArgException();

  0033d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L189035:

; 451  : 
; 452  : #ifdef SIZE_T_MAX
; 453  : 		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow

  00342	81 7d e4 ff ff
	ff 0f		 cmp	 DWORD PTR _nNewMax$189030[ebp], 268435455 ; 0fffffffH
  00349	76 14		 jbe	 SHORT $L189945
  0034b	68 c5 01 00 00	 push	 453			; 000001c5H
  00350	68 00 00 00 00	 push	 OFFSET FLAT:$SG189038
  00355	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0035a	85 c0		 test	 eax, eax
  0035c	74 01		 je	 SHORT $L189945
  0035e	cc		 int	 3
$L189945:

; 454  : #endif
; 455  : 		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

  0035f	8b 55 e4	 mov	 edx, DWORD PTR _nNewMax$189030[ebp]
  00362	c1 e2 04	 shl	 edx, 4
  00365	52		 push	 edx
  00366	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0036b	83 c4 04	 add	 esp, 4
  0036e	89 45 c8	 mov	 DWORD PTR $T189946[ebp], eax
  00371	8b 45 c8	 mov	 eax, DWORD PTR $T189946[ebp]
  00374	89 45 e0	 mov	 DWORD PTR _pNewData$189039[ebp], eax

; 456  : 
; 457  : 		// copy new data from old
; 458  : 		memcpy(pNewData, m_pData, (size_t)m_nSize * sizeof(TYPE));

  00377	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0037a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0037d	c1 e2 04	 shl	 edx, 4
  00380	52		 push	 edx
  00381	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00384	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00387	51		 push	 ecx
  00388	8b 55 e0	 mov	 edx, DWORD PTR _pNewData$189039[ebp]
  0038b	52		 push	 edx
  0038c	e8 00 00 00 00	 call	 _memcpy
  00391	83 c4 0c	 add	 esp, 12			; 0000000cH

; 459  : 
; 460  : 		// construct remaining elements
; 461  : 		ASSERT(nNewSize > m_nSize);

  00394	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00397	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  0039a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0039d	7f 14		 jg	 SHORT $L189947
  0039f	68 cd 01 00 00	 push	 461			; 000001cdH
  003a4	68 00 00 00 00	 push	 OFFSET FLAT:$SG189048
  003a9	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  003ae	85 c0		 test	 eax, eax
  003b0	74 01		 je	 SHORT $L189947
  003b2	cc		 int	 3
$L189947:

; 462  : 		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));

  003b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003b6	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  003b9	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  003bc	c1 e1 04	 shl	 ecx, 4
  003bf	51		 push	 ecx
  003c0	6a 00		 push	 0
  003c2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003c5	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  003c8	c1 e0 04	 shl	 eax, 4
  003cb	03 45 e0	 add	 eax, DWORD PTR _pNewData$189039[ebp]
  003ce	50		 push	 eax
  003cf	e8 00 00 00 00	 call	 _memset
  003d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 463  : 		for( int i = 0; i < nNewSize-m_nSize; i++ )

  003d7	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$189052[ebp], 0
  003de	eb 09		 jmp	 SHORT $L189053
$L189054:
  003e0	8b 4d dc	 mov	 ecx, DWORD PTR _i$189052[ebp]
  003e3	83 c1 01	 add	 ecx, 1
  003e6	89 4d dc	 mov	 DWORD PTR _i$189052[ebp], ecx
$L189053:
  003e9	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003ec	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  003ef	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  003f2	39 45 dc	 cmp	 DWORD PTR _i$189052[ebp], eax
  003f5	7d 3e		 jge	 SHORT $L189055

; 464  : #pragma push_macro("new")
; 465  : #undef new
; 466  : 			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;

  003f7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003fa	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003fd	c1 e2 04	 shl	 edx, 4
  00400	03 55 e0	 add	 edx, DWORD PTR _pNewData$189039[ebp]
  00403	8b 45 dc	 mov	 eax, DWORD PTR _i$189052[ebp]
  00406	c1 e0 04	 shl	 eax, 4
  00409	03 d0		 add	 edx, eax
  0040b	52		 push	 edx
  0040c	6a 10		 push	 16			; 00000010H
  0040e	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00413	83 c4 08	 add	 esp, 8
  00416	89 45 c4	 mov	 DWORD PTR $T189948[ebp], eax
  00419	83 7d c4 00	 cmp	 DWORD PTR $T189948[ebp], 0
  0041d	74 0d		 je	 SHORT $L189949
  0041f	8b 4d c4	 mov	 ecx, DWORD PTR $T189948[ebp]
  00422	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  00427	89 45 a8	 mov	 DWORD PTR tv262[ebp], eax
  0042a	eb 07		 jmp	 SHORT $L189950
$L189949:
  0042c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv262[ebp], 0
$L189950:
  00433	eb ab		 jmp	 SHORT $L189054
$L189055:

; 467  : #pragma pop_macro("new")
; 468  : 
; 469  : 		// get rid of old stuff (note: no destructors called)
; 470  : 		delete[] (BYTE*)m_pData;

  00435	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00438	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0043b	89 55 c0	 mov	 DWORD PTR $T189951[ebp], edx
  0043e	8b 45 c0	 mov	 eax, DWORD PTR $T189951[ebp]
  00441	50		 push	 eax
  00442	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00447	83 c4 04	 add	 esp, 4

; 471  : 		m_pData = pNewData;

  0044a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0044d	8b 55 e0	 mov	 edx, DWORD PTR _pNewData$189039[ebp]
  00450	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 472  : 		m_nSize = nNewSize;

  00453	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00456	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00459	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 473  : 		m_nMaxSize = nNewMax;

  0045c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0045f	8b 45 e4	 mov	 eax, DWORD PTR _nNewMax$189030[ebp]
  00462	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$L189927:

; 474  : 	}
; 475  : }

  00465	5f		 pop	 edi
  00466	83 c4 58	 add	 esp, 88			; 00000058H
  00469	3b ec		 cmp	 ebp, esp
  0046b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00470	8b e5		 mov	 esp, ebp
  00472	5d		 pop	 ebp
  00473	c2 08 00	 ret	 8
?SetSize@?$CArray@VCRect@@V1@@@QAEXHH@Z ENDP		; CArray<CRect,CRect>::SetSize
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\new.h
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __P$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
EXTRN	?Read@CArchive@@QAEIPAXI@Z:NEAR			; CArchive::Read
EXTRN	?Write@CArchive@@QAEXPBXI@Z:NEAR		; CArchive::Write
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afxtempl.h
;	COMDAT ??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv81 = -28						; size = 4
_nElementsToRead$189094 = -24				; size = 4
_nElementsLeft$189090 = -20				; size = 4
_pData$189089 = -16					; size = 4
_nElementsToWrite$189084 = -12				; size = 4
_nElementsLeft$189080 = -8				; size = 4
_pData$189079 = -4					; size = 4
_ar$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z PROC NEAR ; SerializeElements<CRect>, COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000e	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00011	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00014	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00017	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001a	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001d	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00020	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 70   : 	ASSERT(nCount == 0 ||

  00023	83 7d 10 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00027	74 27		 je	 SHORT $L189954
  00029	6a 01		 push	 1
  0002b	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  0002e	c1 e0 04	 shl	 eax, 4
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?AfxIsValidAddress@@YGHPBXIH@Z ; AfxIsValidAddress
  0003b	85 c0		 test	 eax, eax
  0003d	75 11		 jne	 SHORT $L189954
  0003f	6a 47		 push	 71			; 00000047H
  00041	68 00 00 00 00	 push	 OFFSET FLAT:$SG189077
  00046	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0004b	85 c0		 test	 eax, eax
  0004d	74 01		 je	 SHORT $L189954
  0004f	cc		 int	 3
$L189954:

; 71   : 		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(TYPE)));
; 72   : 
; 73   : 	// default is bit-wise read/write
; 74   : 	if (ar.IsStoring())

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  00053	e8 00 00 00 00	 call	 ?IsStoring@CArchive@@QBEHXZ ; CArchive::IsStoring
  00058	85 c0		 test	 eax, eax
  0005a	74 5c		 je	 SHORT $L189078

; 75   :    {
; 76   : 	  TYPE* pData;
; 77   : 	  UINT_PTR nElementsLeft;
; 78   : 
; 79   : 	  nElementsLeft = nCount;

  0005c	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  0005f	89 45 f8	 mov	 DWORD PTR _nElementsLeft$189080[ebp], eax

; 80   : 	  pData = pElements;

  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00065	89 4d fc	 mov	 DWORD PTR _pData$189079[ebp], ecx
$L189082:

; 81   : 	  while( nElementsLeft > 0 )

  00068	83 7d f8 00	 cmp	 DWORD PTR _nElementsLeft$189080[ebp], 0
  0006c	76 48		 jbe	 SHORT $L189083

; 82   : 	  {
; 83   : 		 UINT nElementsToWrite;
; 84   : 
; 85   : 		 nElementsToWrite = UINT(min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  0006e	81 7d f8 ff ff
	ff 07		 cmp	 DWORD PTR _nElementsLeft$189080[ebp], 134217727 ; 07ffffffH
  00075	73 08		 jae	 SHORT $L189955
  00077	8b 55 f8	 mov	 edx, DWORD PTR _nElementsLeft$189080[ebp]
  0007a	89 55 e4	 mov	 DWORD PTR tv81[ebp], edx
  0007d	eb 07		 jmp	 SHORT $L189956
$L189955:
  0007f	c7 45 e4 ff ff
	ff 07		 mov	 DWORD PTR tv81[ebp], 134217727 ; 07ffffffH
$L189956:
  00086	8b 45 e4	 mov	 eax, DWORD PTR tv81[ebp]
  00089	89 45 f4	 mov	 DWORD PTR _nElementsToWrite$189084[ebp], eax

; 86   : 		 ar.Write(pData, nElementsToWrite*sizeof(TYPE));

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR _nElementsToWrite$189084[ebp]
  0008f	c1 e1 04	 shl	 ecx, 4
  00092	51		 push	 ecx
  00093	8b 55 fc	 mov	 edx, DWORD PTR _pData$189079[ebp]
  00096	52		 push	 edx
  00097	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  0009a	e8 00 00 00 00	 call	 ?Write@CArchive@@QAEXPBXI@Z ; CArchive::Write

; 87   : 		 nElementsLeft -= nElementsToWrite;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _nElementsLeft$189080[ebp]
  000a2	2b 45 f4	 sub	 eax, DWORD PTR _nElementsToWrite$189084[ebp]
  000a5	89 45 f8	 mov	 DWORD PTR _nElementsLeft$189080[ebp], eax

; 88   : 		 pData += nElementsToWrite;

  000a8	8b 4d f4	 mov	 ecx, DWORD PTR _nElementsToWrite$189084[ebp]
  000ab	c1 e1 04	 shl	 ecx, 4
  000ae	03 4d fc	 add	 ecx, DWORD PTR _pData$189079[ebp]
  000b1	89 4d fc	 mov	 DWORD PTR _pData$189079[ebp], ecx

; 89   : 	  }

  000b4	eb b2		 jmp	 SHORT $L189082
$L189083:

; 90   :    }
; 91   : 	else

  000b6	eb 5a		 jmp	 SHORT $L189073
$L189078:

; 92   :    {
; 93   : 	  TYPE* pData;
; 94   : 	  UINT_PTR nElementsLeft;
; 95   : 
; 96   : 	  nElementsLeft = nCount;

  000b8	8b 55 10	 mov	 edx, DWORD PTR _nCount$[ebp]
  000bb	89 55 ec	 mov	 DWORD PTR _nElementsLeft$189090[ebp], edx

; 97   : 	  pData = pElements;

  000be	8b 45 0c	 mov	 eax, DWORD PTR _pElements$[ebp]
  000c1	89 45 f0	 mov	 DWORD PTR _pData$189089[ebp], eax
$L189092:

; 98   : 	  while( nElementsLeft > 0 )

  000c4	83 7d ec 00	 cmp	 DWORD PTR _nElementsLeft$189090[ebp], 0
  000c8	76 48		 jbe	 SHORT $L189073

; 99   : 	  {
; 100  : 		 UINT nElementsToRead;
; 101  : 
; 102  : 		 nElementsToRead = UINT(min(nElementsLeft, INT_MAX/sizeof(TYPE)));

  000ca	81 7d ec ff ff
	ff 07		 cmp	 DWORD PTR _nElementsLeft$189090[ebp], 134217727 ; 07ffffffH
  000d1	73 08		 jae	 SHORT $L189957
  000d3	8b 4d ec	 mov	 ecx, DWORD PTR _nElementsLeft$189090[ebp]
  000d6	89 4d e0	 mov	 DWORD PTR tv91[ebp], ecx
  000d9	eb 07		 jmp	 SHORT $L189958
$L189957:
  000db	c7 45 e0 ff ff
	ff 07		 mov	 DWORD PTR tv91[ebp], 134217727 ; 07ffffffH
$L189958:
  000e2	8b 55 e0	 mov	 edx, DWORD PTR tv91[ebp]
  000e5	89 55 e8	 mov	 DWORD PTR _nElementsToRead$189094[ebp], edx

; 103  : 		 ar.Read(pData, nElementsToRead*sizeof(TYPE));

  000e8	8b 45 e8	 mov	 eax, DWORD PTR _nElementsToRead$189094[ebp]
  000eb	c1 e0 04	 shl	 eax, 4
  000ee	50		 push	 eax
  000ef	8b 4d f0	 mov	 ecx, DWORD PTR _pData$189089[ebp]
  000f2	51		 push	 ecx
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _ar$[ebp]
  000f6	e8 00 00 00 00	 call	 ?Read@CArchive@@QAEIPAXI@Z ; CArchive::Read

; 104  : 		 nElementsLeft -= nElementsToRead;

  000fb	8b 55 ec	 mov	 edx, DWORD PTR _nElementsLeft$189090[ebp]
  000fe	2b 55 e8	 sub	 edx, DWORD PTR _nElementsToRead$189094[ebp]
  00101	89 55 ec	 mov	 DWORD PTR _nElementsLeft$189090[ebp], edx

; 105  : 		 pData += nElementsToRead;

  00104	8b 45 e8	 mov	 eax, DWORD PTR _nElementsToRead$189094[ebp]
  00107	c1 e0 04	 shl	 eax, 4
  0010a	03 45 f0	 add	 eax, DWORD PTR _pData$189089[ebp]
  0010d	89 45 f0	 mov	 DWORD PTR _pData$189089[ebp], eax

; 106  : 	  }

  00110	eb b2		 jmp	 SHORT $L189092
$L189073:

; 107  :    }
; 108  : }

  00112	83 c4 20	 add	 esp, 32			; 00000020H
  00115	3b ec		 cmp	 ebp, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c2 0c 00	 ret	 12			; 0000000cH
??$SerializeElements@VCRect@@@@YGXAAVCArchive@@PAVCRect@@H@Z ENDP ; SerializeElements<CRect>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$DumpElements@VCRect@@@@YGXAAVCDumpContext@@PBVCRect@@H@Z
_TEXT	SEGMENT
_dc$ = 8						; size = 4
_pElements$ = 12					; size = 4
_nCount$ = 16						; size = 4
??$DumpElements@VCRect@@@@YGXAAVCDumpContext@@PBVCRect@@H@Z PROC NEAR ; DumpElements<CRect>, COMDAT

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 138  : 	ASSERT(nCount == 0 ||

  00003	83 7d 10 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00007	74 2a		 je	 SHORT $L189098
  00009	6a 00		 push	 0
  0000b	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  0000e	c1 e0 04	 shl	 eax, 4
  00011	50		 push	 eax
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _pElements$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ?AfxIsValidAddress@@YGHPBXIH@Z ; AfxIsValidAddress
  0001b	85 c0		 test	 eax, eax
  0001d	75 14		 jne	 SHORT $L189098
  0001f	68 8b 00 00 00	 push	 139			; 0000008bH
  00024	68 00 00 00 00	 push	 OFFSET FLAT:$SG189102
  00029	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0002e	85 c0		 test	 eax, eax
  00030	74 01		 je	 SHORT $L189098
  00032	cc		 int	 3
$L189098:

; 139  : 		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(TYPE), FALSE));
; 140  : 	&dc; // not used
; 141  : 	pElements;  // not used
; 142  : 	nCount; // not used
; 143  : 
; 144  : 	// default does nothing
; 145  : }

  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
??$DumpElements@VCRect@@@@YGXAAVCDumpContext@@PBVCRect@@H@Z ENDP ; DumpElements<CRect>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z PROC NEAR ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

  0001b	8a 45 fb	 mov	 al, BYTE PTR __Cat$[ebp]

; 214  : 	}

  0001e	52		 push	 edx
  0001f	8b cd		 mov	 ecx, ebp
  00021	50		 push	 eax
  00022	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L189964
  00028	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0002d	58		 pop	 eax
  0002e	5a		 pop	 edx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$L189964:
  00033	01 00 00 00	 DD	 1
  00037	00 00 00 00	 DD	 $L189963
$L189963:
  0003b	fb ff ff ff	 DD	 -5			; fffffffbH
  0003f	01 00 00 00	 DD	 1
  00043	00 00 00 00	 DD	 $L189962
$L189962:
  00047	5f		 DB	 95			; 0000005fH
  00048	43		 DB	 67			; 00000043H
  00049	61		 DB	 97			; 00000061H
  0004a	74		 DB	 116			; 00000074H
  0004b	00		 DB	 0
??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ENDP ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z ; std::allocator<CPictureEx::TFrame>::construct
PUBLIC	?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ; std::allocator<CPictureEx::TFrame>::destroy
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T189971 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T189973 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L189967
$T189972 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T189973
$T189969 DD	019930520H
	DD	02H
	DD	FLAT:$T189971
	DD	01H
	DD	FLAT:$T189972
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00024	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 208  : 	_FwdIt _Next = _First;

  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 209  : 
; 210  : 	_TRY_BEGIN

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

  00034	eb 12		 jmp	 SHORT $L189108
$L189109:
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00039	83 e9 01	 sub	 ecx, 1
  0003c	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	83 c2 1c	 add	 edx, 28			; 0000001cH
  00045	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L189108:
  00048	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0004c	76 12		 jbe	 SHORT $L189110

; 212  : 		_Al.construct(_First, _Val);

  0004e	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00055	51		 push	 ecx
  00056	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00059	e8 00 00 00 00	 call	 ?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z ; std::allocator<CPictureEx::TFrame>::construct
  0005e	eb d6		 jmp	 SHORT $L189109
$L189110:
  00060	eb 2a		 jmp	 SHORT $L189966
$L189967:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

  00062	eb 09		 jmp	 SHORT $L189111
$L189112:
  00064	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  00067	83 c2 1c	 add	 edx, 28			; 0000001cH
  0006a	89 55 ec	 mov	 DWORD PTR __Next$[ebp], edx
$L189111:
  0006d	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00070	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  00073	74 0e		 je	 SHORT $L189113

; 215  : 		_Al.destroy(_Next);

  00075	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00078	51		 push	 ecx
  00079	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0007c	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ; std::allocator<CPictureEx::TFrame>::destroy
  00081	eb e1		 jmp	 SHORT $L189112
$L189113:

; 216  : 	_RERAISE;

  00083	6a 00		 push	 0
  00085	6a 00		 push	 0
  00087	e8 00 00 00 00	 call	 __CxxThrowException@8
$L189966:

; 217  : 	_CATCH_END

  0008c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$L189965:

; 218  : 	}

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	83 c4 14	 add	 esp, 20			; 00000014H
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T189969
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAUTFrame@CPictureEx@@IU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@IABU12@AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CPictureEx::TFrame *,unsigned int,CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >, COMDAT

; 224  : 	{	// destroy [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 225  : 	for (; _First != _Last; ++_First)

  00003	eb 09		 jmp	 SHORT $L189115
$L189116:
  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L189115:
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00011	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00014	74 0e		 je	 SHORT $L189114

; 226  : 		_Al.destroy(_First);

  00016	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001d	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ; std::allocator<CPictureEx::TFrame>::destroy
  00022	eb e1		 jmp	 SHORT $L189116
$L189114:

; 227  : 	}

  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Destroy_range@UTFrame@CPictureEx@@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAXPAUTFrame@CPictureEx@@0AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<CPictureEx::TFrame,std::allocator<CPictureEx::TFrame> >
_TEXT	ENDS
EXTRN	?AfxTryCleanup@@YGXXZ:NEAR			; AfxTryCleanup
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\atlmfc\include\afx.h
;	COMDAT ??1AFX_EXCEPTION_LINK@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1AFX_EXCEPTION_LINK@@QAE@XZ PROC NEAR			; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK, COMDAT
; _this$ = ecx

; 819  : 		{ AfxTryCleanup(); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	e8 00 00 00 00	 call	 ?AfxTryCleanup@@YGXXZ	; AfxTryCleanup
  00013	83 c4 04	 add	 esp, 4
  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??1AFX_EXCEPTION_LINK@@QAE@XZ ENDP			; AFX_EXCEPTION_LINK::~AFX_EXCEPTION_LINK
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z
_TEXT	SEGMENT
$T189979 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  0000b	8d 45 10	 lea	 eax, DWORD PTR __Dest$[ebp]
  0000e	50		 push	 eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUTFrame@CPictureEx@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTFrame@CPictureEx@@0@Z ; std::_Ptr_cat<CPictureEx::TFrame *,CPictureEx::TFrame *>
  00018	83 c4 08	 add	 esp, 8
  0001b	88 45 ff	 mov	 BYTE PTR $T189979[ebp], al
  0001e	8a 55 ff	 mov	 dl, BYTE PTR $T189979[ebp]
  00021	52		 push	 edx
  00022	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002d	52		 push	 edx
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
  00037	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$_Uninitialized_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@@Z ENDP ; std::_Uninitialized_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<CPictureEx::TFrame *,CPictureEx::TFrame *>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
$L189160:

; 1049 : 	while (_First != _Last)

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000b	74 21		 je	 SHORT $L189161

; 1050 : 		*--_Dest = *--_Last;

  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00010	83 e9 1c	 sub	 ecx, 28			; 0000001cH
  00013	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  00016	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00019	83 ea 1c	 sub	 edx, 28			; 0000001cH
  0001c	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0001f	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  00022	b9 07 00 00 00	 mov	 ecx, 7
  00027	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0002a	f3 a5		 rep movsd
  0002c	eb d7		 jmp	 SHORT $L189160
$L189161:

; 1051 : 	return (_Dest);

  0002e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1052 : 	}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Copy_backward_opt@PAUTFrame@CPictureEx@@PAU12@@std@@YAPAUTFrame@CPictureEx@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CPictureEx::TFrame *,CPictureEx::TFrame *>
_TEXT	ENDS
PUBLIC	??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z ; std::_Construct<CPictureEx::TFrame,CPictureEx::TFrame>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z ; std::_Construct<CPictureEx::TFrame,CPictureEx::TFrame>
  0001b	83 c4 08	 add	 esp, 8

; 148  : 		}

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z ENDP ; std::allocator<CPictureEx::TFrame>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z ; std::_Destroy<CPictureEx::TFrame>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z PROC NEAR ; std::allocator<CPictureEx::TFrame>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z ; std::_Destroy<CPictureEx::TFrame>
  00017	83 c4 04	 add	 esp, 4

; 153  : 		}

  0001a	83 c4 04	 add	 esp, 4
  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ENDP ; std::allocator<CPictureEx::TFrame>::destroy
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	SEGMENT
$T189989 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T189991 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L189985
$T189990 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T189991
$T189987 DD	019930520H
	DD	02H
	DD	FLAT:$T189989
	DD	01H
	DD	FLAT:$T189990
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	51		 push	 ecx
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00024	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 78   : 	_FwdIt _Next = _Dest;

  00027	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002a	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 79   : 
; 80   : 	_TRY_BEGIN

  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

  00034	eb 12		 jmp	 SHORT $L189179
$L189180:
  00036	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00039	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0003c	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	83 c2 1c	 add	 edx, 28			; 0000001cH
  00045	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$L189179:
  00048	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004b	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0004e	74 12		 je	 SHORT $L189181

; 82   : 		_Al.construct(_Dest, *_First);

  00050	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00057	52		 push	 edx
  00058	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0005b	e8 00 00 00 00	 call	 ?construct@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@ABU34@@Z ; std::allocator<CPictureEx::TFrame>::construct
  00060	eb d4		 jmp	 SHORT $L189180
$L189181:
  00062	eb 2a		 jmp	 SHORT $L189984
$L189985:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

  00064	eb 09		 jmp	 SHORT $L189182
$L189183:
  00066	8b 45 ec	 mov	 eax, DWORD PTR __Next$[ebp]
  00069	83 c0 1c	 add	 eax, 28			; 0000001cH
  0006c	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax
$L189182:
  0006f	8b 4d ec	 mov	 ecx, DWORD PTR __Next$[ebp]
  00072	3b 4d 10	 cmp	 ecx, DWORD PTR __Dest$[ebp]
  00075	74 0e		 je	 SHORT $L189184

; 85   : 		_Al.destroy(_Next);

  00077	8b 55 ec	 mov	 edx, DWORD PTR __Next$[ebp]
  0007a	52		 push	 edx
  0007b	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0007e	e8 00 00 00 00	 call	 ?destroy@?$allocator@UTFrame@CPictureEx@@@std@@QAEXPAUTFrame@CPictureEx@@@Z ; std::allocator<CPictureEx::TFrame>::destroy
  00083	eb e1		 jmp	 SHORT $L189183
$L189184:

; 86   : 	_RERAISE;

  00085	6a 00		 push	 0
  00087	6a 00		 push	 0
  00089	e8 00 00 00 00	 call	 __CxxThrowException@8
$L189984:

; 87   : 	_CATCH_END

  0008e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 88   : 	return (_Dest);

  00095	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$L189983:

; 89   : 	}

  00098	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	83 c4 14	 add	 esp, 20			; 00000014H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T189987
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAUTFrame@CPictureEx@@PAU12@V?$allocator@UTFrame@CPictureEx@@@std@@@std@@YAPAUTFrame@CPictureEx@@PAU12@00AAV?$allocator@UTFrame@CPictureEx@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CPictureEx::TFrame *,CPictureEx::TFrame *,std::allocator<CPictureEx::TFrame> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
$T189995 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z PROC NEAR ; std::_Construct<CPictureEx::TFrame,CPictureEx::TFrame>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000f	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

  00016	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00019	50		 push	 eax
  0001a	6a 1c		 push	 28			; 0000001cH
  0001c	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00021	83 c4 08	 add	 esp, 8
  00024	89 45 fc	 mov	 DWORD PTR $T189995[ebp], eax
  00027	83 7d fc 00	 cmp	 DWORD PTR $T189995[ebp], 0
  0002b	74 15		 je	 SHORT $L189996
  0002d	8b 75 0c	 mov	 esi, DWORD PTR __Val$[ebp]
  00030	b9 07 00 00 00	 mov	 ecx, 7
  00035	8b 7d fc	 mov	 edi, DWORD PTR $T189995[ebp]
  00038	f3 a5		 rep movsd
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR $T189995[ebp]
  0003d	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  00040	eb 07		 jmp	 SHORT $L189185
$L189996:
  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$L189185:

; 43   : 	}

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	83 c4 08	 add	 esp, 8
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
??$_Construct@UTFrame@CPictureEx@@U12@@std@@YAXPAUTFrame@CPictureEx@@ABU12@@Z ENDP ; std::_Construct<CPictureEx::TFrame,CPictureEx::TFrame>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z PROC NEAR ; std::_Destroy<CPictureEx::TFrame>, COMDAT

; 48   : 	{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy@UTFrame@CPictureEx@@@std@@YAXPAUTFrame@CPictureEx@@@Z ENDP ; std::_Destroy<CPictureEx::TFrame>
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00015	8b f4		 mov	 esi, esp
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0001d	3b f4		 cmp	 esi, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 28   : 		}

  00024	5e		 pop	 esi
  00025	83 c4 04	 add	 esp, 4
  00028	3b ec		 cmp	 ebp, esp
  0002a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
EXTRN	__imp_??0exception@@QAE@XZ:NEAR
EXTRN	__imp_??1exception@@UAE@XZ:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190008 DD	0ffffffffH
	DD	FLAT:$L190003
$T190006 DD	019930520H
	DD	01H
	DD	FLAT:$T190008
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
; Function compile flags: /Odt /RTCsu
rdata$r	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b f4		 mov	 esi, esp
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@XZ
  0002f	3b f4		 cmp	 esi, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00046	8b f4		 mov	 esi, esp
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 20   : 		}

  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00073	5e		 pop	 esi
  00074	83 c4 10	 add	 esp, 16			; 00000010H
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190003:
  00000	8b f4		 mov	 esi, esp
  00002	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190006
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0c		 je	 SHORT $L91647
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
$L91647:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190018 DD	0ffffffffH
	DD	FLAT:$L190013
$T190016 DD	019930520H
	DD	01H
	DD	FLAT:$T190018
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003a	8b f4		 mov	 esi, esp
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00050	8b f4		 mov	 esi, esp
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006c	5e		 pop	 esi
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190013:
  00000	8b f4		 mov	 esi, esp
  00002	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??1logic_error@std@@UAE@XZ:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190016
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0001f	83 c4 04	 add	 esp, 4
  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0c		 je	 SHORT $L91713
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4
$L91713:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T190030 DD	0ffffffffH
	DD	FLAT:$L190025
$T190028 DD	019930520H
	DD	01H
	DD	FLAT:$T190030
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b f4		 mov	 esi, esp
  00026	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0exception@@QAE@ABV0@@Z
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
  0004a	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0004d	83 c2 0c	 add	 edx, 12			; 0000000cH
  00050	8b f4		 mov	 esi, esp
  00052	52		 push	 edx
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007a	5e		 pop	 esi
  0007b	83 c4 10	 add	 esp, 16			; 00000010H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L190025:
  00000	8b f4		 mov	 esi, esp
  00002	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1exception@@UAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T190028
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
END
