; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\CommonControl\SkinScroll\coolscroll.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG22593 DB	01H DUP (?)
	ALIGN	4

?count@?1??CalcThumbSize@@9@9 DD 01H DUP (?)		; `CalcThumbSize'::`2'::count
?lastportion@?1??MouseMove@@9@9 DD 01H DUP (?)		; `MouseMove'::`2'::lastportion
?lastbutton@?1??MouseMove@@9@9 DD 01H DUP (?)		; `MouseMove'::`2'::lastbutton
_uCurrentButton DD 01H DUP (?)
_uMouseOverId DD 01H DUP (?)
_uScrollTimerMsg DD 01H DUP (?)
_uScrollTimerId DD 01H DUP (?)
_hwndCurCoolSB DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_uCurrentScrollbar DD 0ffffffffH
_uCurrentScrollPortion DD 0ffffffffH
_nLastPos DD	0ffffffffH
_uMouseOverScrollbar DD 0ffffffffH
_uHitTestPortion DD 0ffffffffH
_uLastHitTestPortion DD 0ffffffffH
_uScrollTimerPortion DD 0ffffffffH
?wCheckPat@?1??DrawCheckedRect@@9@9 DW 0aaaaH		; `DrawCheckedRect'::`2'::wCheckPat
	DW	05555H
	DW	0aaaaH
	DW	05555H
	DW	0aaaaH
	DW	05555H
	DW	0aaaaH
	DW	05555H
_curTool DD	0ffffffffH
?lastpos@?5??CoolSBWndProc@@9@9 DD 0ffffffffH		; `CoolSBWndProc'::`6'::lastpos
_DATA	ENDS
PUBLIC	_CoolSB_IsThumbTracking@4
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	_GetScrollWndFromHwnd:NEAR
;	COMDAT rtc$IMZ
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\commoncontrol\skinscroll\coolscroll.c
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
_TEXT	SEGMENT
_sw$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_CoolSB_IsThumbTracking@4 PROC NEAR

; 105  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 106  : 	SCROLLWND *sw;
; 107  : 
; 108  : 	if((sw = GetScrollWndFromHwnd(hwnd)) == NULL)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _GetScrollWndFromHwnd
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 fc	 mov	 DWORD PTR _sw$[ebp], eax
  0001a	83 7d fc 00	 cmp	 DWORD PTR _sw$[ebp], 0
  0001e	75 04		 jne	 SHORT $L22463

; 109  : 		return FALSE;

  00020	33 c0		 xor	 eax, eax
  00022	eb 09		 jmp	 SHORT $L22460
$L22463:

; 110  : 	else
; 111  : 		return sw->fThumbTracking; 

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _sw$[ebp]
  00027	8b 81 a0 06 00
	00		 mov	 eax, DWORD PTR [ecx+1696]
$L22460:

; 112  : }

  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
_CoolSB_IsThumbTracking@4 ENDP
_TEXT	ENDS
PUBLIC	_DrawBlankButton
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	__imp__GetSysColorBrush@4:NEAR
EXTRN	__imp__FillRect@12:NEAR
EXTRN	__imp__DrawEdge@16:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_rc$ = -20						; size = 16
_hdc$ = 8						; size = 4
_rect$ = 12						; size = 4
_drawflag$ = 16						; size = 4
_DrawBlankButton PROC NEAR

; 386  : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 18	 sub	 esp, 24			; 00000018H
  00046	56		 push	 esi
  00047	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0004c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0004f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00052	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00055	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00058	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0005b	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 387  : 	RECT rc = *rect;

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	89 4d ec	 mov	 DWORD PTR _rc$[ebp], ecx
  00066	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00069	89 55 f0	 mov	 DWORD PTR _rc$[ebp+4], edx
  0006c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006f	89 4d f4	 mov	 DWORD PTR _rc$[ebp+8], ecx
  00072	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00075	89 55 f8	 mov	 DWORD PTR _rc$[ebp+12], edx

; 388  : 		
; 389  : #ifndef FLAT_SCROLLBARS	
; 390  : 	drawflag &= ~BF_FLAT;
; 391  : #endif
; 392  : 	
; 393  : 	DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | drawflag | BF_ADJUST);

  00078	8b 45 10	 mov	 eax, DWORD PTR _drawflag$[ebp]
  0007b	83 c8 0f	 or	 eax, 15			; 0000000fH
  0007e	0d 00 20 00 00	 or	 eax, 8192		; 00002000H
  00083	8b f4		 mov	 esi, esp
  00085	50		 push	 eax
  00086	6a 05		 push	 5
  00088	8d 4d ec	 lea	 ecx, DWORD PTR _rc$[ebp]
  0008b	51		 push	 ecx
  0008c	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  0008f	52		 push	 edx
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawEdge@16
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 394  : 	FillRect(hdc, &rc, GetSysColorBrush(COLOR_BTNFACE));

  0009d	8b f4		 mov	 esi, esp
  0009f	6a 0f		 push	 15			; 0000000fH
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColorBrush@4
  000a7	3b f4		 cmp	 esi, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b f4		 mov	 esi, esp
  000b0	50		 push	 eax
  000b1	8d 45 ec	 lea	 eax, DWORD PTR _rc$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  000b8	51		 push	 ecx
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 395  : }

  000c6	52		 push	 edx
  000c7	8b cd		 mov	 ecx, ebp
  000c9	50		 push	 eax
  000ca	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23869
  000d0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d5	58		 pop	 eax
  000d6	5a		 pop	 edx
  000d7	5e		 pop	 esi
  000d8	83 c4 18	 add	 esp, 24			; 00000018H
  000db	3b ec		 cmp	 ebp, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$L23869:
  000e6	01 00 00 00	 DD	 1
  000ea	00 00 00 00	 DD	 $L23868
$L23868:
  000ee	ec ff ff ff	 DD	 -20			; ffffffecH
  000f2	10 00 00 00	 DD	 16			; 00000010H
  000f6	00 00 00 00	 DD	 $L23867
$L23867:
  000fa	72		 DB	 114			; 00000072H
  000fb	63		 DB	 99			; 00000063H
  000fc	00		 DB	 0
_DrawBlankButton ENDP
_TEXT	ENDS
PUBLIC	_GetScrollRect
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_sw$ = 8						; size = 4
_nBar$ = 12						; size = 4
_hwnd$ = 16						; size = 4
_rect$ = 20						; size = 4
_GetScrollRect PROC NEAR

; 471  : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp

; 472  : 	if(nBar == SB_HORZ)

  00103	83 7d 0c 00	 cmp	 DWORD PTR _nBar$[ebp], 0
  00107	75 16		 jne	 SHORT $L22651

; 473  : 		return GetHScrollRect(sw, hwnd, rect);

  00109	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  0010c	50		 push	 eax
  0010d	8b 4d 10	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00110	51		 push	 ecx
  00111	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 _GetHScrollRect
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011d	eb 1e		 jmp	 SHORT $L22650
$L22651:

; 474  : 	else if(nBar == SB_VERT)

  0011f	83 7d 0c 01	 cmp	 DWORD PTR _nBar$[ebp], 1
  00123	75 16		 jne	 SHORT $L22653

; 475  : 		return GetVScrollRect(sw, hwnd, rect);

  00125	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  00128	50		 push	 eax
  00129	8b 4d 10	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0012c	51		 push	 ecx
  0012d	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00130	52		 push	 edx
  00131	e8 00 00 00 00	 call	 _GetVScrollRect
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH
  00139	eb 02		 jmp	 SHORT $L22650
$L22653:

; 476  : 	else
; 477  : 		return FALSE;

  0013b	33 c0		 xor	 eax, eax
$L22650:

; 478  : }

  0013d	3b ec		 cmp	 ebp, esp
  0013f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
_GetScrollRect ENDP
_TEXT	ENDS
EXTRN	__imp__GetWindowRect@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv140 = -12						; size = 4
tv92 = -8						; size = 4
tv75 = -4						; size = 4
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_GetHScrollRect PROC NEAR

; 411  : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00156	56		 push	 esi
  00157	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0015e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00165	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 412  : 	GetWindowRect(hwnd, rect);

  0016c	8b f4		 mov	 esi, esp
  0016e	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  00171	50		 push	 eax
  00172	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00175	51		 push	 ecx
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  0017c	3b f4		 cmp	 esi, esp
  0017e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 413  : 	
; 414  : 	if(sw->fLeftScrollbar)

  00183	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00186	83 ba a4 06 00
	00 00		 cmp	 DWORD PTR [edx+1700], 0
  0018d	74 59		 je	 SHORT $L22629

; 415  : 	{
; 416  : 		rect->left  += sw->cxLeftEdge + (sw->sbarVert.fScrollVisible ? 
; 417  : 					GetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);

  0018f	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00192	83 b8 58 03 00
	00 00		 cmp	 DWORD PTR [eax+856], 0
  00199	74 19		 je	 SHORT $L23873
  0019b	6a 01		 push	 1
  0019d	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  001a0	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  001a6	51		 push	 ecx
  001a7	e8 00 00 00 00	 call	 _GetScrollMetric
  001ac	83 c4 08	 add	 esp, 8
  001af	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  001b2	eb 07		 jmp	 SHORT $L23874
$L23873:
  001b4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$L23874:
  001bb	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  001be	8b 82 ac 06 00
	00		 mov	 eax, DWORD PTR [edx+1708]
  001c4	03 45 fc	 add	 eax, DWORD PTR tv75[ebp]
  001c7	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  001ca	03 01		 add	 eax, DWORD PTR [ecx]
  001cc	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  001cf	89 02		 mov	 DWORD PTR [edx], eax

; 418  : 		rect->right -= sw->cxRightEdge;

  001d1	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  001d4	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  001d7	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001da	2b 91 b0 06 00
	00		 sub	 edx, DWORD PTR [ecx+1712]
  001e0	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  001e3	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 419  : 	}
; 420  : 	else

  001e6	eb 58		 jmp	 SHORT $L22630
$L22629:

; 421  : 	{
; 422  : 		rect->left   += sw->cxLeftEdge;					//left window edge

  001e8	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  001eb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ed	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  001f0	03 90 ac 06 00
	00		 add	 edx, DWORD PTR [eax+1708]
  001f6	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  001f9	89 11		 mov	 DWORD PTR [ecx], edx

; 423  : 	
; 424  : 		rect->right  -= sw->cxRightEdge +				//right window edge
; 425  : 					(sw->sbarVert.fScrollVisible ? 
; 426  : 					GetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);

  001fb	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  001fe	83 ba 58 03 00
	00 00		 cmp	 DWORD PTR [edx+856], 0
  00205	74 18		 je	 SHORT $L23875
  00207	6a 01		 push	 1
  00209	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0020c	05 54 03 00 00	 add	 eax, 852		; 00000354H
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 _GetScrollMetric
  00217	83 c4 08	 add	 esp, 8
  0021a	89 45 f8	 mov	 DWORD PTR tv92[ebp], eax
  0021d	eb 07		 jmp	 SHORT $L23876
$L23875:
  0021f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$L23876:
  00226	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00229	8b 91 b0 06 00
	00		 mov	 edx, DWORD PTR [ecx+1712]
  0022f	03 55 f8	 add	 edx, DWORD PTR tv92[ebp]
  00232	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  00235	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00238	2b ca		 sub	 ecx, edx
  0023a	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  0023d	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$L22630:

; 427  : 	}
; 428  : 	
; 429  : 	rect->bottom -= sw->cyBottomEdge;				//bottom window edge

  00240	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  00243	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00246	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00249	2b 91 b8 06 00
	00		 sub	 edx, DWORD PTR [ecx+1720]
  0024f	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  00252	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 430  : 	
; 431  : 	rect->top	  = rect->bottom -
; 432  : 					(sw->sbarHorz.fScrollVisible ?
; 433  : 					GetScrollMetric(&sw->sbarHorz, SM_CYHORZSB) : 0);

  00255	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00258	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0025c	74 16		 je	 SHORT $L23877
  0025e	6a 01		 push	 1
  00260	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00263	83 c2 08	 add	 edx, 8
  00266	52		 push	 edx
  00267	e8 00 00 00 00	 call	 _GetScrollMetric
  0026c	83 c4 08	 add	 esp, 8
  0026f	89 45 f4	 mov	 DWORD PTR tv140[ebp], eax
  00272	eb 07		 jmp	 SHORT $L23878
$L23877:
  00274	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$L23878:
  0027b	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  0027e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00281	2b 4d f4	 sub	 ecx, DWORD PTR tv140[ebp]
  00284	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00287	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 434  : 	
; 435  : 	return TRUE;

  0028a	b8 01 00 00 00	 mov	 eax, 1

; 436  : }

  0028f	5e		 pop	 esi
  00290	83 c4 0c	 add	 esp, 12			; 0000000cH
  00293	3b ec		 cmp	 ebp, esp
  00295	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029a	8b e5		 mov	 esp, ebp
  0029c	5d		 pop	 ebp
  0029d	c3		 ret	 0
_GetHScrollRect ENDP
_TEXT	ENDS
EXTRN	__imp__GetSystemMetrics@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_sbar$ = 8						; size = 4
_metric$ = 12						; size = 4
_GetScrollMetric PROC NEAR

; 269  : {

  002a0	55		 push	 ebp
  002a1	8b ec		 mov	 ebp, esp
  002a3	56		 push	 esi
  002a4	57		 push	 edi

; 270  : 	if(sbar->nBarType == SB_HORZ)

  002a5	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  002a8	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  002af	75 6a		 jne	 SHORT $L22540

; 271  : 	{
; 272  : 		if(metric == SM_CXHORZSB)

  002b1	83 7d 0c 00	 cmp	 DWORD PTR _metric$[ebp], 0
  002b5	75 35		 jne	 SHORT $L22541

; 273  : 		{
; 274  : 			if(sbar->nArrowLength < 0)

  002b7	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  002ba	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  002be	7d 21		 jge	 SHORT $L22542

; 275  : 				return -sbar->nArrowLength * GetSystemMetrics(SM_CXHSCROLL);

  002c0	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  002c3	8b 72 24	 mov	 esi, DWORD PTR [edx+36]
  002c6	f7 de		 neg	 esi
  002c8	8b fc		 mov	 edi, esp
  002ca	6a 15		 push	 21			; 00000015H
  002cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  002d2	3b fc		 cmp	 edi, esp
  002d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002d9	0f af c6	 imul	 eax, esi
  002dc	e9 ac 00 00 00	 jmp	 $L22539
$L22542:

; 276  : 			else
; 277  : 				return sbar->nArrowLength;

  002e1	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  002e4	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  002e7	e9 a1 00 00 00	 jmp	 $L22539
$L22541:

; 278  : 		}
; 279  : 		else
; 280  : 		{
; 281  : 			if(sbar->nArrowWidth < 0)

  002ec	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  002ef	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  002f3	7d 1e		 jge	 SHORT $L22545

; 282  : 				return -sbar->nArrowWidth * GetSystemMetrics(SM_CYHSCROLL);

  002f5	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  002f8	8b 72 28	 mov	 esi, DWORD PTR [edx+40]
  002fb	f7 de		 neg	 esi
  002fd	8b fc		 mov	 edi, esp
  002ff	6a 03		 push	 3
  00301	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00307	3b fc		 cmp	 edi, esp
  00309	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0030e	0f af c6	 imul	 eax, esi
  00311	eb 7a		 jmp	 SHORT $L22539
$L22545:

; 283  : 			else
; 284  : 				return sbar->nArrowWidth;

  00313	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  00316	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00319	eb 72		 jmp	 SHORT $L22539
$L22540:

; 285  : 		}
; 286  : 	}
; 287  : 	else if(sbar->nBarType == SB_VERT)

  0031b	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  0031e	83 b9 40 03 00
	00 01		 cmp	 DWORD PTR [ecx+832], 1
  00325	75 64		 jne	 SHORT $L22547

; 288  : 	{
; 289  : 		if(metric == SM_CYVERTSB)

  00327	83 7d 0c 00	 cmp	 DWORD PTR _metric$[ebp], 0
  0032b	75 2f		 jne	 SHORT $L22549

; 290  : 		{
; 291  : 			if(sbar->nArrowLength < 0)

  0032d	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  00330	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00334	7d 1e		 jge	 SHORT $L22550

; 292  : 				return -sbar->nArrowLength * GetSystemMetrics(SM_CYVSCROLL);

  00336	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  00339	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  0033c	f7 de		 neg	 esi
  0033e	8b fc		 mov	 edi, esp
  00340	6a 14		 push	 20			; 00000014H
  00342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00348	3b fc		 cmp	 edi, esp
  0034a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0034f	0f af c6	 imul	 eax, esi
  00352	eb 39		 jmp	 SHORT $L22539
$L22550:

; 293  : 			else
; 294  : 				return sbar->nArrowLength;

  00354	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  00357	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0035a	eb 31		 jmp	 SHORT $L22539
$L22549:

; 295  : 		}
; 296  : 		else
; 297  : 		{
; 298  : 			if(sbar->nArrowWidth < 0)

  0035c	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  0035f	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00363	7d 1e		 jge	 SHORT $L22553

; 299  : 				return -sbar->nArrowWidth * GetSystemMetrics(SM_CXVSCROLL);

  00365	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  00368	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  0036b	f7 de		 neg	 esi
  0036d	8b fc		 mov	 edi, esp
  0036f	6a 02		 push	 2
  00371	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  00377	3b fc		 cmp	 edi, esp
  00379	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0037e	0f af c6	 imul	 eax, esi
  00381	eb 0a		 jmp	 SHORT $L22539
$L22553:

; 300  : 			else
; 301  : 				return sbar->nArrowWidth;

  00383	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  00386	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00389	eb 02		 jmp	 SHORT $L22539
$L22547:

; 302  : 		}
; 303  : 	}
; 304  : 
; 305  : 	return 0;

  0038b	33 c0		 xor	 eax, eax
$L22539:

; 306  : }

  0038d	5f		 pop	 edi
  0038e	5e		 pop	 esi
  0038f	3b ec		 cmp	 ebp, esp
  00391	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00396	5d		 pop	 ebp
  00397	c3		 ret	 0
_GetScrollMetric ENDP
; Function compile flags: /Odt /RTCsu
tv138 = -12						; size = 4
tv93 = -8						; size = 4
tv78 = -4						; size = 4
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_GetVScrollRect PROC NEAR

; 443  : {

  003a0	55		 push	 ebp
  003a1	8b ec		 mov	 ebp, esp
  003a3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  003a6	56		 push	 esi
  003a7	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  003ae	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  003b5	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 444  : 	GetWindowRect(hwnd, rect);

  003bc	8b f4		 mov	 esi, esp
  003be	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  003c1	50		 push	 eax
  003c2	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  003c5	51		 push	 ecx
  003c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  003cc	3b f4		 cmp	 esi, esp
  003ce	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 445  : 	rect->top	 += sw->cyTopEdge;						//top window edge

  003d3	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  003d6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003d9	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  003dc	03 81 b4 06 00
	00		 add	 eax, DWORD PTR [ecx+1716]
  003e2	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  003e5	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 446  : 	
; 447  : 	rect->bottom -= sw->cyBottomEdge + 
; 448  : 					(sw->sbarHorz.fScrollVisible ?		//bottom window edge
; 449  : 					GetScrollMetric(&sw->sbarHorz, SM_CYHORZSB) : 0);

  003e8	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  003eb	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  003ef	74 16		 je	 SHORT $L23881
  003f1	6a 01		 push	 1
  003f3	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  003f6	83 c1 08	 add	 ecx, 8
  003f9	51		 push	 ecx
  003fa	e8 00 00 00 00	 call	 _GetScrollMetric
  003ff	83 c4 08	 add	 esp, 8
  00402	89 45 fc	 mov	 DWORD PTR tv78[ebp], eax
  00405	eb 07		 jmp	 SHORT $L23882
$L23881:
  00407	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$L23882:
  0040e	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00411	8b 82 b8 06 00
	00		 mov	 eax, DWORD PTR [edx+1720]
  00417	03 45 fc	 add	 eax, DWORD PTR tv78[ebp]
  0041a	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0041d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00420	2b d0		 sub	 edx, eax
  00422	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  00425	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 450  : 
; 451  : 	if(sw->fLeftScrollbar)

  00428	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0042b	83 b9 a4 06 00
	00 00		 cmp	 DWORD PTR [ecx+1700], 0
  00432	74 4f		 je	 SHORT $L22639

; 452  : 	{
; 453  : 		rect->left	+= sw->cxLeftEdge;

  00434	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00437	8b 02		 mov	 eax, DWORD PTR [edx]
  00439	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0043c	03 81 ac 06 00
	00		 add	 eax, DWORD PTR [ecx+1708]
  00442	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00445	89 02		 mov	 DWORD PTR [edx], eax

; 454  : 		rect->right = rect->left + (sw->sbarVert.fScrollVisible ?
; 455  : 					GetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);

  00447	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0044a	83 b8 58 03 00
	00 00		 cmp	 DWORD PTR [eax+856], 0
  00451	74 19		 je	 SHORT $L23883
  00453	6a 01		 push	 1
  00455	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00458	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  0045e	51		 push	 ecx
  0045f	e8 00 00 00 00	 call	 _GetScrollMetric
  00464	83 c4 08	 add	 esp, 8
  00467	89 45 f8	 mov	 DWORD PTR tv93[ebp], eax
  0046a	eb 07		 jmp	 SHORT $L23884
$L23883:
  0046c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
$L23884:
  00473	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00476	8b 02		 mov	 eax, DWORD PTR [edx]
  00478	03 45 f8	 add	 eax, DWORD PTR tv93[ebp]
  0047b	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0047e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 456  : 	}
; 457  : 	else

  00481	eb 4f		 jmp	 SHORT $L22640
$L22639:

; 458  : 	{
; 459  : 		rect->right  -= sw->cxRightEdge;

  00483	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00486	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00489	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0048c	2b 88 b0 06 00
	00		 sub	 ecx, DWORD PTR [eax+1712]
  00492	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  00495	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 460  : 		rect->left    = rect->right - (sw->sbarVert.fScrollVisible ?	
; 461  : 					GetScrollMetric(&sw->sbarVert, SM_CXVERTSB) : 0);

  00498	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0049b	83 b8 58 03 00
	00 00		 cmp	 DWORD PTR [eax+856], 0
  004a2	74 19		 je	 SHORT $L23885
  004a4	6a 01		 push	 1
  004a6	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  004a9	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  004af	51		 push	 ecx
  004b0	e8 00 00 00 00	 call	 _GetScrollMetric
  004b5	83 c4 08	 add	 esp, 8
  004b8	89 45 f4	 mov	 DWORD PTR tv138[ebp], eax
  004bb	eb 07		 jmp	 SHORT $L23886
$L23885:
  004bd	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
$L23886:
  004c4	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  004c7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  004ca	2b 45 f4	 sub	 eax, DWORD PTR tv138[ebp]
  004cd	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  004d0	89 01		 mov	 DWORD PTR [ecx], eax
$L22640:

; 462  : 	}
; 463  : 
; 464  : 	return TRUE;

  004d2	b8 01 00 00 00	 mov	 eax, 1

; 465  : }

  004d7	5e		 pop	 esi
  004d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  004db	3b ec		 cmp	 ebp, esp
  004dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004e2	8b e5		 mov	 esp, ebp
  004e4	5d		 pop	 ebp
  004e5	c3		 ret	 0
_GetVScrollRect ENDP
_TEXT	ENDS
PUBLIC	_CoolSB_GetDC
EXTRN	__imp__GetWindowDC@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hwnd$ = 8						; size = 4
_wParam$ = 12						; size = 4
_CoolSB_GetDC PROC NEAR

; 1384 : {

  004f0	55		 push	 ebp
  004f1	8b ec		 mov	 ebp, esp
  004f3	56		 push	 esi

; 1385 : 	// I just can't figure out GetDCEx, so I'll just use this:
; 1386 : 	return GetWindowDC(hwnd);

  004f4	8b f4		 mov	 esi, esp
  004f6	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  004f9	50		 push	 eax
  004fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  00500	3b f4		 cmp	 esi, esp
  00502	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1387 : 
; 1388 : 	/*
; 1389 : 	RECT rc;
; 1390 : 	DWORD flags = 0x10000;
; 1391 : 	HRGN hrgn = (HRGN)wParam;
; 1392 : 
; 1393 : 	if(hrgn == (HRGN)1)
; 1394 : 	{
; 1395 : 		GetWindowRect(hwnd, &rc);
; 1396 : 		OffsetRect(&rc, -rc.left, -rc.top);
; 1397 : 		hrgn = CreateRectRgnIndirect(&rc);
; 1398 : 	}
; 1399 : 
; 1400 : 	if(GetWindowLong(hwnd, GWL_STYLE) & WS_CLIPCHILDREN)
; 1401 : 		flags |= DCX_CLIPCHILDREN;
; 1402 : 
; 1403 : 	if(GetWindowLong(hwnd, GWL_STYLE) & WS_CLIPSIBLINGS)
; 1404 : 		flags |= DCX_CLIPSIBLINGS;
; 1405 : 
; 1406 : 	return GetDCEx(hwnd, hrgn, flags | DCX_CACHE|DCX_NORESETATTRS|DCX_WINDOW | DCX_INTERSECTUPDATE);
; 1407 : 	*/
; 1408 : 
; 1409 : 	//return GetDCEx(hwnd, NULL, flags | DCX_WINDOW| DCX_NORESETATTRS);
; 1410 : }

  00507	5e		 pop	 esi
  00508	3b ec		 cmp	 ebp, esp
  0050a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0050f	5d		 pop	 ebp
  00510	c3		 ret	 0
_CoolSB_GetDC ENDP
_TEXT	ENDS
PUBLIC	_CoolSBWndProc@16
EXTRN	__imp__CallWindowProcA@20:NEAR
EXTRN	_UninitializeCoolSB@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv66 = -12						; size = 4
_swnd$ = -8						; size = 4
_oldproc$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CoolSBWndProc@16 PROC NEAR

; 3095 : {

  00520	55		 push	 ebp
  00521	8b ec		 mov	 ebp, esp
  00523	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00526	56		 push	 esi
  00527	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0052e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00535	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 3096 : 	WNDPROC oldproc;
; 3097 : 	SCROLLWND *swnd = GetScrollWndFromHwnd(hwnd);

  0053c	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0053f	50		 push	 eax
  00540	e8 00 00 00 00	 call	 _GetScrollWndFromHwnd
  00545	83 c4 04	 add	 esp, 4
  00548	89 45 f8	 mov	 DWORD PTR _swnd$[ebp], eax

; 3098 : 	static int count;
; 3099 : 
; 3100 : 	switch(message)

  0054b	8b 4d 0c	 mov	 ecx, DWORD PTR _message$[ebp]
  0054e	89 4d f4	 mov	 DWORD PTR tv66[ebp], ecx
  00551	81 7d f4 a0 00
	00 00		 cmp	 DWORD PTR tv66[ebp], 160 ; 000000a0H
  00558	77 31		 ja	 SHORT $L23889
  0055a	81 7d f4 a0 00
	00 00		 cmp	 DWORD PTR tv66[ebp], 160 ; 000000a0H
  00561	0f 84 74 02 00
	00		 je	 $L23752
  00567	8b 55 f4	 mov	 edx, DWORD PTR tv66[ebp]
  0056a	83 ea 20	 sub	 edx, 32			; 00000020H
  0056d	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  00570	83 7d f4 65	 cmp	 DWORD PTR tv66[ebp], 101 ; 00000065H
  00574	0f 87 c0 02 00
	00		 ja	 $L23727
  0057a	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  0057d	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L23891[eax]
  00584	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L23892[ecx*4]
$L23889:
  0058b	81 7d f4 a8 00
	00 00		 cmp	 DWORD PTR tv66[ebp], 168 ; 000000a8H
  00592	77 2d		 ja	 SHORT $L23890
  00594	81 7d f4 a7 00
	00 00		 cmp	 DWORD PTR tv66[ebp], 167 ; 000000a7H
  0059b	0f 83 dd 00 00
	00		 jae	 $L23734
  005a1	8b 55 f4	 mov	 edx, DWORD PTR tv66[ebp]
  005a4	81 ea a1 00 00
	00		 sub	 edx, 161		; 000000a1H
  005aa	89 55 f4	 mov	 DWORD PTR tv66[ebp], edx
  005ad	83 7d f4 04	 cmp	 DWORD PTR tv66[ebp], 4
  005b1	0f 87 83 02 00
	00		 ja	 $L23727
  005b7	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  005ba	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L23893[eax*4]
$L23890:
  005c1	81 7d f4 13 01
	00 00		 cmp	 DWORD PTR tv66[ebp], 275 ; 00000113H
  005c8	0f 84 b6 01 00
	00		 je	 $L23746
  005ce	81 7d f4 00 02
	00 00		 cmp	 DWORD PTR tv66[ebp], 512 ; 00000200H
  005d5	0f 84 8c 01 00
	00		 je	 $L23745
  005db	81 7d f4 02 02
	00 00		 cmp	 DWORD PTR tv66[ebp], 514 ; 00000202H
  005e2	0f 84 2d 01 00
	00		 je	 $L23743
  005e8	e9 4d 02 00 00	 jmp	 $L23727
$L23730:

; 3101 : 	{
; 3102 : 	case WM_NCDESTROY:
; 3103 : 		//this should NEVER be called, because the user
; 3104 : 		//should have called Uninitialize() themselves.
; 3105 : 
; 3106 : 		//However, if the user tries to call Uninitialize().. 
; 3107 : 		//after this window is destroyed, this window's entry in the lookup
; 3108 : 		//table will not be there, and the call will fail
; 3109 : 		oldproc = swnd->oldproc;

  005ed	8b 4d f8	 mov	 ecx, DWORD PTR _swnd$[ebp]
  005f0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  005f3	89 55 fc	 mov	 DWORD PTR _oldproc$[ebp], edx

; 3110 : 		UninitializeCoolSB(hwnd);

  005f6	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  005f9	50		 push	 eax
  005fa	e8 00 00 00 00	 call	 _UninitializeCoolSB@4

; 3111 : 		
; 3112 : 		//we must call the original window procedure, otherwise it
; 3113 : 		//will never get the WM_NCDESTROY message, and it wouldn't
; 3114 : 		//be able to clean up etc.
; 3115 : 		return CallWindowProc(oldproc, hwnd, message, wParam, lParam);

  005ff	8b f4		 mov	 esi, esp
  00601	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00604	51		 push	 ecx
  00605	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00608	52		 push	 edx
  00609	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  0060c	50		 push	 eax
  0060d	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00610	51		 push	 ecx
  00611	8b 55 fc	 mov	 edx, DWORD PTR _oldproc$[ebp]
  00614	52		 push	 edx
  00615	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  0061b	3b f4		 cmp	 esi, esp
  0061d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00622	e9 39 02 00 00	 jmp	 $L23721
$L23731:

; 3116 : 
; 3117 : 	case WM_NCCALCSIZE:
; 3118 : 		return NCCalcSize(swnd, hwnd, wParam, lParam);

  00627	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0062a	50		 push	 eax
  0062b	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0062e	51		 push	 ecx
  0062f	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00632	52		 push	 edx
  00633	8b 45 f8	 mov	 eax, DWORD PTR _swnd$[ebp]
  00636	50		 push	 eax
  00637	e8 00 00 00 00	 call	 _NCCalcSize
  0063c	83 c4 10	 add	 esp, 16			; 00000010H
  0063f	e9 1c 02 00 00	 jmp	 $L23721
$L23732:

; 3119 : 
; 3120 : 	case WM_NCPAINT:
; 3121 : 		return NCPaint(swnd, hwnd, wParam, lParam);	

  00644	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00647	51		 push	 ecx
  00648	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  0064b	52		 push	 edx
  0064c	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0064f	50		 push	 eax
  00650	8b 4d f8	 mov	 ecx, DWORD PTR _swnd$[ebp]
  00653	51		 push	 ecx
  00654	e8 00 00 00 00	 call	 _NCPaint
  00659	83 c4 10	 add	 esp, 16			; 00000010H
  0065c	e9 ff 01 00 00	 jmp	 $L23721
$L23733:

; 3122 : 
; 3123 : 	case WM_NCHITTEST:
; 3124 : 		return NCHitTest(swnd, hwnd, wParam, lParam);

  00661	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  00664	52		 push	 edx
  00665	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00668	50		 push	 eax
  00669	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0066c	51		 push	 ecx
  0066d	8b 55 f8	 mov	 edx, DWORD PTR _swnd$[ebp]
  00670	52		 push	 edx
  00671	e8 00 00 00 00	 call	 _NCHitTest
  00676	83 c4 10	 add	 esp, 16			; 00000010H
  00679	e9 e2 01 00 00	 jmp	 $L23721
$L23734:

; 3125 : 
; 3126 : 	case WM_NCRBUTTONDOWN: case WM_NCRBUTTONUP: 
; 3127 : 	case WM_NCMBUTTONDOWN: case WM_NCMBUTTONUP: 
; 3128 : 		RelayMouseEvent(hwnd, swnd->hwndToolTip, (WM_MOUSEMOVE-WM_NCMOUSEMOVE) + (message));

  0067e	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00681	05 60 01 00 00	 add	 eax, 352		; 00000160H
  00686	50		 push	 eax
  00687	8b 4d f8	 mov	 ecx, DWORD PTR _swnd$[ebp]
  0068a	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  00690	52		 push	 edx
  00691	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00694	50		 push	 eax
  00695	e8 00 00 00 00	 call	 _RelayMouseEvent@12

; 3129 : 		if(wParam == HTHSCROLL || wParam == HTVSCROLL) 

  0069a	83 7d 10 06	 cmp	 DWORD PTR _wParam$[ebp], 6
  0069e	74 06		 je	 SHORT $L23736
  006a0	83 7d 10 07	 cmp	 DWORD PTR _wParam$[ebp], 7
  006a4	75 07		 jne	 SHORT $L23735
$L23736:

; 3130 : 			return 0;

  006a6	33 c0		 xor	 eax, eax
  006a8	e9 b3 01 00 00	 jmp	 $L23721
$L23735:

; 3131 : 		else 
; 3132 : 			break;

  006ad	e9 88 01 00 00	 jmp	 $L23727
$L23738:

; 3133 : 
; 3134 : 	case WM_NCLBUTTONDBLCLK:
; 3135 : 		//TRACE("WM_NCLBUTTONDBLCLK %d\n", count++);
; 3136 : 		if(wParam == HTHSCROLL || wParam == HTVSCROLL)

  006b2	83 7d 10 06	 cmp	 DWORD PTR _wParam$[ebp], 6
  006b6	74 06		 je	 SHORT $L23740
  006b8	83 7d 10 07	 cmp	 DWORD PTR _wParam$[ebp], 7
  006bc	75 1d		 jne	 SHORT $L23739
$L23740:

; 3137 : 			return NCLButtonDown(swnd, hwnd, wParam, lParam);

  006be	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  006c1	51		 push	 ecx
  006c2	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  006c5	52		 push	 edx
  006c6	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  006c9	50		 push	 eax
  006ca	8b 4d f8	 mov	 ecx, DWORD PTR _swnd$[ebp]
  006cd	51		 push	 ecx
  006ce	e8 00 00 00 00	 call	 _NCLButtonDown
  006d3	83 c4 10	 add	 esp, 16			; 00000010H
  006d6	e9 85 01 00 00	 jmp	 $L23721
$L23739:

; 3138 : 		else
; 3139 : 			break;

  006db	e9 5a 01 00 00	 jmp	 $L23727
$L23742:

; 3140 : 
; 3141 : 	case WM_NCLBUTTONDOWN:
; 3142 : 		//TRACE("WM_NCLBUTTONDOWN%d\n", count++);
; 3143 : 		RelayMouseEvent(hwnd, swnd->hwndToolTip, WM_LBUTTONDOWN);

  006e0	68 01 02 00 00	 push	 513			; 00000201H
  006e5	8b 55 f8	 mov	 edx, DWORD PTR _swnd$[ebp]
  006e8	8b 82 a8 06 00
	00		 mov	 eax, DWORD PTR [edx+1704]
  006ee	50		 push	 eax
  006ef	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  006f2	51		 push	 ecx
  006f3	e8 00 00 00 00	 call	 _RelayMouseEvent@12

; 3144 : 		return NCLButtonDown(swnd, hwnd, wParam, lParam);

  006f8	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  006fb	52		 push	 edx
  006fc	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  006ff	50		 push	 eax
  00700	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00703	51		 push	 ecx
  00704	8b 55 f8	 mov	 edx, DWORD PTR _swnd$[ebp]
  00707	52		 push	 edx
  00708	e8 00 00 00 00	 call	 _NCLButtonDown
  0070d	83 c4 10	 add	 esp, 16			; 00000010H
  00710	e9 4b 01 00 00	 jmp	 $L23721
$L23743:

; 3145 : 
; 3146 : 
; 3147 : 	case WM_LBUTTONUP:
; 3148 : 		//TRACE("WM_LBUTTONUP %d\n", count++);
; 3149 : 		RelayMouseEvent(hwnd, swnd->hwndToolTip, WM_LBUTTONUP);

  00715	68 02 02 00 00	 push	 514			; 00000202H
  0071a	8b 45 f8	 mov	 eax, DWORD PTR _swnd$[ebp]
  0071d	8b 88 a8 06 00
	00		 mov	 ecx, DWORD PTR [eax+1704]
  00723	51		 push	 ecx
  00724	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00727	52		 push	 edx
  00728	e8 00 00 00 00	 call	 _RelayMouseEvent@12

; 3150 : 		return LButtonUp(swnd, hwnd, wParam, lParam);

  0072d	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00730	50		 push	 eax
  00731	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00734	51		 push	 ecx
  00735	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00738	52		 push	 edx
  00739	8b 45 f8	 mov	 eax, DWORD PTR _swnd$[ebp]
  0073c	50		 push	 eax
  0073d	e8 00 00 00 00	 call	 _LButtonUp
  00742	83 c4 10	 add	 esp, 16			; 00000010H
  00745	e9 16 01 00 00	 jmp	 $L23721
$L23744:

; 3151 : 
; 3152 : 	case WM_NOTIFY:
; 3153 : 		return CoolSB_Notify(swnd, hwnd, wParam, lParam);

  0074a	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  0074d	51		 push	 ecx
  0074e	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00751	52		 push	 edx
  00752	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00755	50		 push	 eax
  00756	8b 4d f8	 mov	 ecx, DWORD PTR _swnd$[ebp]
  00759	51		 push	 ecx
  0075a	e8 00 00 00 00	 call	 _CoolSB_Notify
  0075f	83 c4 10	 add	 esp, 16			; 00000010H
  00762	e9 f9 00 00 00	 jmp	 $L23721
$L23745:

; 3154 : 
; 3155 : 	//Mouse moves are received when we set the mouse capture,
; 3156 : 	//even when the mouse moves over the non-client area
; 3157 : 	case WM_MOUSEMOVE: 
; 3158 : 		//TRACE("WM_MOUSEMOVE %d\n", count++);
; 3159 : 		return MouseMove(swnd, hwnd, wParam, lParam);

  00767	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0076a	52		 push	 edx
  0076b	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0076e	50		 push	 eax
  0076f	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00772	51		 push	 ecx
  00773	8b 55 f8	 mov	 edx, DWORD PTR _swnd$[ebp]
  00776	52		 push	 edx
  00777	e8 00 00 00 00	 call	 _MouseMove
  0077c	83 c4 10	 add	 esp, 16			; 00000010H
  0077f	e9 dc 00 00 00	 jmp	 $L23721
$L23746:

; 3160 : 	
; 3161 : 	case WM_TIMER:
; 3162 : 		return CoolSB_Timer(swnd, hwnd, wParam, lParam);

  00784	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00787	50		 push	 eax
  00788	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0078b	51		 push	 ecx
  0078c	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0078f	52		 push	 edx
  00790	8b 45 f8	 mov	 eax, DWORD PTR _swnd$[ebp]
  00793	50		 push	 eax
  00794	e8 00 00 00 00	 call	 _CoolSB_Timer
  00799	83 c4 10	 add	 esp, 16			; 00000010H
  0079c	e9 bf 00 00 00	 jmp	 $L23721
$L23747:

; 3163 : 
; 3164 : 	//case WM_STYLECHANGING:
; 3165 : 	//	return CoolSB_StyleChange(swnd, hwnd, WM_STYLECHANGING, wParam, lParam);
; 3166 : 	case WM_STYLECHANGED:
; 3167 : 
; 3168 : 		if(swnd->bPreventStyleChange)

  007a1	8b 4d f8	 mov	 ecx, DWORD PTR _swnd$[ebp]
  007a4	83 b9 bc 06 00
	00 00		 cmp	 DWORD PTR [ecx+1724], 0
  007ab	74 07		 je	 SHORT $L23748

; 3169 : 		{
; 3170 : 			// the NCPAINT handler has told us to eat this message!
; 3171 : 			return 0;

  007ad	33 c0		 xor	 eax, eax
  007af	e9 ac 00 00 00	 jmp	 $L23721
$L23748:

; 3172 : 		}
; 3173 : 		else
; 3174 : 		{
; 3175 :             if (message == WM_STYLECHANGED) 

  007b4	83 7d 0c 7d	 cmp	 DWORD PTR _message$[ebp], 125 ; 0000007dH
  007b8	75 1f		 jne	 SHORT $L23750

; 3176 : 				return CoolSB_StyleChange(swnd, hwnd, WM_STYLECHANGED, wParam, lParam);

  007ba	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  007bd	52		 push	 edx
  007be	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  007c1	50		 push	 eax
  007c2	6a 7d		 push	 125			; 0000007dH
  007c4	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  007c7	51		 push	 ecx
  007c8	8b 55 f8	 mov	 edx, DWORD PTR _swnd$[ebp]
  007cb	52		 push	 edx
  007cc	e8 00 00 00 00	 call	 _CoolSB_StyleChange
  007d1	83 c4 14	 add	 esp, 20			; 00000014H
  007d4	e9 87 00 00 00	 jmp	 $L23721
$L23750:

; 3177 : 			else
; 3178 : 				break;

  007d9	eb 5f		 jmp	 SHORT $L23727
$L23752:

; 3179 : 		}
; 3180 : 
; 3181 : 	case WM_NCMOUSEMOVE: 
; 3182 : 		{
; 3183 : 			static LONG lastpos = -1;
; 3184 : 
; 3185 : 			//TRACE("WM_NCMOUSEMOVE %d\n", count++);
; 3186 : 
; 3187 : 			//The problem with NCMOUSEMOVE is that it is sent continuously
; 3188 : 			//even when the mouse is stationary (under win2000 / win98)
; 3189 : 			//
; 3190 : 			//Tooltips don't like being sent a continous stream of mouse-moves
; 3191 : 			//if the cursor isn't moving, because they will think that the mouse
; 3192 : 			//is moving position, and the internal timer will never expire
; 3193 : 			//
; 3194 : 			if(lastpos != lParam)

  007db	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lastpos@?5??CoolSBWndProc@@9@9
  007e0	3b 45 14	 cmp	 eax, DWORD PTR _lParam$[ebp]
  007e3	74 21		 je	 SHORT $L23755

; 3195 : 			{
; 3196 : #pragma warning( disable: 4244)	
; 3197 : 				RelayMouseEvent(hwnd, swnd->hwndToolTip, WM_MOUSEMOVE);

  007e5	68 00 02 00 00	 push	 512			; 00000200H
  007ea	8b 4d f8	 mov	 ecx, DWORD PTR _swnd$[ebp]
  007ed	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  007f3	52		 push	 edx
  007f4	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  007f7	50		 push	 eax
  007f8	e8 00 00 00 00	 call	 _RelayMouseEvent@12

; 3198 : 				lastpos = lParam;

  007fd	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00800	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lastpos@?5??CoolSBWndProc@@9@9, ecx
$L23755:

; 3199 : #pragma warning( default: 4244)	
; 3200 : 			}
; 3201 : 		}
; 3202 : 
; 3203 : 		return NCMouseMove(swnd, hwnd, wParam, lParam);

  00806	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  00809	52		 push	 edx
  0080a	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  0080d	50		 push	 eax
  0080e	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00811	51		 push	 ecx
  00812	8b 55 f8	 mov	 edx, DWORD PTR _swnd$[ebp]
  00815	52		 push	 edx
  00816	e8 00 00 00 00	 call	 _NCMouseMove
  0081b	83 c4 10	 add	 esp, 16			; 00000010H
  0081e	eb 40		 jmp	 SHORT $L23721
$L23756:

; 3204 : 
; 3205 : 
; 3206 : 	case WM_SETCURSOR:
; 3207 : 		return CoolSB_SetCursor(swnd, hwnd, wParam, lParam);

  00820	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00823	50		 push	 eax
  00824	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00827	51		 push	 ecx
  00828	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0082b	52		 push	 edx
  0082c	8b 45 f8	 mov	 eax, DWORD PTR _swnd$[ebp]
  0082f	50		 push	 eax
  00830	e8 00 00 00 00	 call	 _CoolSB_SetCursor
  00835	83 c4 10	 add	 esp, 16			; 00000010H
  00838	eb 26		 jmp	 SHORT $L23721
$L23727:

; 3208 : 	case WM_CAPTURECHANGED:
; 3209 : 		break;
; 3210 : 
; 3211 : 	default:
; 3212 : 		break;
; 3213 : 	}
; 3214 : 	
; 3215 : 	return CallWindowProc(swnd->oldproc, hwnd, message, wParam, lParam);

  0083a	8b f4		 mov	 esi, esp
  0083c	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  0083f	51		 push	 ecx
  00840	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00843	52		 push	 edx
  00844	8b 45 0c	 mov	 eax, DWORD PTR _message$[ebp]
  00847	50		 push	 eax
  00848	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0084b	51		 push	 ecx
  0084c	8b 55 f8	 mov	 edx, DWORD PTR _swnd$[ebp]
  0084f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00852	50		 push	 eax
  00853	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  00859	3b f4		 cmp	 esi, esp
  0085b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23721:

; 3216 : }

  00860	5e		 pop	 esi
  00861	83 c4 0c	 add	 esp, 12			; 0000000cH
  00864	3b ec		 cmp	 ebp, esp
  00866	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0086b	8b e5		 mov	 esp, ebp
  0086d	5d		 pop	 ebp
  0086e	c2 10 00	 ret	 16			; 00000010H
$L23892:
  00871	00 00 00 00	 DD	 $L23756
  00875	00 00 00 00	 DD	 $L23744
  00879	00 00 00 00	 DD	 $L23747
  0087d	00 00 00 00	 DD	 $L23730
  00881	00 00 00 00	 DD	 $L23731
  00885	00 00 00 00	 DD	 $L23733
  00889	00 00 00 00	 DD	 $L23732
  0088d	00 00 00 00	 DD	 $L23727
$L23891:
  00891	00		 DB	 0
  00892	07		 DB	 7
  00893	07		 DB	 7
  00894	07		 DB	 7
  00895	07		 DB	 7
  00896	07		 DB	 7
  00897	07		 DB	 7
  00898	07		 DB	 7
  00899	07		 DB	 7
  0089a	07		 DB	 7
  0089b	07		 DB	 7
  0089c	07		 DB	 7
  0089d	07		 DB	 7
  0089e	07		 DB	 7
  0089f	07		 DB	 7
  008a0	07		 DB	 7
  008a1	07		 DB	 7
  008a2	07		 DB	 7
  008a3	07		 DB	 7
  008a4	07		 DB	 7
  008a5	07		 DB	 7
  008a6	07		 DB	 7
  008a7	07		 DB	 7
  008a8	07		 DB	 7
  008a9	07		 DB	 7
  008aa	07		 DB	 7
  008ab	07		 DB	 7
  008ac	07		 DB	 7
  008ad	07		 DB	 7
  008ae	07		 DB	 7
  008af	07		 DB	 7
  008b0	07		 DB	 7
  008b1	07		 DB	 7
  008b2	07		 DB	 7
  008b3	07		 DB	 7
  008b4	07		 DB	 7
  008b5	07		 DB	 7
  008b6	07		 DB	 7
  008b7	07		 DB	 7
  008b8	07		 DB	 7
  008b9	07		 DB	 7
  008ba	07		 DB	 7
  008bb	07		 DB	 7
  008bc	07		 DB	 7
  008bd	07		 DB	 7
  008be	07		 DB	 7
  008bf	01		 DB	 1
  008c0	07		 DB	 7
  008c1	07		 DB	 7
  008c2	07		 DB	 7
  008c3	07		 DB	 7
  008c4	07		 DB	 7
  008c5	07		 DB	 7
  008c6	07		 DB	 7
  008c7	07		 DB	 7
  008c8	07		 DB	 7
  008c9	07		 DB	 7
  008ca	07		 DB	 7
  008cb	07		 DB	 7
  008cc	07		 DB	 7
  008cd	07		 DB	 7
  008ce	07		 DB	 7
  008cf	07		 DB	 7
  008d0	07		 DB	 7
  008d1	07		 DB	 7
  008d2	07		 DB	 7
  008d3	07		 DB	 7
  008d4	07		 DB	 7
  008d5	07		 DB	 7
  008d6	07		 DB	 7
  008d7	07		 DB	 7
  008d8	07		 DB	 7
  008d9	07		 DB	 7
  008da	07		 DB	 7
  008db	07		 DB	 7
  008dc	07		 DB	 7
  008dd	07		 DB	 7
  008de	07		 DB	 7
  008df	07		 DB	 7
  008e0	07		 DB	 7
  008e1	07		 DB	 7
  008e2	07		 DB	 7
  008e3	07		 DB	 7
  008e4	07		 DB	 7
  008e5	07		 DB	 7
  008e6	07		 DB	 7
  008e7	07		 DB	 7
  008e8	07		 DB	 7
  008e9	07		 DB	 7
  008ea	07		 DB	 7
  008eb	07		 DB	 7
  008ec	07		 DB	 7
  008ed	07		 DB	 7
  008ee	02		 DB	 2
  008ef	07		 DB	 7
  008f0	07		 DB	 7
  008f1	07		 DB	 7
  008f2	07		 DB	 7
  008f3	03		 DB	 3
  008f4	04		 DB	 4
  008f5	05		 DB	 5
  008f6	06		 DB	 6
$L23893:
  008f7	00 00 00 00	 DD	 $L23742
  008fb	00 00 00 00	 DD	 $L23727
  008ff	00 00 00 00	 DD	 $L23738
  00903	00 00 00 00	 DD	 $L23734
  00907	00 00 00 00	 DD	 $L23734
_CoolSBWndProc@16 ENDP
_TEXT	ENDS
EXTRN	__imp__GetClientRect@8:NEAR
EXTRN	__imp__MapWindowPoints@16:NEAR
EXTRN	__imp__GetSysColor@4:NEAR
EXTRN	__imp__CopyRect@8:NEAR
EXTRN	__imp__OffsetRect@12:NEAR
EXTRN	__imp__GetWindowLongA@8:NEAR
EXTRN	__imp__SetWindowLongA@12:NEAR
EXTRN	__imp__GetParent@4:NEAR
EXTRN	__imp__ReleaseDC@8:NEAR
EXTRN	__imp__DrawFrameControl@16:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hwndParent$23094 = -148				; size = 4
_rect2$23093 = -140					; size = 16
_parent$23092 = -116					; size = 16
_updown$23077 = -96					; size = 4
_vbarheight$23076 = -92					; size = 4
_leftright$23068 = -88					; size = 4
_hbarwidth$23067 = -84					; size = 4
_dwStyle$ = -80						; size = 4
_ret$ = -76						; size = 4
_fCustomDraw$ = -72					; size = 4
_fUpdateAll$ = -68					; size = 4
_rect$ = -56						; size = 16
_winrect$ = -32						; size = 16
_hrgn$ = -12						; size = 4
_hdc$ = -8						; size = 4
_sb$ = -4						; size = 4
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCPaint PROC NEAR

; 1413 : {

  00910	55		 push	 ebp
  00911	8b ec		 mov	 ebp, esp
  00913	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00919	56		 push	 esi
  0091a	57		 push	 edi
  0091b	8d bd 6c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-148]
  00921	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  00926	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0092b	f3 ab		 rep stosd

; 1414 : 	SCROLLBAR *sb;
; 1415 : 	HDC hdc;
; 1416 : 	HRGN hrgn;
; 1417 : 	RECT winrect, rect;
; 1418 : 	HRGN clip;
; 1419 : 	BOOL fUpdateAll = ((LONG)wParam == 1);

  0092d	33 c0		 xor	 eax, eax
  0092f	83 7d 10 01	 cmp	 DWORD PTR _wParam$[ebp], 1
  00933	0f 94 c0	 sete	 al
  00936	89 45 bc	 mov	 DWORD PTR _fUpdateAll$[ebp], eax

; 1420 : 	BOOL fCustomDraw = FALSE;

  00939	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _fCustomDraw$[ebp], 0

; 1421 : 	LRESULT ret;
; 1422 : 	DWORD dwStyle;
; 1423 : 
; 1424 : 	GetWindowRect(hwnd, &winrect);

  00940	8b f4		 mov	 esi, esp
  00942	8d 4d e0	 lea	 ecx, DWORD PTR _winrect$[ebp]
  00945	51		 push	 ecx
  00946	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00949	52		 push	 edx
  0094a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00950	3b f4		 cmp	 esi, esp
  00952	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1425 : 	
; 1426 : 	//if entire region needs painting, then make a region to cover the entire window
; 1427 : 	if(fUpdateAll)

  00957	83 7d bc 00	 cmp	 DWORD PTR _fUpdateAll$[ebp], 0
  0095b	74 08		 je	 SHORT $L23062

; 1428 : 		hrgn = (HRGN)wParam;

  0095d	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00960	89 45 f4	 mov	 DWORD PTR _hrgn$[ebp], eax

; 1429 : 	else

  00963	eb 06		 jmp	 SHORT $L23064
$L23062:

; 1430 : 		hrgn = (HRGN)wParam;

  00965	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00968	89 4d f4	 mov	 DWORD PTR _hrgn$[ebp], ecx
$L23064:

; 1431 : 	
; 1432 : 	//hdc = GetWindowDC(hwnd);
; 1433 : 	hdc = CoolSB_GetDC(hwnd, wParam);

  0096b	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  0096e	52		 push	 edx
  0096f	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00972	50		 push	 eax
  00973	e8 00 00 00 00	 call	 _CoolSB_GetDC
  00978	83 c4 08	 add	 esp, 8
  0097b	89 45 f8	 mov	 DWORD PTR _hdc$[ebp], eax

; 1434 : 
; 1435 : 	//
; 1436 : 	//	Only draw the horizontal scrollbar if the window is tall enough
; 1437 : 	//
; 1438 : 	sb = &sw->sbarHorz;

  0097e	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00981	83 c1 08	 add	 ecx, 8
  00984	89 4d fc	 mov	 DWORD PTR _sb$[ebp], ecx

; 1439 : 	if(sb->fScrollVisible)

  00987	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  0098a	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0098e	0f 84 7c 01 00
	00		 je	 $L23066

; 1440 : 	{
; 1441 : 		int hbarwidth = 0, leftright = 0;

  00994	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _hbarwidth$23067[ebp], 0
  0099b	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _leftright$23068[ebp], 0

; 1442 : 
; 1443 : 		//get the screen coordinates of the whole horizontal scrollbar area
; 1444 : 		GetHScrollRect(sw, hwnd, &rect);

  009a2	8d 45 c8	 lea	 eax, DWORD PTR _rect$[ebp]
  009a5	50		 push	 eax
  009a6	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  009a9	51		 push	 ecx
  009aa	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  009ad	52		 push	 edx
  009ae	e8 00 00 00 00	 call	 _GetHScrollRect
  009b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1445 : 
; 1446 : 		//make the coordinates relative to the window for drawing
; 1447 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  009b6	8b 45 e4	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  009b9	f7 d8		 neg	 eax
  009bb	8b f4		 mov	 esi, esp
  009bd	50		 push	 eax
  009be	8b 4d e0	 mov	 ecx, DWORD PTR _winrect$[ebp]
  009c1	f7 d9		 neg	 ecx
  009c3	51		 push	 ecx
  009c4	8d 55 c8	 lea	 edx, DWORD PTR _rect$[ebp]
  009c7	52		 push	 edx
  009c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  009ce	3b f4		 cmp	 esi, esp
  009d0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1448 : 
; 1449 : #ifdef INCLUDE_BUTTONS
; 1450 : 
; 1451 : 		//work out the size of any inserted buttons so we can dra them
; 1452 : 		sb->nButSizeBefore  = GetButtonSize(sb, hwnd, SBBP_LEFT);

  009d5	6a 01		 push	 1
  009d7	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  009da	50		 push	 eax
  009db	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  009de	51		 push	 ecx
  009df	e8 00 00 00 00	 call	 _GetButtonSize
  009e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  009e7	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  009ea	89 82 30 03 00
	00		 mov	 DWORD PTR [edx+816], eax

; 1453 : 		sb->nButSizeAfter   = GetButtonSize(sb, hwnd, SBBP_RIGHT);

  009f0	6a 02		 push	 2
  009f2	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  009f5	50		 push	 eax
  009f6	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  009f9	51		 push	 ecx
  009fa	e8 00 00 00 00	 call	 _GetButtonSize
  009ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a02	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  00a05	89 82 34 03 00
	00		 mov	 DWORD PTR [edx+820], eax

; 1454 : 
; 1455 : 		//make sure there is room for the buttons
; 1456 : 		hbarwidth = rect.right - rect.left;

  00a0b	8b 45 d0	 mov	 eax, DWORD PTR _rect$[ebp+8]
  00a0e	2b 45 c8	 sub	 eax, DWORD PTR _rect$[ebp]
  00a11	89 45 ac	 mov	 DWORD PTR _hbarwidth$23067[ebp], eax

; 1457 : 
; 1458 : 		//check that we can fit any left/right buttons in the available space
; 1459 : 		if(sb->nButSizeAfter < (hbarwidth - MIN_COOLSB_SIZE))

  00a14	8b 4d ac	 mov	 ecx, DWORD PTR _hbarwidth$23067[ebp]
  00a17	83 e9 18	 sub	 ecx, 24			; 00000018H
  00a1a	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  00a1d	39 8a 34 03 00
	00		 cmp	 DWORD PTR [edx+820], ecx
  00a23	7d 77		 jge	 SHORT $L23069

; 1460 : 		{
; 1461 : 			//adjust the scrollbar rectangle to fit the buttons into
; 1462 : 			sb->fButVisibleAfter = TRUE;

  00a25	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00a28	c7 80 3c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+828], 1

; 1463 : 			rect.right -= sb->nButSizeAfter;

  00a32	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00a35	8b 55 d0	 mov	 edx, DWORD PTR _rect$[ebp+8]
  00a38	2b 91 34 03 00
	00		 sub	 edx, DWORD PTR [ecx+820]
  00a3e	89 55 d0	 mov	 DWORD PTR _rect$[ebp+8], edx

; 1464 : 			leftright |= SBBP_RIGHT;

  00a41	8b 45 a8	 mov	 eax, DWORD PTR _leftright$23068[ebp]
  00a44	83 c8 02	 or	 eax, 2
  00a47	89 45 a8	 mov	 DWORD PTR _leftright$23068[ebp], eax

; 1465 : 			
; 1466 : 			//check that there is enough space for the right buttons
; 1467 : 			if(sb->nButSizeBefore + sb->nButSizeAfter < (hbarwidth - MIN_COOLSB_SIZE))

  00a4a	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00a4d	8b 91 30 03 00
	00		 mov	 edx, DWORD PTR [ecx+816]
  00a53	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00a56	03 90 34 03 00
	00		 add	 edx, DWORD PTR [eax+820]
  00a5c	8b 4d ac	 mov	 ecx, DWORD PTR _hbarwidth$23067[ebp]
  00a5f	83 e9 18	 sub	 ecx, 24			; 00000018H
  00a62	3b d1		 cmp	 edx, ecx
  00a64	7d 27		 jge	 SHORT $L23070

; 1468 : 			{
; 1469 : 				sb->fButVisibleBefore = TRUE;

  00a66	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  00a69	c7 82 38 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+824], 1

; 1470 : 				rect.left += sb->nButSizeBefore;

  00a73	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00a76	8b 4d c8	 mov	 ecx, DWORD PTR _rect$[ebp]
  00a79	03 88 30 03 00
	00		 add	 ecx, DWORD PTR [eax+816]
  00a7f	89 4d c8	 mov	 DWORD PTR _rect$[ebp], ecx

; 1471 : 				leftright |= SBBP_LEFT;

  00a82	8b 55 a8	 mov	 edx, DWORD PTR _leftright$23068[ebp]
  00a85	83 ca 01	 or	 edx, 1
  00a88	89 55 a8	 mov	 DWORD PTR _leftright$23068[ebp], edx

; 1472 : 			}
; 1473 : 			else

  00a8b	eb 0d		 jmp	 SHORT $L23071
$L23070:

; 1474 : 				sb->fButVisibleBefore = FALSE;

  00a8d	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00a90	c7 80 38 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+824], 0
$L23071:

; 1475 : 		}	
; 1476 : 		else

  00a9a	eb 0d		 jmp	 SHORT $L23072
$L23069:

; 1477 : 			sb->fButVisibleAfter = FALSE;

  00a9c	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00a9f	c7 81 3c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+828], 0
$L23072:

; 1478 : 		
; 1479 : 		
; 1480 : 		DrawHorzButtons(sb, hdc, &rect, leftright);

  00aa9	8b 55 a8	 mov	 edx, DWORD PTR _leftright$23068[ebp]
  00aac	52		 push	 edx
  00aad	8d 45 c8	 lea	 eax, DWORD PTR _rect$[ebp]
  00ab0	50		 push	 eax
  00ab1	8b 4d f8	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00ab4	51		 push	 ecx
  00ab5	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  00ab8	52		 push	 edx
  00ab9	e8 00 00 00 00	 call	 _DrawHorzButtons
  00abe	83 c4 10	 add	 esp, 16			; 00000010H

; 1481 : #endif// INCLUDE_BUTTONS		
; 1482 : 
; 1483 : 		if(uCurrentScrollbar == SB_HORZ)

  00ac1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  00ac8	75 26		 jne	 SHORT $L23073

; 1484 : 			fCustomDraw |= NCDrawHScrollbar(sb, hwnd, hdc, &rect, uScrollTimerPortion);

  00aca	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerPortion
  00acf	50		 push	 eax
  00ad0	8d 4d c8	 lea	 ecx, DWORD PTR _rect$[ebp]
  00ad3	51		 push	 ecx
  00ad4	8b 55 f8	 mov	 edx, DWORD PTR _hdc$[ebp]
  00ad7	52		 push	 edx
  00ad8	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00adb	50		 push	 eax
  00adc	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00adf	51		 push	 ecx
  00ae0	e8 00 00 00 00	 call	 _NCDrawHScrollbar
  00ae5	83 c4 14	 add	 esp, 20			; 00000014H
  00ae8	0b 45 b8	 or	 eax, DWORD PTR _fCustomDraw$[ebp]
  00aeb	89 45 b8	 mov	 DWORD PTR _fCustomDraw$[ebp], eax

; 1485 : 		else

  00aee	eb 20		 jmp	 SHORT $L23066
$L23073:

; 1486 : 			fCustomDraw |= NCDrawHScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_NONE);

  00af0	6a ff		 push	 -1
  00af2	8d 55 c8	 lea	 edx, DWORD PTR _rect$[ebp]
  00af5	52		 push	 edx
  00af6	8b 45 f8	 mov	 eax, DWORD PTR _hdc$[ebp]
  00af9	50		 push	 eax
  00afa	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00afd	51		 push	 ecx
  00afe	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  00b01	52		 push	 edx
  00b02	e8 00 00 00 00	 call	 _NCDrawHScrollbar
  00b07	83 c4 14	 add	 esp, 20			; 00000014H
  00b0a	0b 45 b8	 or	 eax, DWORD PTR _fCustomDraw$[ebp]
  00b0d	89 45 b8	 mov	 DWORD PTR _fCustomDraw$[ebp], eax
$L23066:

; 1487 : 	}
; 1488 : 
; 1489 : 	//
; 1490 : 	// Only draw the vertical scrollbar if the window is wide enough to accomodate it
; 1491 : 	//
; 1492 : 	sb = &sw->sbarVert;

  00b10	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00b13	05 54 03 00 00	 add	 eax, 852		; 00000354H
  00b18	89 45 fc	 mov	 DWORD PTR _sb$[ebp], eax

; 1493 : 	if(sb->fScrollVisible)

  00b1b	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00b1e	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00b22	0f 84 7d 01 00
	00		 je	 $L23075

; 1494 : 	{
; 1495 : 		int vbarheight = 0, updown = 0;

  00b28	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _vbarheight$23076[ebp], 0
  00b2f	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _updown$23077[ebp], 0

; 1496 : 
; 1497 : 		//get the screen cooridinates of the whole horizontal scrollbar area
; 1498 : 		GetVScrollRect(sw, hwnd, &rect);

  00b36	8d 55 c8	 lea	 edx, DWORD PTR _rect$[ebp]
  00b39	52		 push	 edx
  00b3a	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00b3d	50		 push	 eax
  00b3e	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00b41	51		 push	 ecx
  00b42	e8 00 00 00 00	 call	 _GetVScrollRect
  00b47	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1499 : 
; 1500 : 		//make the coordinates relative to the window for drawing
; 1501 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  00b4a	8b 55 e4	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  00b4d	f7 da		 neg	 edx
  00b4f	8b f4		 mov	 esi, esp
  00b51	52		 push	 edx
  00b52	8b 45 e0	 mov	 eax, DWORD PTR _winrect$[ebp]
  00b55	f7 d8		 neg	 eax
  00b57	50		 push	 eax
  00b58	8d 4d c8	 lea	 ecx, DWORD PTR _rect$[ebp]
  00b5b	51		 push	 ecx
  00b5c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  00b62	3b f4		 cmp	 esi, esp
  00b64	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1502 : 
; 1503 : #ifdef INCLUDE_BUTTONS
; 1504 : 
; 1505 : 		//work out the size of any inserted buttons so we can dra them
; 1506 : 		sb->nButSizeBefore  = GetButtonSize(sb, hwnd, SBBP_LEFT);

  00b69	6a 01		 push	 1
  00b6b	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00b6e	52		 push	 edx
  00b6f	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00b72	50		 push	 eax
  00b73	e8 00 00 00 00	 call	 _GetButtonSize
  00b78	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b7b	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00b7e	89 81 30 03 00
	00		 mov	 DWORD PTR [ecx+816], eax

; 1507 : 		sb->nButSizeAfter   = GetButtonSize(sb, hwnd, SBBP_RIGHT);

  00b84	6a 02		 push	 2
  00b86	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00b89	52		 push	 edx
  00b8a	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00b8d	50		 push	 eax
  00b8e	e8 00 00 00 00	 call	 _GetButtonSize
  00b93	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b96	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00b99	89 81 34 03 00
	00		 mov	 DWORD PTR [ecx+820], eax

; 1508 : 
; 1509 : 		//make sure there is room for the buttons
; 1510 : 		vbarheight = rect.bottom - rect.top;

  00b9f	8b 55 d4	 mov	 edx, DWORD PTR _rect$[ebp+12]
  00ba2	2b 55 cc	 sub	 edx, DWORD PTR _rect$[ebp+4]
  00ba5	89 55 a4	 mov	 DWORD PTR _vbarheight$23076[ebp], edx

; 1511 : 
; 1512 : 		//check that we can fit any left/right buttons in the available space
; 1513 : 		if(sb->nButSizeAfter < (vbarheight - MIN_COOLSB_SIZE))

  00ba8	8b 45 a4	 mov	 eax, DWORD PTR _vbarheight$23076[ebp]
  00bab	83 e8 18	 sub	 eax, 24			; 00000018H
  00bae	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00bb1	39 81 34 03 00
	00		 cmp	 DWORD PTR [ecx+820], eax
  00bb7	7d 77		 jge	 SHORT $L23078

; 1514 : 		{
; 1515 : 			//adjust the scrollbar rectangle to fit the buttons into
; 1516 : 			sb->fButVisibleAfter = TRUE;

  00bb9	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  00bbc	c7 82 3c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+828], 1

; 1517 : 			rect.bottom -= sb->nButSizeAfter;

  00bc6	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00bc9	8b 4d d4	 mov	 ecx, DWORD PTR _rect$[ebp+12]
  00bcc	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  00bd2	89 4d d4	 mov	 DWORD PTR _rect$[ebp+12], ecx

; 1518 : 			updown |= SBBP_BOTTOM;

  00bd5	8b 55 a0	 mov	 edx, DWORD PTR _updown$23077[ebp]
  00bd8	83 ca 02	 or	 edx, 2
  00bdb	89 55 a0	 mov	 DWORD PTR _updown$23077[ebp], edx

; 1519 : 			
; 1520 : 			//check that there is enough space for the right buttons
; 1521 : 			if(sb->nButSizeBefore + sb->nButSizeAfter < (vbarheight - MIN_COOLSB_SIZE))

  00bde	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00be1	8b 88 30 03 00
	00		 mov	 ecx, DWORD PTR [eax+816]
  00be7	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  00bea	03 8a 34 03 00
	00		 add	 ecx, DWORD PTR [edx+820]
  00bf0	8b 45 a4	 mov	 eax, DWORD PTR _vbarheight$23076[ebp]
  00bf3	83 e8 18	 sub	 eax, 24			; 00000018H
  00bf6	3b c8		 cmp	 ecx, eax
  00bf8	7d 27		 jge	 SHORT $L23079

; 1522 : 			{
; 1523 : 				sb->fButVisibleBefore = TRUE;

  00bfa	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00bfd	c7 81 38 03 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+824], 1

; 1524 : 				rect.top += sb->nButSizeBefore;

  00c07	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  00c0a	8b 45 cc	 mov	 eax, DWORD PTR _rect$[ebp+4]
  00c0d	03 82 30 03 00
	00		 add	 eax, DWORD PTR [edx+816]
  00c13	89 45 cc	 mov	 DWORD PTR _rect$[ebp+4], eax

; 1525 : 				updown |= SBBP_TOP;

  00c16	8b 4d a0	 mov	 ecx, DWORD PTR _updown$23077[ebp]
  00c19	83 c9 01	 or	 ecx, 1
  00c1c	89 4d a0	 mov	 DWORD PTR _updown$23077[ebp], ecx

; 1526 : 			}
; 1527 : 			else

  00c1f	eb 0d		 jmp	 SHORT $L23080
$L23079:

; 1528 : 				sb->fButVisibleBefore = FALSE;

  00c21	8b 55 fc	 mov	 edx, DWORD PTR _sb$[ebp]
  00c24	c7 82 38 03 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+824], 0
$L23080:

; 1529 : 		}	
; 1530 : 		else

  00c2e	eb 0d		 jmp	 SHORT $L23081
$L23078:

; 1531 : 			sb->fButVisibleAfter = FALSE;

  00c30	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00c33	c7 80 3c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+828], 0
$L23081:

; 1532 : 		
; 1533 : 	
; 1534 : 		DrawVertButtons(sb, hdc, &rect, updown);

  00c3d	8b 4d a0	 mov	 ecx, DWORD PTR _updown$23077[ebp]
  00c40	51		 push	 ecx
  00c41	8d 55 c8	 lea	 edx, DWORD PTR _rect$[ebp]
  00c44	52		 push	 edx
  00c45	8b 45 f8	 mov	 eax, DWORD PTR _hdc$[ebp]
  00c48	50		 push	 eax
  00c49	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00c4c	51		 push	 ecx
  00c4d	e8 00 00 00 00	 call	 _DrawVertButtons
  00c52	83 c4 10	 add	 esp, 16			; 00000010H

; 1535 : #endif // INCLUDE_BUTTONS
; 1536 : 
; 1537 : 		if(uCurrentScrollbar == SB_VERT)

  00c55	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uCurrentScrollbar, 1
  00c5c	75 27		 jne	 SHORT $L23082

; 1538 : 			fCustomDraw |= NCDrawVScrollbar(sb, hwnd, hdc, &rect, uScrollTimerPortion);

  00c5e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uScrollTimerPortion
  00c64	52		 push	 edx
  00c65	8d 45 c8	 lea	 eax, DWORD PTR _rect$[ebp]
  00c68	50		 push	 eax
  00c69	8b 4d f8	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00c6c	51		 push	 ecx
  00c6d	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00c70	52		 push	 edx
  00c71	8b 45 fc	 mov	 eax, DWORD PTR _sb$[ebp]
  00c74	50		 push	 eax
  00c75	e8 00 00 00 00	 call	 _NCDrawVScrollbar
  00c7a	83 c4 14	 add	 esp, 20			; 00000014H
  00c7d	0b 45 b8	 or	 eax, DWORD PTR _fCustomDraw$[ebp]
  00c80	89 45 b8	 mov	 DWORD PTR _fCustomDraw$[ebp], eax

; 1539 : 		else

  00c83	eb 20		 jmp	 SHORT $L23075
$L23082:

; 1540 : 			fCustomDraw |= NCDrawVScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_NONE);

  00c85	6a ff		 push	 -1
  00c87	8d 4d c8	 lea	 ecx, DWORD PTR _rect$[ebp]
  00c8a	51		 push	 ecx
  00c8b	8b 55 f8	 mov	 edx, DWORD PTR _hdc$[ebp]
  00c8e	52		 push	 edx
  00c8f	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00c92	50		 push	 eax
  00c93	8b 4d fc	 mov	 ecx, DWORD PTR _sb$[ebp]
  00c96	51		 push	 ecx
  00c97	e8 00 00 00 00	 call	 _NCDrawVScrollbar
  00c9c	83 c4 14	 add	 esp, 20			; 00000014H
  00c9f	0b 45 b8	 or	 eax, DWORD PTR _fCustomDraw$[ebp]
  00ca2	89 45 b8	 mov	 DWORD PTR _fCustomDraw$[ebp], eax
$L23075:

; 1541 : 	}
; 1542 : 
; 1543 : 	//Call the default window procedure for WM_NCPAINT, with the
; 1544 : 	//new window region. ** region must be in SCREEN coordinates **
; 1545 : 	dwStyle = GetWindowLong(hwnd, GWL_STYLE);

  00ca5	8b f4		 mov	 esi, esp
  00ca7	6a f0		 push	 -16			; fffffff0H
  00ca9	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00cac	52		 push	 edx
  00cad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  00cb3	3b f4		 cmp	 esi, esp
  00cb5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00cba	89 45 b0	 mov	 DWORD PTR _dwStyle$[ebp], eax

; 1546 : 
; 1547 :     // If the window has WS_(H-V)SCROLL bits set, we should reset them
; 1548 :     // to avoid windows taking the scrollbars into account.
; 1549 :     // We temporarily set a flag preventing the subsecuent 
; 1550 :     // WM_STYLECHANGING/WM_STYLECHANGED to be forwarded to 
; 1551 :     // the original window procedure
; 1552 :     if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )

  00cbd	8b 45 b0	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  00cc0	25 00 00 30 00	 and	 eax, 3145728		; 00300000H
  00cc5	74 2c		 je	 SHORT $L23084

; 1553 :     {
; 1554 :         sw->bPreventStyleChange = TRUE;

  00cc7	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00cca	c7 81 bc 06 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+1724], 1

; 1555 :         SetWindowLong(hwnd, GWL_STYLE, dwStyle & ~(WS_VSCROLL|WS_HSCROLL));

  00cd4	8b 55 b0	 mov	 edx, DWORD PTR _dwStyle$[ebp]
  00cd7	81 e2 ff ff cf
	ff		 and	 edx, -3145729		; ffcfffffH
  00cdd	8b f4		 mov	 esi, esp
  00cdf	52		 push	 edx
  00ce0	6a f0		 push	 -16			; fffffff0H
  00ce2	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00ce5	50		 push	 eax
  00ce6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12
  00cec	3b f4		 cmp	 esi, esp
  00cee	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23084:

; 1556 :     }
; 1557 : 	
; 1558 : 	ret = CallWindowProc(sw->oldproc, hwnd, WM_NCPAINT, (WPARAM)hrgn, lParam);

  00cf3	8b f4		 mov	 esi, esp
  00cf5	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00cf8	51		 push	 ecx
  00cf9	8b 55 f4	 mov	 edx, DWORD PTR _hrgn$[ebp]
  00cfc	52		 push	 edx
  00cfd	68 85 00 00 00	 push	 133			; 00000085H
  00d02	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  00d05	50		 push	 eax
  00d06	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00d09	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00d0c	52		 push	 edx
  00d0d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  00d13	3b f4		 cmp	 esi, esp
  00d15	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d1a	89 45 b4	 mov	 DWORD PTR _ret$[ebp], eax

; 1559 : 	
; 1560 :     if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )

  00d1d	8b 45 b0	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  00d20	25 00 00 30 00	 and	 eax, 3145728		; 00300000H
  00d25	74 26		 je	 SHORT $L23086

; 1561 :     {
; 1562 :         SetWindowLong(hwnd, GWL_STYLE, dwStyle);

  00d27	8b f4		 mov	 esi, esp
  00d29	8b 4d b0	 mov	 ecx, DWORD PTR _dwStyle$[ebp]
  00d2c	51		 push	 ecx
  00d2d	6a f0		 push	 -16			; fffffff0H
  00d2f	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00d32	52		 push	 edx
  00d33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12
  00d39	3b f4		 cmp	 esi, esp
  00d3b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1563 :         sw->bPreventStyleChange = FALSE;

  00d40	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00d43	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1724], 0
$L23086:

; 1564 :     }
; 1565 : 
; 1566 : 
; 1567 : 	// DRAW THE DEAD AREA
; 1568 : 	// only do this if the horizontal and vertical bars are visible
; 1569 : 	if(sw->sbarHorz.fScrollVisible && sw->sbarVert.fScrollVisible)

  00d4d	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00d50	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00d54	0f 84 36 02 00
	00		 je	 $L23087
  00d5a	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00d5d	83 ba 58 03 00
	00 00		 cmp	 DWORD PTR [edx+856], 0
  00d64	0f 84 26 02 00
	00		 je	 $L23087

; 1570 : 	{
; 1571 : 		GetWindowRect(hwnd, &rect);

  00d6a	8b f4		 mov	 esi, esp
  00d6c	8d 45 c8	 lea	 eax, DWORD PTR _rect$[ebp]
  00d6f	50		 push	 eax
  00d70	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00d73	51		 push	 ecx
  00d74	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  00d7a	3b f4		 cmp	 esi, esp
  00d7c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1572 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  00d81	8b 55 e4	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  00d84	f7 da		 neg	 edx
  00d86	8b f4		 mov	 esi, esp
  00d88	52		 push	 edx
  00d89	8b 45 e0	 mov	 eax, DWORD PTR _winrect$[ebp]
  00d8c	f7 d8		 neg	 eax
  00d8e	50		 push	 eax
  00d8f	8d 4d c8	 lea	 ecx, DWORD PTR _rect$[ebp]
  00d92	51		 push	 ecx
  00d93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  00d99	3b f4		 cmp	 esi, esp
  00d9b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1573 : 
; 1574 : 		rect.bottom -= sw->cyBottomEdge;

  00da0	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00da3	8b 45 d4	 mov	 eax, DWORD PTR _rect$[ebp+12]
  00da6	2b 82 b8 06 00
	00		 sub	 eax, DWORD PTR [edx+1720]
  00dac	89 45 d4	 mov	 DWORD PTR _rect$[ebp+12], eax

; 1575 : 		rect.top  = rect.bottom - GetScrollMetric(&sw->sbarHorz, SM_CYHORZSB);

  00daf	6a 01		 push	 1
  00db1	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00db4	83 c1 08	 add	 ecx, 8
  00db7	51		 push	 ecx
  00db8	e8 00 00 00 00	 call	 _GetScrollMetric
  00dbd	83 c4 08	 add	 esp, 8
  00dc0	8b 55 d4	 mov	 edx, DWORD PTR _rect$[ebp+12]
  00dc3	2b d0		 sub	 edx, eax
  00dc5	89 55 cc	 mov	 DWORD PTR _rect$[ebp+4], edx

; 1576 : 
; 1577 : 		if(sw->fLeftScrollbar)

  00dc8	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00dcb	83 b8 a4 06 00
	00 00		 cmp	 DWORD PTR [eax+1700], 0
  00dd2	74 2a		 je	 SHORT $L23088

; 1578 : 		{
; 1579 : 			rect.left += sw->cxLeftEdge;

  00dd4	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00dd7	8b 55 c8	 mov	 edx, DWORD PTR _rect$[ebp]
  00dda	03 91 ac 06 00
	00		 add	 edx, DWORD PTR [ecx+1708]
  00de0	89 55 c8	 mov	 DWORD PTR _rect$[ebp], edx

; 1580 : 			rect.right = rect.left + GetScrollMetric(&sw->sbarVert, SM_CXVERTSB);

  00de3	6a 01		 push	 1
  00de5	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00de8	05 54 03 00 00	 add	 eax, 852		; 00000354H
  00ded	50		 push	 eax
  00dee	e8 00 00 00 00	 call	 _GetScrollMetric
  00df3	83 c4 08	 add	 esp, 8
  00df6	03 45 c8	 add	 eax, DWORD PTR _rect$[ebp]
  00df9	89 45 d0	 mov	 DWORD PTR _rect$[ebp+8], eax

; 1581 : 		}
; 1582 : 		else

  00dfc	eb 2a		 jmp	 SHORT $L23089
$L23088:

; 1583 : 		{
; 1584 : 			rect.right -= sw->cxRightEdge;

  00dfe	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00e01	8b 55 d0	 mov	 edx, DWORD PTR _rect$[ebp+8]
  00e04	2b 91 b0 06 00
	00		 sub	 edx, DWORD PTR [ecx+1712]
  00e0a	89 55 d0	 mov	 DWORD PTR _rect$[ebp+8], edx

; 1585 : 			rect.left = rect.right  - GetScrollMetric(&sw->sbarVert, SM_CXVERTSB);

  00e0d	6a 01		 push	 1
  00e0f	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00e12	05 54 03 00 00	 add	 eax, 852		; 00000354H
  00e17	50		 push	 eax
  00e18	e8 00 00 00 00	 call	 _GetScrollMetric
  00e1d	83 c4 08	 add	 esp, 8
  00e20	8b 4d d0	 mov	 ecx, DWORD PTR _rect$[ebp+8]
  00e23	2b c8		 sub	 ecx, eax
  00e25	89 4d c8	 mov	 DWORD PTR _rect$[ebp], ecx
$L23089:

; 1586 : 		}
; 1587 : 		
; 1588 : 		if(fCustomDraw)

  00e28	83 7d b8 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  00e2c	74 23		 je	 SHORT $L23090

; 1589 : 			PostCustomDrawNotify(hwnd, hdc, SB_BOTH, &rect, 32, 0, 0, 0);

  00e2e	6a 00		 push	 0
  00e30	6a 00		 push	 0
  00e32	6a 00		 push	 0
  00e34	6a 20		 push	 32			; 00000020H
  00e36	8d 55 c8	 lea	 edx, DWORD PTR _rect$[ebp]
  00e39	52		 push	 edx
  00e3a	6a 03		 push	 3
  00e3c	8b 45 f8	 mov	 eax, DWORD PTR _hdc$[ebp]
  00e3f	50		 push	 eax
  00e40	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  00e43	51		 push	 ecx
  00e44	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  00e49	83 c4 20	 add	 esp, 32			; 00000020H

; 1590 : 		else

  00e4c	e9 3f 01 00 00	 jmp	 $L23087
$L23090:

; 1591 : 		{
; 1592 : 			//calculate the position of THIS window's dead area
; 1593 : 			//with the position of the PARENT window's client rectangle.
; 1594 : 			//if THIS window has been positioned such that its bottom-right
; 1595 : 			//corner sits in the parent's bottom-right corner, then we should
; 1596 : 			//show the sizing-grip.
; 1597 : 			//Otherwise, assume this window is not in the right place, and
; 1598 : 			//just draw a blank rectangle
; 1599 : 			RECT parent;
; 1600 : 			RECT rect2;
; 1601 : 			HWND hwndParent = GetParent(hwnd);

  00e51	8b f4		 mov	 esi, esp
  00e53	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00e56	52		 push	 edx
  00e57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00e5d	3b f4		 cmp	 esi, esp
  00e5f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00e64	89 85 6c ff ff
	ff		 mov	 DWORD PTR _hwndParent$23094[ebp], eax

; 1602 : 
; 1603 : 			GetClientRect(hwndParent, &parent);

  00e6a	8b f4		 mov	 esi, esp
  00e6c	8d 45 8c	 lea	 eax, DWORD PTR _parent$23092[ebp]
  00e6f	50		 push	 eax
  00e70	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _hwndParent$23094[ebp]
  00e76	51		 push	 ecx
  00e77	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8
  00e7d	3b f4		 cmp	 esi, esp
  00e7f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1604 : 			MapWindowPoints(hwndParent, 0, (POINT *)&parent, 2);

  00e84	8b f4		 mov	 esi, esp
  00e86	6a 02		 push	 2
  00e88	8d 55 8c	 lea	 edx, DWORD PTR _parent$23092[ebp]
  00e8b	52		 push	 edx
  00e8c	6a 00		 push	 0
  00e8e	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _hwndParent$23094[ebp]
  00e94	50		 push	 eax
  00e95	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapWindowPoints@16
  00e9b	3b f4		 cmp	 esi, esp
  00e9d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1605 : 
; 1606 : 			CopyRect(&rect2, &rect);

  00ea2	8b f4		 mov	 esi, esp
  00ea4	8d 4d c8	 lea	 ecx, DWORD PTR _rect$[ebp]
  00ea7	51		 push	 ecx
  00ea8	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _rect2$23093[ebp]
  00eae	52		 push	 edx
  00eaf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyRect@8
  00eb5	3b f4		 cmp	 esi, esp
  00eb7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1607 : 			OffsetRect(&rect2, winrect.left, winrect.top);

  00ebc	8b f4		 mov	 esi, esp
  00ebe	8b 45 e4	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  00ec1	50		 push	 eax
  00ec2	8b 4d e0	 mov	 ecx, DWORD PTR _winrect$[ebp]
  00ec5	51		 push	 ecx
  00ec6	8d 95 74 ff ff
	ff		 lea	 edx, DWORD PTR _rect2$23093[ebp]
  00ecc	52		 push	 edx
  00ecd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  00ed3	3b f4		 cmp	 esi, esp
  00ed5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1608 : 
; 1609 : 			if(!sw->fLeftScrollbar && parent.right == rect2.right+sw->cxRightEdge && parent.bottom == rect2.bottom+sw->cyBottomEdge
; 1610 : 			 || sw->fLeftScrollbar && parent.left  == rect2.left -sw->cxLeftEdge  && parent.bottom == rect2.bottom+sw->cyBottomEdge)

  00eda	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00edd	83 b8 a4 06 00
	00 00		 cmp	 DWORD PTR [eax+1700], 0
  00ee4	75 25		 jne	 SHORT $L23098
  00ee6	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00ee9	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _rect2$23093[ebp+8]
  00eef	03 91 b0 06 00
	00		 add	 edx, DWORD PTR [ecx+1712]
  00ef5	39 55 94	 cmp	 DWORD PTR _parent$23092[ebp+8], edx
  00ef8	75 11		 jne	 SHORT $L23098
  00efa	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00efd	8b 4d 80	 mov	 ecx, DWORD PTR _rect2$23093[ebp+12]
  00f00	03 88 b8 06 00
	00		 add	 ecx, DWORD PTR [eax+1720]
  00f06	39 4d 98	 cmp	 DWORD PTR _parent$23092[ebp+12], ecx
  00f09	74 31		 je	 SHORT $L23097
$L23098:
  00f0b	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00f0e	83 ba a4 06 00
	00 00		 cmp	 DWORD PTR [edx+1700], 0
  00f15	74 57		 je	 SHORT $L23096
  00f17	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  00f1a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _rect2$23093[ebp]
  00f20	2b 88 ac 06 00
	00		 sub	 ecx, DWORD PTR [eax+1708]
  00f26	39 4d 8c	 cmp	 DWORD PTR _parent$23092[ebp], ecx
  00f29	75 43		 jne	 SHORT $L23096
  00f2b	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  00f2e	8b 45 80	 mov	 eax, DWORD PTR _rect2$23093[ebp+12]
  00f31	03 82 b8 06 00
	00		 add	 eax, DWORD PTR [edx+1720]
  00f37	39 45 98	 cmp	 DWORD PTR _parent$23092[ebp+12], eax
  00f3a	75 32		 jne	 SHORT $L23096
$L23097:

; 1611 : 				DrawFrameControl(hdc, &rect, DFC_SCROLL, sw->fLeftScrollbar ? DFCS_SCROLLSIZEGRIPRIGHT : DFCS_SCROLLSIZEGRIP );

  00f3c	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  00f3f	33 d2		 xor	 edx, edx
  00f41	83 b9 a4 06 00
	00 00		 cmp	 DWORD PTR [ecx+1700], 0
  00f48	0f 95 c2	 setne	 dl
  00f4b	8d 14 d5 08 00
	00 00		 lea	 edx, DWORD PTR [edx*8+8]
  00f52	8b f4		 mov	 esi, esp
  00f54	52		 push	 edx
  00f55	6a 03		 push	 3
  00f57	8d 45 c8	 lea	 eax, DWORD PTR _rect$[ebp]
  00f5a	50		 push	 eax
  00f5b	8b 4d f8	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00f5e	51		 push	 ecx
  00f5f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  00f65	3b f4		 cmp	 esi, esp
  00f67	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1612 : 			else

  00f6c	eb 22		 jmp	 SHORT $L23087
$L23096:

; 1613 : 				PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  00f6e	8b f4		 mov	 esi, esp
  00f70	6a 0f		 push	 15			; 0000000fH
  00f72	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  00f78	3b f4		 cmp	 esi, esp
  00f7a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00f7f	50		 push	 eax
  00f80	8d 55 c8	 lea	 edx, DWORD PTR _rect$[ebp]
  00f83	52		 push	 edx
  00f84	8b 45 f8	 mov	 eax, DWORD PTR _hdc$[ebp]
  00f87	50		 push	 eax
  00f88	e8 00 00 00 00	 call	 _PaintRect
  00f8d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L23087:

; 1614 : 		}
; 1615 : 	}
; 1616 : 
; 1617 : 	UNREFERENCED_PARAMETER(clip);
; 1618 : 
; 1619 : 	ReleaseDC(hwnd, hdc);

  00f90	8b f4		 mov	 esi, esp
  00f92	8b 4d f8	 mov	 ecx, DWORD PTR _hdc$[ebp]
  00f95	51		 push	 ecx
  00f96	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  00f99	52		 push	 edx
  00f9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  00fa0	3b f4		 cmp	 esi, esp
  00fa2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1620 : 	return ret;

  00fa7	8b 45 b4	 mov	 eax, DWORD PTR _ret$[ebp]

; 1621 : }

  00faa	52		 push	 edx
  00fab	8b cd		 mov	 ecx, ebp
  00fad	50		 push	 eax
  00fae	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23900
  00fb4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00fb9	58		 pop	 eax
  00fba	5a		 pop	 edx
  00fbb	5f		 pop	 edi
  00fbc	5e		 pop	 esi
  00fbd	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  00fc3	3b ec		 cmp	 ebp, esp
  00fc5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00fca	8b e5		 mov	 esp, ebp
  00fcc	5d		 pop	 ebp
  00fcd	c3		 ret	 0
$L23900:
  00fce	04 00 00 00	 DD	 4
  00fd2	00 00 00 00	 DD	 $L23899
$L23899:
  00fd6	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00fda	10 00 00 00	 DD	 16			; 00000010H
  00fde	00 00 00 00	 DD	 $L23895
  00fe2	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00fe6	10 00 00 00	 DD	 16			; 00000010H
  00fea	00 00 00 00	 DD	 $L23896
  00fee	8c ff ff ff	 DD	 -116			; ffffff8cH
  00ff2	10 00 00 00	 DD	 16			; 00000010H
  00ff6	00 00 00 00	 DD	 $L23897
  00ffa	74 ff ff ff	 DD	 -140			; ffffff74H
  00ffe	10 00 00 00	 DD	 16			; 00000010H
  01002	00 00 00 00	 DD	 $L23898
$L23898:
  01006	72		 DB	 114			; 00000072H
  01007	65		 DB	 101			; 00000065H
  01008	63		 DB	 99			; 00000063H
  01009	74		 DB	 116			; 00000074H
  0100a	32		 DB	 50			; 00000032H
  0100b	00		 DB	 0
$L23897:
  0100c	70		 DB	 112			; 00000070H
  0100d	61		 DB	 97			; 00000061H
  0100e	72		 DB	 114			; 00000072H
  0100f	65		 DB	 101			; 00000065H
  01010	6e		 DB	 110			; 0000006eH
  01011	74		 DB	 116			; 00000074H
  01012	00		 DB	 0
$L23896:
  01013	72		 DB	 114			; 00000072H
  01014	65		 DB	 101			; 00000065H
  01015	63		 DB	 99			; 00000063H
  01016	74		 DB	 116			; 00000074H
  01017	00		 DB	 0
$L23895:
  01018	77		 DB	 119			; 00000077H
  01019	69		 DB	 105			; 00000069H
  0101a	6e		 DB	 110			; 0000006eH
  0101b	72		 DB	 114			; 00000072H
  0101c	65		 DB	 101			; 00000065H
  0101d	63		 DB	 99			; 00000063H
  0101e	74		 DB	 116			; 00000074H
  0101f	00		 DB	 0
_NCPaint ENDP
_TEXT	ENDS
EXTRN	__imp__ExtTextOutA@32:NEAR
EXTRN	__imp__SetBkColor@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_oldcol$ = -4						; size = 4
_hdc$ = 8						; size = 4
_rect$ = 12						; size = 4
_color$ = 16						; size = 4
_PaintRect PROC NEAR

; 374  : {

  01020	55		 push	 ebp
  01021	8b ec		 mov	 ebp, esp
  01023	51		 push	 ecx
  01024	56		 push	 esi
  01025	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 375  : 	COLORREF oldcol = SetBkColor(hdc, color);

  0102c	8b f4		 mov	 esi, esp
  0102e	8b 45 10	 mov	 eax, DWORD PTR _color$[ebp]
  01031	50		 push	 eax
  01032	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01035	51		 push	 ecx
  01036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  0103c	3b f4		 cmp	 esi, esp
  0103e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01043	89 45 fc	 mov	 DWORD PTR _oldcol$[ebp], eax

; 376  : 	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, rect, _T(""), 0, 0);

  01046	8b f4		 mov	 esi, esp
  01048	6a 00		 push	 0
  0104a	6a 00		 push	 0
  0104c	68 00 00 00 00	 push	 OFFSET FLAT:$SG22593
  01051	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  01054	52		 push	 edx
  01055	6a 02		 push	 2
  01057	6a 00		 push	 0
  01059	6a 00		 push	 0
  0105b	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  0105e	50		 push	 eax
  0105f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExtTextOutA@32
  01065	3b f4		 cmp	 esi, esp
  01067	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 377  : 	SetBkColor(hdc, oldcol);

  0106c	8b f4		 mov	 esi, esp
  0106e	8b 4d fc	 mov	 ecx, DWORD PTR _oldcol$[ebp]
  01071	51		 push	 ecx
  01072	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  01075	52		 push	 edx
  01076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  0107c	3b f4		 cmp	 esi, esp
  0107e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 378  : }

  01083	5e		 pop	 esi
  01084	83 c4 04	 add	 esp, 4
  01087	3b ec		 cmp	 ebp, esp
  01089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0108e	8b e5		 mov	 esp, ebp
  01090	5d		 pop	 ebp
  01091	c3		 ret	 0
_PaintRect ENDP
; Function compile flags: /Odt /RTCsu
_sbut$ = -12						; size = 4
_nPixels$ = -8						; size = 4
_i$ = -4						; size = 4
_sbar$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_uBeforeAfter$ = 16					; size = 4
_GetButtonSize PROC NEAR

; 509  : {

  010a0	55		 push	 ebp
  010a1	8b ec		 mov	 ebp, esp
  010a3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  010a6	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  010ad	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  010b4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 510  : 	int i;
; 511  : 	int nPixels = 0;

  010bb	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nPixels$[ebp], 0

; 512  : 
; 513  : 	SCROLLBUT *sbut = sbar->sbButtons;

  010c2	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  010c5	83 c0 2c	 add	 eax, 44			; 0000002cH
  010c8	89 45 f4	 mov	 DWORD PTR _sbut$[ebp], eax

; 514  : 	
; 515  : 	for(i = 0; i < sbar->nButtons; i++)

  010cb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  010d2	eb 09		 jmp	 SHORT $L22676
$L22677:
  010d4	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  010d7	83 c1 01	 add	 ecx, 1
  010da	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$L22676:
  010dd	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  010e0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  010e3	3b 82 2c 03 00
	00		 cmp	 eax, DWORD PTR [edx+812]
  010e9	7d 30		 jge	 SHORT $L22678

; 516  : 	{
; 517  : 		//only consider those buttons on the same side as nTopBottom says
; 518  : 		if(sbut[i].uPlacement == uBeforeAfter)

  010eb	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  010ee	6b c9 30	 imul	 ecx, 48			; 00000030H
  010f1	8b 55 f4	 mov	 edx, DWORD PTR _sbut$[ebp]
  010f4	8b 44 0a 04	 mov	 eax, DWORD PTR [edx+ecx+4]
  010f8	3b 45 10	 cmp	 eax, DWORD PTR _uBeforeAfter$[ebp]
  010fb	75 1c		 jne	 SHORT $L22679

; 519  : 		{
; 520  : 			nPixels += GetSingleButSize(sbar, &sbut[i]);

  010fd	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  01100	6b c9 30	 imul	 ecx, 48			; 00000030H
  01103	03 4d f4	 add	 ecx, DWORD PTR _sbut$[ebp]
  01106	51		 push	 ecx
  01107	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  0110a	52		 push	 edx
  0110b	e8 00 00 00 00	 call	 _GetSingleButSize
  01110	83 c4 08	 add	 esp, 8
  01113	03 45 f8	 add	 eax, DWORD PTR _nPixels$[ebp]
  01116	89 45 f8	 mov	 DWORD PTR _nPixels$[ebp], eax
$L22679:

; 521  : 		}
; 522  : 	}

  01119	eb b9		 jmp	 SHORT $L22677
$L22678:

; 523  : 
; 524  : 	return nPixels;

  0111b	8b 45 f8	 mov	 eax, DWORD PTR _nPixels$[ebp]

; 525  : }

  0111e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01121	3b ec		 cmp	 ebp, esp
  01123	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01128	8b e5		 mov	 esp, ebp
  0112a	5d		 pop	 ebp
  0112b	c3		 ret	 0
_GetButtonSize ENDP
; Function compile flags: /Odt /RTCsu
_sbar$ = 8						; size = 4
_sbut$ = 12						; size = 4
_GetSingleButSize PROC NEAR

; 490  : {

  01130	55		 push	 ebp
  01131	8b ec		 mov	 ebp, esp
  01133	56		 push	 esi
  01134	57		 push	 edi

; 491  : 	//multiple of the system button size
; 492  : 	//or a specific button size
; 493  : 	if(sbut->nSize < 0)

  01135	8b 45 0c	 mov	 eax, DWORD PTR _sbut$[ebp]
  01138	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0113c	7d 48		 jge	 SHORT $L22661

; 494  : 	{
; 495  : 		if(sbar->nBarType == SB_HORZ)

  0113e	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  01141	83 b9 40 03 00
	00 00		 cmp	 DWORD PTR [ecx+832], 0
  01148	75 1e		 jne	 SHORT $L22662

; 496  : 			return -sbut->nSize * GetSystemMetrics(SM_CXHSCROLL);

  0114a	8b 55 0c	 mov	 edx, DWORD PTR _sbut$[ebp]
  0114d	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  01150	f7 de		 neg	 esi
  01152	8b fc		 mov	 edi, esp
  01154	6a 15		 push	 21			; 00000015H
  01156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0115c	3b fc		 cmp	 edi, esp
  0115e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01163	0f af c6	 imul	 eax, esi
  01166	eb 24		 jmp	 SHORT $L22660
$L22662:

; 497  : 		else 
; 498  : 			return -sbut->nSize * GetSystemMetrics(SM_CYVSCROLL);

  01168	8b 45 0c	 mov	 eax, DWORD PTR _sbut$[ebp]
  0116b	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0116e	f7 de		 neg	 esi
  01170	8b fc		 mov	 edi, esp
  01172	6a 14		 push	 20			; 00000014H
  01174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemMetrics@4
  0117a	3b fc		 cmp	 edi, esp
  0117c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01181	0f af c6	 imul	 eax, esi
  01184	eb 06		 jmp	 SHORT $L22660
$L22661:

; 499  : 	}
; 500  : 	else
; 501  : 		return  sbut->nSize;

  01186	8b 4d 0c	 mov	 ecx, DWORD PTR _sbut$[ebp]
  01189	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
$L22660:

; 502  : }

  0118c	5f		 pop	 edi
  0118d	5e		 pop	 esi
  0118e	3b ec		 cmp	 ebp, esp
  01190	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01195	5d		 pop	 ebp
  01196	c3		 ret	 0
_GetSingleButSize ENDP
_TEXT	ENDS
EXTRN	__imp__SendMessageA@16:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_nmcd$ = -52						; size = 48
_hwnd$ = 8						; size = 4
_hdc$ = 12						; size = 4
_nBar$ = 16						; size = 4
_prect$ = 20						; size = 4
_nItem$ = 24						; size = 4
_fMouseDown$ = 28					; size = 4
_fMouseOver$ = 32					; size = 4
_fInactive$ = 36					; size = 4
_PostCustomDrawNotify0 PROC NEAR

; 706  : {

  011a0	55		 push	 ebp
  011a1	8b ec		 mov	 ebp, esp
  011a3	83 ec 38	 sub	 esp, 56			; 00000038H
  011a6	56		 push	 esi
  011a7	57		 push	 edi
  011a8	8d 7d c8	 lea	 edi, DWORD PTR [ebp-56]
  011ab	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  011b0	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  011b5	f3 ab		 rep stosd

; 707  : #ifdef CUSTOM_DRAW
; 708  : 	NMCSBCUSTOMDRAW	nmcd;
; 709  : 
; 710  : 	//fill in the standard header
; 711  : 	nmcd.hdr.hwndFrom = hwnd;

  011b7	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  011ba	89 45 cc	 mov	 DWORD PTR _nmcd$[ebp], eax

; 712  : 	nmcd.hdr.idFrom   = GetWindowLong(hwnd, GWL_ID);

  011bd	8b f4		 mov	 esi, esp
  011bf	6a f4		 push	 -12			; fffffff4H
  011c1	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  011c4	51		 push	 ecx
  011c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  011cb	3b f4		 cmp	 esi, esp
  011cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  011d2	89 45 d0	 mov	 DWORD PTR _nmcd$[ebp+4], eax

; 713  : 	nmcd.hdr.code     = NM_COOLSB_CUSTOMDRAW;

  011d5	c7 45 d4 01 f0
	ff ff		 mov	 DWORD PTR _nmcd$[ebp+8], -4095 ; fffff001H

; 714  : 
; 715  : 	nmcd.dwDrawStage  = CDDS_ITEMPREPAINT;

  011dc	c7 45 d8 01 00
	01 00		 mov	 DWORD PTR _nmcd$[ebp+12], 65537 ; 00010001H

; 716  : 	nmcd.nBar		  = nBar;

  011e3	8b 55 10	 mov	 edx, DWORD PTR _nBar$[ebp]
  011e6	89 55 f8	 mov	 DWORD PTR _nmcd$[ebp+44], edx

; 717  : 	nmcd.rect		  = *prect;

  011e9	8b 45 14	 mov	 eax, DWORD PTR _prect$[ebp]
  011ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  011ee	89 4d e0	 mov	 DWORD PTR _nmcd$[ebp+20], ecx
  011f1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  011f4	89 55 e4	 mov	 DWORD PTR _nmcd$[ebp+24], edx
  011f7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  011fa	89 4d e8	 mov	 DWORD PTR _nmcd$[ebp+28], ecx
  011fd	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01200	89 55 ec	 mov	 DWORD PTR _nmcd$[ebp+32], edx

; 718  : 	nmcd.uItem		  = nItem;

  01203	8b 45 18	 mov	 eax, DWORD PTR _nItem$[ebp]
  01206	89 45 f0	 mov	 DWORD PTR _nmcd$[ebp+36], eax

; 719  : 	nmcd.hdc		  = hdc;

  01209	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0120c	89 4d dc	 mov	 DWORD PTR _nmcd$[ebp+16], ecx

; 720  : 
; 721  : 	if(fMouseDown) 

  0120f	83 7d 1c 00	 cmp	 DWORD PTR _fMouseDown$[ebp], 0
  01213	74 09		 je	 SHORT $L22784

; 722  : 		nmcd.uState		  = CDIS_SELECTED;

  01215	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _nmcd$[ebp+40], 1

; 723  : 	else if(fMouseOver)

  0121c	eb 25		 jmp	 SHORT $L22785
$L22784:
  0121e	83 7d 20 00	 cmp	 DWORD PTR _fMouseOver$[ebp], 0
  01222	74 09		 je	 SHORT $L22786

; 724  : 		nmcd.uState		  = CDIS_HOT;

  01224	c7 45 f4 40 00
	00 00		 mov	 DWORD PTR _nmcd$[ebp+40], 64 ; 00000040H

; 725  : 	else if(fInactive)

  0122b	eb 16		 jmp	 SHORT $L22785
$L22786:
  0122d	83 7d 24 00	 cmp	 DWORD PTR _fInactive$[ebp], 0
  01231	74 09		 je	 SHORT $L22788

; 726  : 		nmcd.uState		  = CDIS_DISABLED;

  01233	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR _nmcd$[ebp+40], 4

; 727  : 	else

  0123a	eb 07		 jmp	 SHORT $L22785
$L22788:

; 728  : 		nmcd.uState		  = CDIS_DEFAULT;

  0123c	c7 45 f4 20 00
	00 00		 mov	 DWORD PTR _nmcd$[ebp+40], 32 ; 00000020H
$L22785:

; 729  : 
; 730  : 	hwnd = GetParent(hwnd);

  01243	8b f4		 mov	 esi, esp
  01245	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  01248	52		 push	 edx
  01249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  0124f	3b f4		 cmp	 esi, esp
  01251	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01256	89 45 08	 mov	 DWORD PTR _hwnd$[ebp], eax

; 731  : 	return SendMessage(hwnd, WM_NOTIFY, nmcd.hdr.idFrom, (LPARAM)&nmcd);

  01259	8b f4		 mov	 esi, esp
  0125b	8d 45 cc	 lea	 eax, DWORD PTR _nmcd$[ebp]
  0125e	50		 push	 eax
  0125f	8b 4d d0	 mov	 ecx, DWORD PTR _nmcd$[ebp+4]
  01262	51		 push	 ecx
  01263	6a 4e		 push	 78			; 0000004eH
  01265	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  01268	52		 push	 edx
  01269	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0126f	3b f4		 cmp	 esi, esp
  01271	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 732  : #else
; 733  : 	return 0;
; 734  : #endif
; 735  : }

  01276	52		 push	 edx
  01277	8b cd		 mov	 ecx, ebp
  01279	50		 push	 eax
  0127a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23907
  01280	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  01285	58		 pop	 eax
  01286	5a		 pop	 edx
  01287	5f		 pop	 edi
  01288	5e		 pop	 esi
  01289	83 c4 38	 add	 esp, 56			; 00000038H
  0128c	3b ec		 cmp	 ebp, esp
  0128e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01293	8b e5		 mov	 esp, ebp
  01295	5d		 pop	 ebp
  01296	c3		 ret	 0
$L23907:
  01297	01 00 00 00	 DD	 1
  0129b	00 00 00 00	 DD	 $L23906
$L23906:
  0129f	cc ff ff ff	 DD	 -52			; ffffffccH
  012a3	30 00 00 00	 DD	 48			; 00000030H
  012a7	00 00 00 00	 DD	 $L23905
$L23905:
  012ab	6e		 DB	 110			; 0000006eH
  012ac	6d		 DB	 109			; 0000006dH
  012ad	63		 DB	 99			; 00000063H
  012ae	64		 DB	 100			; 00000064H
  012af	00		 DB	 0
_PostCustomDrawNotify0 ENDP
_TEXT	ENDS
EXTRN	__imp__SetRect@20:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv315 = -200						; size = 4
tv157 = -196						; size = 4
tv153 = -192						; size = 4
tv149 = -188						; size = 4
_rdis$22851 = -184					; size = 4
_ldis$22850 = -180					; size = 4
_uRightButFlags$ = -176					; size = 4
_uLeftButFlags$ = -172					; size = 4
_uDEFlat$ = -168					; size = 4
_uDFCFlat$ = -164					; size = 4
_crInverse2$ = -160					; size = 4
_crInverse1$ = -156					; size = 4
_crCheck2$ = -152					; size = 4
_crCheck1$ = -148					; size = 4
_fMouseOverR$ = -144					; size = 4
_fMouseDownR$ = -140					; size = 4
_fBarHot$ = -136					; size = 4
_fMouseOverL$ = -132					; size = 4
_fMouseDownL$ = -128					; size = 4
_fCustomDraw$ = -124					; size = 4
_ret$ = -120						; size = 4
_siMaxMin$ = -116					; size = 4
_thumbpos$ = -108					; size = 4
_thumbwidth$ = -96					; size = 4
_workingwidth$ = -88					; size = 4
_scrollwidth$ = -84					; size = 4
_butwidth$ = -80					; size = 4
_sbm$ = -72						; size = 16
_thumb$ = -48						; size = 16
_ctrl$ = -24						; size = 16
_si$ = -4						; size = 4
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_hdc$ = 16						; size = 4
_rect$ = 20						; size = 4
_uDrawFlags$ = 24					; size = 4
_NCDrawHScrollbar PROC NEAR

; 790  : {

  012b0	55		 push	 ebp
  012b1	8b ec		 mov	 ebp, esp
  012b3	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  012b9	56		 push	 esi
  012ba	57		 push	 edi
  012bb	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  012c1	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  012c6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  012cb	f3 ab		 rep stosd

; 791  : 	SCROLLINFO *si;
; 792  : 	RECT ctrl, thumb;
; 793  : 	RECT sbm;
; 794  : 	int butwidth	 = GetScrollMetric(sb, SM_SCROLL_LENGTH);

  012cd	6a 00		 push	 0
  012cf	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  012d2	50		 push	 eax
  012d3	e8 00 00 00 00	 call	 _GetScrollMetric
  012d8	83 c4 08	 add	 esp, 8
  012db	89 45 b0	 mov	 DWORD PTR _butwidth$[ebp], eax

; 795  : 	int scrollwidth  = rect->right-rect->left;

  012de	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  012e1	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  012e4	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  012e7	2b 02		 sub	 eax, DWORD PTR [edx]
  012e9	89 45 ac	 mov	 DWORD PTR _scrollwidth$[ebp], eax

; 796  : 	int workingwidth = scrollwidth - butwidth*2;

  012ec	8b 4d b0	 mov	 ecx, DWORD PTR _butwidth$[ebp]
  012ef	d1 e1		 shl	 ecx, 1
  012f1	8b 55 ac	 mov	 edx, DWORD PTR _scrollwidth$[ebp]
  012f4	2b d1		 sub	 edx, ecx
  012f6	89 55 a8	 mov	 DWORD PTR _workingwidth$[ebp], edx

; 797  : 	int thumbwidth   = 0, thumbpos = 0;

  012f9	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _thumbwidth$[ebp], 0
  01300	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _thumbpos$[ebp], 0

; 798  : 	int siMaxMin;
; 799  : 
; 800  : 	LRESULT  ret = 0;

  01307	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 801  : 	BOOL fCustomDraw = 0;

  0130e	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _fCustomDraw$[ebp], 0

; 802  : 
; 803  : 	BOOL fMouseDownL = 0, fMouseOverL = 0, fBarHot = 0;

  01315	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _fMouseDownL$[ebp], 0
  0131c	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _fMouseOverL$[ebp], 0
  01326	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _fBarHot$[ebp], 0

; 804  : 	BOOL fMouseDownR = 0, fMouseOverR = 0;

  01330	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _fMouseDownR$[ebp], 0
  0133a	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _fMouseOverR$[ebp], 0

; 805  : 
; 806  : 	COLORREF crCheck1   = GetSBForeColor();

  01344	e8 00 00 00 00	 call	 _GetSBForeColor
  01349	89 85 6c ff ff
	ff		 mov	 DWORD PTR _crCheck1$[ebp], eax

; 807  : 	COLORREF crCheck2   = GetSBBackColor();

  0134f	e8 00 00 00 00	 call	 _GetSBBackColor
  01354	89 85 68 ff ff
	ff		 mov	 DWORD PTR _crCheck2$[ebp], eax

; 808  : 	COLORREF crInverse1 = InvertCOLORREF(crCheck1);

  0135a	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _crCheck1$[ebp]
  01360	f7 d0		 not	 eax
  01362	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  01367	89 85 64 ff ff
	ff		 mov	 DWORD PTR _crInverse1$[ebp], eax

; 809  : 	COLORREF crInverse2 = InvertCOLORREF(crCheck2);

  0136d	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _crCheck2$[ebp]
  01373	f7 d1		 not	 ecx
  01375	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0137b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _crInverse2$[ebp], ecx

; 810  : 
; 811  : 	UINT uDFCFlat = sb->fFlatScrollbar ? DFCS_FLAT : 0;

  01381	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01384	8b 82 44 03 00
	00		 mov	 eax, DWORD PTR [edx+836]
  0138a	f7 d8		 neg	 eax
  0138c	1b c0		 sbb	 eax, eax
  0138e	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  01393	89 85 5c ff ff
	ff		 mov	 DWORD PTR _uDFCFlat$[ebp], eax

; 812  : 	UINT uDEFlat  = sb->fFlatScrollbar ? BF_FLAT   : 0;

  01399	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  0139c	8b 91 44 03 00
	00		 mov	 edx, DWORD PTR [ecx+836]
  013a2	f7 da		 neg	 edx
  013a4	1b d2		 sbb	 edx, edx
  013a6	81 e2 00 40 00
	00		 and	 edx, 16384		; 00004000H
  013ac	89 95 58 ff ff
	ff		 mov	 DWORD PTR _uDEFlat$[ebp], edx

; 813  : 
; 814  : 	//drawing flags to modify the appearance of the scrollbar buttons
; 815  : 	UINT uLeftButFlags  = DFCS_SCROLLLEFT;

  013b2	c7 85 54 ff ff
	ff 02 00 00 00	 mov	 DWORD PTR _uLeftButFlags$[ebp], 2

; 816  : 	UINT uRightButFlags = DFCS_SCROLLRIGHT;

  013bc	c7 85 50 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR _uRightButFlags$[ebp], 3

; 817  : 
; 818  : 	if(scrollwidth <= 0)

  013c6	83 7d ac 00	 cmp	 DWORD PTR _scrollwidth$[ebp], 0
  013ca	7f 07		 jg	 SHORT $L22844

; 819  : 		return 0;

  013cc	33 c0		 xor	 eax, eax
  013ce	e9 fc 09 00 00	 jmp	 $L22818
$L22844:

; 820  : 
; 821  : 	si = &sb->scrollInfo;

  013d3	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  013d6	83 c0 08	 add	 eax, 8
  013d9	89 45 fc	 mov	 DWORD PTR _si$[ebp], eax

; 822  : 	siMaxMin = si->nMax - si->nMin;

  013dc	8b 4d fc	 mov	 ecx, DWORD PTR _si$[ebp]
  013df	8b 55 fc	 mov	 edx, DWORD PTR _si$[ebp]
  013e2	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  013e5	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  013e8	89 45 8c	 mov	 DWORD PTR _siMaxMin$[ebp], eax

; 823  : 
; 824  : 	if(hwnd != hwndCurCoolSB)

  013eb	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  013ee	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _hwndCurCoolSB
  013f4	74 07		 je	 SHORT $L22845

; 825  : 		uDrawFlags = HTSCROLL_NONE;

  013f6	c7 45 18 ff ff
	ff ff		 mov	 DWORD PTR _uDrawFlags$[ebp], -1
$L22845:

; 826  : 	//
; 827  : 	// work out the thumb size and position
; 828  : 	//
; 829  : 	CalcThumbSize(sb, rect, &thumbwidth, &thumbpos);

  013fd	8d 55 94	 lea	 edx, DWORD PTR _thumbpos$[ebp]
  01400	52		 push	 edx
  01401	8d 45 a0	 lea	 eax, DWORD PTR _thumbwidth$[ebp]
  01404	50		 push	 eax
  01405	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  01408	51		 push	 ecx
  01409	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0140c	52		 push	 edx
  0140d	e8 00 00 00 00	 call	 _CalcThumbSize
  01412	83 c4 10	 add	 esp, 16			; 00000010H

; 830  : 	
; 831  : 	if(sb->fScrollFlags & ESB_DISABLE_LEFT)		uLeftButFlags  |= DFCS_INACTIVE;

  01415	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01418	8b 08		 mov	 ecx, DWORD PTR [eax]
  0141a	83 e1 01	 and	 ecx, 1
  0141d	74 12		 je	 SHORT $L22846
  0141f	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _uLeftButFlags$[ebp]
  01425	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  0142b	89 95 54 ff ff
	ff		 mov	 DWORD PTR _uLeftButFlags$[ebp], edx
$L22846:

; 832  : 	if(sb->fScrollFlags & ESB_DISABLE_RIGHT)	uRightButFlags |= DFCS_INACTIVE;

  01431	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01434	8b 08		 mov	 ecx, DWORD PTR [eax]
  01436	83 e1 02	 and	 ecx, 2
  01439	74 12		 je	 SHORT $L22847
  0143b	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _uRightButFlags$[ebp]
  01441	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  01447	89 95 50 ff ff
	ff		 mov	 DWORD PTR _uRightButFlags$[ebp], edx
$L22847:

; 833  : 
; 834  : 	//if we need to grey the arrows because there is no data to scroll
; 835  : 	if(!IsScrollInfoActive(si) && !(sb->fScrollFlags & CSBS_THUMBALWAYS))

  0144d	8b 45 fc	 mov	 eax, DWORD PTR _si$[ebp]
  01450	50		 push	 eax
  01451	e8 00 00 00 00	 call	 _IsScrollInfoActive
  01456	83 c4 04	 add	 esp, 4
  01459	85 c0		 test	 eax, eax
  0145b	75 2d		 jne	 SHORT $L22848
  0145d	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01460	8b 11		 mov	 edx, DWORD PTR [ecx]
  01462	83 e2 04	 and	 edx, 4
  01465	75 23		 jne	 SHORT $L22848

; 836  : 	{
; 837  : 		uLeftButFlags  |= DFCS_INACTIVE;

  01467	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _uLeftButFlags$[ebp]
  0146d	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  01472	89 85 54 ff ff
	ff		 mov	 DWORD PTR _uLeftButFlags$[ebp], eax

; 838  : 		uRightButFlags |= DFCS_INACTIVE;

  01478	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _uRightButFlags$[ebp]
  0147e	81 c9 00 01 00
	00		 or	 ecx, 256		; 00000100H
  01484	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _uRightButFlags$[ebp], ecx
$L22848:

; 839  : 	}
; 840  : 
; 841  : 	if(hwnd == hwndCurCoolSB)

  0148a	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0148d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _hwndCurCoolSB
  01493	0f 85 01 01 00
	00		 jne	 $L22849

; 842  : 	{
; 843  : #ifdef FLAT_SCROLLBARS	
; 844  : 		BOOL ldis = !(uLeftButFlags & DFCS_INACTIVE);

  01499	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _uLeftButFlags$[ebp]
  0149f	25 00 01 00 00	 and	 eax, 256		; 00000100H
  014a4	f7 d8		 neg	 eax
  014a6	1b c0		 sbb	 eax, eax
  014a8	40		 inc	 eax
  014a9	89 85 4c ff ff
	ff		 mov	 DWORD PTR _ldis$22850[ebp], eax

; 845  : 		BOOL rdis = !(uRightButFlags & DFCS_INACTIVE);

  014af	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _uRightButFlags$[ebp]
  014b5	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  014bb	f7 d9		 neg	 ecx
  014bd	1b c9		 sbb	 ecx, ecx
  014bf	41		 inc	 ecx
  014c0	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _rdis$22851[ebp], ecx

; 846  : 
; 847  : 		fBarHot = (sb->nBarType == (int)uMouseOverScrollbar && sb->fFlatScrollbar == CSBS_HOTTRACKED);

  014c6	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  014c9	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  014cf	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _uMouseOverScrollbar
  014d5	75 18		 jne	 SHORT $L23909
  014d7	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  014da	83 b9 44 03 00
	00 02		 cmp	 DWORD PTR [ecx+836], 2
  014e1	75 0c		 jne	 SHORT $L23909
  014e3	c7 85 44 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv149[ebp], 1
  014ed	eb 0a		 jmp	 SHORT $L23910
$L23909:
  014ef	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv149[ebp], 0
$L23910:
  014f9	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv149[ebp]
  014ff	89 95 78 ff ff
	ff		 mov	 DWORD PTR _fBarHot$[ebp], edx

; 848  : 		
; 849  : 		fMouseOverL = uHitTestPortion == HTSCROLL_LEFT && fBarHot && ldis;		

  01505	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uHitTestPortion, 0
  0150c	75 1e		 jne	 SHORT $L23911
  0150e	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _fBarHot$[ebp], 0
  01515	74 15		 je	 SHORT $L23911
  01517	83 bd 4c ff ff
	ff 00		 cmp	 DWORD PTR _ldis$22850[ebp], 0
  0151e	74 0c		 je	 SHORT $L23911
  01520	c7 85 40 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv153[ebp], 1
  0152a	eb 0a		 jmp	 SHORT $L23912
$L23911:
  0152c	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$L23912:
  01536	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
  0153c	89 85 7c ff ff
	ff		 mov	 DWORD PTR _fMouseOverL$[ebp], eax

; 850  : 		fMouseOverR = uHitTestPortion == HTSCROLL_RIGHT && fBarHot && rdis;

  01542	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uHitTestPortion, 1
  01549	75 1e		 jne	 SHORT $L23913
  0154b	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _fBarHot$[ebp], 0
  01552	74 15		 je	 SHORT $L23913
  01554	83 bd 48 ff ff
	ff 00		 cmp	 DWORD PTR _rdis$22851[ebp], 0
  0155b	74 0c		 je	 SHORT $L23913
  0155d	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv157[ebp], 1
  01567	eb 0a		 jmp	 SHORT $L23914
$L23913:
  01569	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv157[ebp], 0
$L23914:
  01573	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv157[ebp]
  01579	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _fMouseOverR$[ebp], ecx

; 851  : #endif
; 852  : 		fMouseDownL = (uDrawFlags == HTSCROLL_LEFT);

  0157f	33 d2		 xor	 edx, edx
  01581	83 7d 18 00	 cmp	 DWORD PTR _uDrawFlags$[ebp], 0
  01585	0f 94 c2	 sete	 dl
  01588	89 55 80	 mov	 DWORD PTR _fMouseDownL$[ebp], edx

; 853  : 		fMouseDownR = (uDrawFlags == HTSCROLL_RIGHT);

  0158b	33 c0		 xor	 eax, eax
  0158d	83 7d 18 01	 cmp	 DWORD PTR _uDrawFlags$[ebp], 1
  01591	0f 94 c0	 sete	 al
  01594	89 85 74 ff ff
	ff		 mov	 DWORD PTR _fMouseDownR$[ebp], eax
$L22849:

; 854  : 	}
; 855  : 
; 856  : 
; 857  : #ifdef CUSTOM_DRAW
; 858  : 	ret = PostCustomPrePostPaint(hwnd, hdc, sb, CDDS_PREPAINT);

  0159a	6a 01		 push	 1
  0159c	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  0159f	51		 push	 ecx
  015a0	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  015a3	52		 push	 edx
  015a4	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  015a7	50		 push	 eax
  015a8	e8 00 00 00 00	 call	 _PostCustomPrePostPaint0
  015ad	83 c4 10	 add	 esp, 16			; 00000010H
  015b0	89 45 88	 mov	 DWORD PTR _ret$[ebp], eax

; 859  : 	fCustomDraw = (ret == CDRF_SKIPDEFAULT);

  015b3	33 c9		 xor	 ecx, ecx
  015b5	83 7d 88 04	 cmp	 DWORD PTR _ret$[ebp], 4
  015b9	0f 94 c1	 sete	 cl
  015bc	89 4d 84	 mov	 DWORD PTR _fCustomDraw$[ebp], ecx

; 860  : //fCustomDraw = TRUE;
; 861  : #endif
; 862  : 
; 863  : 	//
; 864  : 	// Draw the scrollbar now
; 865  : 	//
; 866  : 	if(scrollwidth > butwidth*2)

  015bf	8b 55 b0	 mov	 edx, DWORD PTR _butwidth$[ebp]
  015c2	d1 e2		 shl	 edx, 1
  015c4	39 55 ac	 cmp	 DWORD PTR _scrollwidth$[ebp], edx
  015c7	0f 8e 08 06 00
	00		 jle	 $L22853

; 867  : 	{
; 868  : 		//LEFT ARROW
; 869  : 		SetRect(&ctrl, rect->left, rect->top, rect->left + butwidth, rect->bottom);

  015cd	8b f4		 mov	 esi, esp
  015cf	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  015d2	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  015d5	51		 push	 ecx
  015d6	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  015d9	8b 02		 mov	 eax, DWORD PTR [edx]
  015db	03 45 b0	 add	 eax, DWORD PTR _butwidth$[ebp]
  015de	50		 push	 eax
  015df	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  015e2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  015e5	52		 push	 edx
  015e6	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  015e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  015eb	51		 push	 ecx
  015ec	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  015ef	52		 push	 edx
  015f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  015f6	3b f4		 cmp	 esi, esp
  015f8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 870  : 
; 871  : 		RotateRect0(sb, &ctrl);

  015fd	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01600	50		 push	 eax
  01601	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01604	51		 push	 ecx
  01605	e8 00 00 00 00	 call	 _RotateRect0@8

; 872  : 
; 873  : 		if(fCustomDraw)

  0160a	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  0160e	74 3a		 je	 SHORT $L22854

; 874  : 			PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_LINELEFT, fMouseDownL, fMouseOverL, uLeftButFlags & DFCS_INACTIVE);

  01610	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _uLeftButFlags$[ebp]
  01616	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  0161c	52		 push	 edx
  0161d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _fMouseOverL$[ebp]
  01623	50		 push	 eax
  01624	8b 4d 80	 mov	 ecx, DWORD PTR _fMouseDownL$[ebp]
  01627	51		 push	 ecx
  01628	6a 00		 push	 0
  0162a	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  0162d	52		 push	 edx
  0162e	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01631	8b 88 40 03 00
	00		 mov	 ecx, DWORD PTR [eax+832]
  01637	51		 push	 ecx
  01638	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  0163b	52		 push	 edx
  0163c	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0163f	50		 push	 eax
  01640	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01645	83 c4 20	 add	 esp, 32			; 00000020H

; 875  : 		else

  01648	eb 26		 jmp	 SHORT $L22855
$L22854:

; 876  : 			DrawScrollArrow(sb, hdc, &ctrl, uLeftButFlags, fMouseDownL, fMouseOverL);

  0164a	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _fMouseOverL$[ebp]
  01650	51		 push	 ecx
  01651	8b 55 80	 mov	 edx, DWORD PTR _fMouseDownL$[ebp]
  01654	52		 push	 edx
  01655	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _uLeftButFlags$[ebp]
  0165b	50		 push	 eax
  0165c	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  0165f	51		 push	 ecx
  01660	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  01663	52		 push	 edx
  01664	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01667	50		 push	 eax
  01668	e8 00 00 00 00	 call	 _DrawScrollArrow
  0166d	83 c4 18	 add	 esp, 24			; 00000018H
$L22855:

; 877  : 
; 878  : 		RotateRect0(sb, &ctrl);

  01670	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01673	51		 push	 ecx
  01674	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01677	52		 push	 edx
  01678	e8 00 00 00 00	 call	 _RotateRect0@8

; 879  : 
; 880  : 		//MIDDLE PORTION
; 881  : 		//if we can fit the thumbbar in, then draw it
; 882  : 		if(thumbwidth > 0 && thumbwidth <= workingwidth
; 883  : 			&& IsScrollInfoActive(si) && ((sb->fScrollFlags & ESB_DISABLE_BOTH) != ESB_DISABLE_BOTH))

  0167d	83 7d a0 00	 cmp	 DWORD PTR _thumbwidth$[ebp], 0
  01681	0f 8e b4 02 00
	00		 jle	 $L22856
  01687	8b 45 a0	 mov	 eax, DWORD PTR _thumbwidth$[ebp]
  0168a	3b 45 a8	 cmp	 eax, DWORD PTR _workingwidth$[ebp]
  0168d	0f 8f a8 02 00
	00		 jg	 $L22856
  01693	8b 4d fc	 mov	 ecx, DWORD PTR _si$[ebp]
  01696	51		 push	 ecx
  01697	e8 00 00 00 00	 call	 _IsScrollInfoActive
  0169c	83 c4 04	 add	 esp, 4
  0169f	85 c0		 test	 eax, eax
  016a1	0f 84 94 02 00
	00		 je	 $L22856
  016a7	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  016aa	8b 02		 mov	 eax, DWORD PTR [edx]
  016ac	83 e0 03	 and	 eax, 3
  016af	83 f8 03	 cmp	 eax, 3
  016b2	0f 84 83 02 00
	00		 je	 $L22856

; 884  : 		{	
; 885  : 			//Draw the scrollbar margin above the thumb
; 886  : 			SetRect(&sbm, rect->left + butwidth, rect->top, thumbpos, rect->bottom);

  016b8	8b f4		 mov	 esi, esp
  016ba	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  016bd	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  016c0	52		 push	 edx
  016c1	8b 45 94	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  016c4	50		 push	 eax
  016c5	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  016c8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  016cb	52		 push	 edx
  016cc	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  016cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  016d1	03 4d b0	 add	 ecx, DWORD PTR _butwidth$[ebp]
  016d4	51		 push	 ecx
  016d5	8d 55 b8	 lea	 edx, DWORD PTR _sbm$[ebp]
  016d8	52		 push	 edx
  016d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  016df	3b f4		 cmp	 esi, esp
  016e1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 887  : 			
; 888  : 			RotateRect0(sb, &sbm);

  016e6	8d 45 b8	 lea	 eax, DWORD PTR _sbm$[ebp]
  016e9	50		 push	 eax
  016ea	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  016ed	51		 push	 ecx
  016ee	e8 00 00 00 00	 call	 _RotateRect0@8

; 889  : 			
; 890  : 			if(fCustomDraw)

  016f3	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  016f7	74 30		 je	 SHORT $L22857

; 891  : 			{
; 892  : 				PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &sbm, SB_PAGELEFT, uDrawFlags == HTSCROLL_PAGELEFT, FALSE, FALSE);

  016f9	6a 00		 push	 0
  016fb	6a 00		 push	 0
  016fd	33 d2		 xor	 edx, edx
  016ff	83 7d 18 02	 cmp	 DWORD PTR _uDrawFlags$[ebp], 2
  01703	0f 94 c2	 sete	 dl
  01706	52		 push	 edx
  01707	6a 02		 push	 2
  01709	8d 45 b8	 lea	 eax, DWORD PTR _sbm$[ebp]
  0170c	50		 push	 eax
  0170d	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01710	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  01716	52		 push	 edx
  01717	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  0171a	50		 push	 eax
  0171b	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0171e	51		 push	 ecx
  0171f	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01724	83 c4 20	 add	 esp, 32			; 00000020H

; 893  : 			}
; 894  : 			else

  01727	eb 44		 jmp	 SHORT $L22858
$L22857:

; 895  : 			{
; 896  : 				if(uDrawFlags == HTSCROLL_PAGELEFT)

  01729	83 7d 18 02	 cmp	 DWORD PTR _uDrawFlags$[ebp], 2
  0172d	75 20		 jne	 SHORT $L22859

; 897  : 					DrawCheckedRect(hdc, &sbm, crInverse1, crInverse2);

  0172f	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _crInverse2$[ebp]
  01735	52		 push	 edx
  01736	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _crInverse1$[ebp]
  0173c	50		 push	 eax
  0173d	8d 4d b8	 lea	 ecx, DWORD PTR _sbm$[ebp]
  01740	51		 push	 ecx
  01741	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  01744	52		 push	 edx
  01745	e8 00 00 00 00	 call	 _DrawCheckedRect
  0174a	83 c4 10	 add	 esp, 16			; 00000010H

; 898  : 				else

  0174d	eb 1e		 jmp	 SHORT $L22858
$L22859:

; 899  : 					DrawCheckedRect(hdc, &sbm, crCheck1, crCheck2);

  0174f	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _crCheck2$[ebp]
  01755	50		 push	 eax
  01756	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  0175c	51		 push	 ecx
  0175d	8d 55 b8	 lea	 edx, DWORD PTR _sbm$[ebp]
  01760	52		 push	 edx
  01761	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  01764	50		 push	 eax
  01765	e8 00 00 00 00	 call	 _DrawCheckedRect
  0176a	83 c4 10	 add	 esp, 16			; 00000010H
$L22858:

; 900  : 
; 901  : 			}
; 902  : 
; 903  : 			RotateRect0(sb, &sbm);			

  0176d	8d 4d b8	 lea	 ecx, DWORD PTR _sbm$[ebp]
  01770	51		 push	 ecx
  01771	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01774	52		 push	 edx
  01775	e8 00 00 00 00	 call	 _RotateRect0@8

; 904  : 			
; 905  : 			//Draw the margin below the thumb
; 906  : 			sbm.left = thumbpos+thumbwidth;

  0177a	8b 45 94	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  0177d	03 45 a0	 add	 eax, DWORD PTR _thumbwidth$[ebp]
  01780	89 45 b8	 mov	 DWORD PTR _sbm$[ebp], eax

; 907  : 			sbm.right = rect->right - butwidth;

  01783	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  01786	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01789	2b 55 b0	 sub	 edx, DWORD PTR _butwidth$[ebp]
  0178c	89 55 c0	 mov	 DWORD PTR _sbm$[ebp+8], edx

; 908  : 			
; 909  : 			RotateRect0(sb, &sbm);

  0178f	8d 45 b8	 lea	 eax, DWORD PTR _sbm$[ebp]
  01792	50		 push	 eax
  01793	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01796	51		 push	 ecx
  01797	e8 00 00 00 00	 call	 _RotateRect0@8

; 910  : 			if(fCustomDraw)

  0179c	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  017a0	74 30		 je	 SHORT $L22861

; 911  : 			{
; 912  : 				PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &sbm, SB_PAGERIGHT, uDrawFlags == HTSCROLL_PAGERIGHT, 0, 0);

  017a2	6a 00		 push	 0
  017a4	6a 00		 push	 0
  017a6	33 d2		 xor	 edx, edx
  017a8	83 7d 18 03	 cmp	 DWORD PTR _uDrawFlags$[ebp], 3
  017ac	0f 94 c2	 sete	 dl
  017af	52		 push	 edx
  017b0	6a 03		 push	 3
  017b2	8d 45 b8	 lea	 eax, DWORD PTR _sbm$[ebp]
  017b5	50		 push	 eax
  017b6	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  017b9	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  017bf	52		 push	 edx
  017c0	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  017c3	50		 push	 eax
  017c4	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  017c7	51		 push	 ecx
  017c8	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  017cd	83 c4 20	 add	 esp, 32			; 00000020H

; 913  : 			}
; 914  : 			else

  017d0	eb 44		 jmp	 SHORT $L22862
$L22861:

; 915  : 			{
; 916  : 				if(uDrawFlags == HTSCROLL_PAGERIGHT)

  017d2	83 7d 18 03	 cmp	 DWORD PTR _uDrawFlags$[ebp], 3
  017d6	75 20		 jne	 SHORT $L22863

; 917  : 					DrawCheckedRect(hdc, &sbm, crInverse1, crInverse2);

  017d8	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _crInverse2$[ebp]
  017de	52		 push	 edx
  017df	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _crInverse1$[ebp]
  017e5	50		 push	 eax
  017e6	8d 4d b8	 lea	 ecx, DWORD PTR _sbm$[ebp]
  017e9	51		 push	 ecx
  017ea	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  017ed	52		 push	 edx
  017ee	e8 00 00 00 00	 call	 _DrawCheckedRect
  017f3	83 c4 10	 add	 esp, 16			; 00000010H

; 918  : 				else

  017f6	eb 1e		 jmp	 SHORT $L22862
$L22863:

; 919  : 					DrawCheckedRect(hdc, &sbm, crCheck1, crCheck2);

  017f8	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _crCheck2$[ebp]
  017fe	50		 push	 eax
  017ff	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  01805	51		 push	 ecx
  01806	8d 55 b8	 lea	 edx, DWORD PTR _sbm$[ebp]
  01809	52		 push	 edx
  0180a	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  0180d	50		 push	 eax
  0180e	e8 00 00 00 00	 call	 _DrawCheckedRect
  01813	83 c4 10	 add	 esp, 16			; 00000010H
$L22862:

; 920  : 			
; 921  : 			}
; 922  : 			RotateRect0(sb, &sbm);

  01816	8d 4d b8	 lea	 ecx, DWORD PTR _sbm$[ebp]
  01819	51		 push	 ecx
  0181a	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0181d	52		 push	 edx
  0181e	e8 00 00 00 00	 call	 _RotateRect0@8

; 923  : 			
; 924  : 			//Draw the THUMB finally
; 925  : 			SetRect(&thumb, thumbpos, rect->top, thumbpos+thumbwidth, rect->bottom);

  01823	8b f4		 mov	 esi, esp
  01825	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01828	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0182b	51		 push	 ecx
  0182c	8b 55 94	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  0182f	03 55 a0	 add	 edx, DWORD PTR _thumbwidth$[ebp]
  01832	52		 push	 edx
  01833	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01836	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01839	51		 push	 ecx
  0183a	8b 55 94	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  0183d	52		 push	 edx
  0183e	8d 45 d0	 lea	 eax, DWORD PTR _thumb$[ebp]
  01841	50		 push	 eax
  01842	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  01848	3b f4		 cmp	 esi, esp
  0184a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 926  : 
; 927  : 			RotateRect0(sb, &thumb);			

  0184f	8d 4d d0	 lea	 ecx, DWORD PTR _thumb$[ebp]
  01852	51		 push	 ecx
  01853	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01856	52		 push	 edx
  01857	e8 00 00 00 00	 call	 _RotateRect0@8

; 928  : 
; 929  : 			if(fCustomDraw)

  0185c	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01860	74 5d		 je	 SHORT $L22865

; 930  : 			{
; 931  : 				PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &thumb, SB_THUMBTRACK, uDrawFlags==HTSCROLL_THUMB, uHitTestPortion == HTSCROLL_THUMB && fBarHot, FALSE);

  01862	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _uHitTestPortion, 5
  01869	75 15		 jne	 SHORT $L23915
  0186b	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _fBarHot$[ebp], 0
  01872	74 0c		 je	 SHORT $L23915
  01874	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv315[ebp], 1
  0187e	eb 0a		 jmp	 SHORT $L23916
$L23915:
  01880	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv315[ebp], 0
$L23916:
  0188a	6a 00		 push	 0
  0188c	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv315[ebp]
  01892	50		 push	 eax
  01893	33 c9		 xor	 ecx, ecx
  01895	83 7d 18 05	 cmp	 DWORD PTR _uDrawFlags$[ebp], 5
  01899	0f 94 c1	 sete	 cl
  0189c	51		 push	 ecx
  0189d	6a 05		 push	 5
  0189f	8d 55 d0	 lea	 edx, DWORD PTR _thumb$[ebp]
  018a2	52		 push	 edx
  018a3	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  018a6	8b 88 40 03 00
	00		 mov	 ecx, DWORD PTR [eax+832]
  018ac	51		 push	 ecx
  018ad	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  018b0	52		 push	 edx
  018b1	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  018b4	50		 push	 eax
  018b5	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  018ba	83 c4 20	 add	 esp, 32			; 00000020H

; 932  : 			}
; 933  : 			else

  018bd	eb 6a		 jmp	 SHORT $L22866
$L22865:

; 934  : 			{
; 935  : 
; 936  : #ifdef FLAT_SCROLLBARS	
; 937  : 				if(hwnd == hwndCurCoolSB && sb->fFlatScrollbar && (uDrawFlags == HTSCROLL_THUMB || 
; 938  : 				(uHitTestPortion == HTSCROLL_THUMB && fBarHot)))

  018bf	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  018c2	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _hwndCurCoolSB
  018c8	75 48		 jne	 SHORT $L22867
  018ca	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  018cd	83 ba 44 03 00
	00 00		 cmp	 DWORD PTR [edx+836], 0
  018d4	74 3c		 je	 SHORT $L22867
  018d6	83 7d 18 05	 cmp	 DWORD PTR _uDrawFlags$[ebp], 5
  018da	74 12		 je	 SHORT $L22868
  018dc	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR _uHitTestPortion, 5
  018e3	75 2d		 jne	 SHORT $L22867
  018e5	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _fBarHot$[ebp], 0
  018ec	74 24		 je	 SHORT $L22867
$L22868:

; 939  : 				{	
; 940  : 					PaintRect(hdc, &thumb, GetSysColor(COLOR_3DSHADOW));

  018ee	8b f4		 mov	 esi, esp
  018f0	6a 10		 push	 16			; 00000010H
  018f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  018f8	3b f4		 cmp	 esi, esp
  018fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  018ff	50		 push	 eax
  01900	8d 45 d0	 lea	 eax, DWORD PTR _thumb$[ebp]
  01903	50		 push	 eax
  01904	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01907	51		 push	 ecx
  01908	e8 00 00 00 00	 call	 _PaintRect
  0190d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 941  : 				}
; 942  : 				else

  01910	eb 17		 jmp	 SHORT $L22866
$L22867:

; 943  : #endif
; 944  : 				{
; 945  : 					DrawBlankButton(hdc, &thumb, uDEFlat);

  01912	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _uDEFlat$[ebp]
  01918	52		 push	 edx
  01919	8d 45 d0	 lea	 eax, DWORD PTR _thumb$[ebp]
  0191c	50		 push	 eax
  0191d	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01920	51		 push	 ecx
  01921	e8 00 00 00 00	 call	 _DrawBlankButton
  01926	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22866:

; 946  : 				}
; 947  : 			}
; 948  : 			RotateRect0(sb, &thumb);

  01929	8d 55 d0	 lea	 edx, DWORD PTR _thumb$[ebp]
  0192c	52		 push	 edx
  0192d	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01930	50		 push	 eax
  01931	e8 00 00 00 00	 call	 _RotateRect0@8

; 949  : 
; 950  : 		}
; 951  : 		//otherwise, just leave that whole area blank
; 952  : 		else

  01936	e9 dd 01 00 00	 jmp	 $L22870
$L22856:

; 953  : 		{
; 954  : 			OffsetRect(&ctrl, butwidth, 0);

  0193b	8b f4		 mov	 esi, esp
  0193d	6a 00		 push	 0
  0193f	8b 4d b0	 mov	 ecx, DWORD PTR _butwidth$[ebp]
  01942	51		 push	 ecx
  01943	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01946	52		 push	 edx
  01947	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  0194d	3b f4		 cmp	 esi, esp
  0194f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 955  : 			ctrl.right = rect->right - butwidth;

  01954	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01957	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0195a	2b 4d b0	 sub	 ecx, DWORD PTR _butwidth$[ebp]
  0195d	89 4d f0	 mov	 DWORD PTR _ctrl$[ebp+8], ecx

; 956  : 
; 957  : 			//if we always show the thumb covering the whole scrollbar,
; 958  : 			//then draw it that way
; 959  : 			if(!IsScrollInfoActive(si)	&& (sb->fScrollFlags & CSBS_THUMBALWAYS) 
; 960  : 				&& ctrl.right - ctrl.left > sb->nMinThumbSize)

  01960	8b 55 fc	 mov	 edx, DWORD PTR _si$[ebp]
  01963	52		 push	 edx
  01964	e8 00 00 00 00	 call	 _IsScrollInfoActive
  01969	83 c4 04	 add	 esp, 4
  0196c	85 c0		 test	 eax, eax
  0196e	0f 85 3e 01 00
	00		 jne	 $L22871
  01974	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01977	8b 08		 mov	 ecx, DWORD PTR [eax]
  01979	83 e1 04	 and	 ecx, 4
  0197c	0f 84 30 01 00
	00		 je	 $L22871
  01982	8b 55 f0	 mov	 edx, DWORD PTR _ctrl$[ebp+8]
  01985	2b 55 e8	 sub	 edx, DWORD PTR _ctrl$[ebp]
  01988	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0198b	3b 90 48 03 00
	00		 cmp	 edx, DWORD PTR [eax+840]
  01991	0f 8e 1b 01 00
	00		 jle	 $L22871

; 961  : 			{
; 962  : 				//leave a 1-pixel gap between the thumb + right button
; 963  : 				ctrl.right --;

  01997	8b 4d f0	 mov	 ecx, DWORD PTR _ctrl$[ebp+8]
  0199a	83 e9 01	 sub	 ecx, 1
  0199d	89 4d f0	 mov	 DWORD PTR _ctrl$[ebp+8], ecx

; 964  : 				RotateRect0(sb, &ctrl);

  019a0	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  019a3	52		 push	 edx
  019a4	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  019a7	50		 push	 eax
  019a8	e8 00 00 00 00	 call	 _RotateRect0@8

; 965  : 
; 966  : 				if(fCustomDraw)

  019ad	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  019b1	74 2a		 je	 SHORT $L22872

; 967  : 					PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_THUMBTRACK, fMouseDownL, FALSE, FALSE);

  019b3	6a 00		 push	 0
  019b5	6a 00		 push	 0
  019b7	8b 4d 80	 mov	 ecx, DWORD PTR _fMouseDownL$[ebp]
  019ba	51		 push	 ecx
  019bb	6a 05		 push	 5
  019bd	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  019c0	52		 push	 edx
  019c1	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  019c4	8b 88 40 03 00
	00		 mov	 ecx, DWORD PTR [eax+832]
  019ca	51		 push	 ecx
  019cb	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  019ce	52		 push	 edx
  019cf	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  019d2	50		 push	 eax
  019d3	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  019d8	83 c4 20	 add	 esp, 32			; 00000020H

; 968  : 				else

  019db	eb 4d		 jmp	 SHORT $L22873
$L22872:

; 969  : 				{
; 970  : #ifdef FLAT_SCROLLBARS	
; 971  : 					if(sb->fFlatScrollbar == CSBS_HOTTRACKED && uDrawFlags == HTSCROLL_THUMB)

  019dd	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  019e0	83 b9 44 03 00
	00 02		 cmp	 DWORD PTR [ecx+836], 2
  019e7	75 2a		 jne	 SHORT $L22874
  019e9	83 7d 18 05	 cmp	 DWORD PTR _uDrawFlags$[ebp], 5
  019ed	75 24		 jne	 SHORT $L22874

; 972  : 						PaintRect(hdc, &ctrl, GetSysColor(COLOR_3DSHADOW));

  019ef	8b f4		 mov	 esi, esp
  019f1	6a 10		 push	 16			; 00000010H
  019f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  019f9	3b f4		 cmp	 esi, esp
  019fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01a00	50		 push	 eax
  01a01	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01a04	52		 push	 edx
  01a05	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  01a08	50		 push	 eax
  01a09	e8 00 00 00 00	 call	 _PaintRect
  01a0e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 973  : 					else

  01a11	eb 17		 jmp	 SHORT $L22873
$L22874:

; 974  : #endif
; 975  : 						DrawBlankButton(hdc, &ctrl, uDEFlat);

  01a13	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _uDEFlat$[ebp]
  01a19	51		 push	 ecx
  01a1a	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01a1d	52		 push	 edx
  01a1e	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  01a21	50		 push	 eax
  01a22	e8 00 00 00 00	 call	 _DrawBlankButton
  01a27	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22873:

; 976  : 
; 977  : 				}
; 978  : 				RotateRect0(sb, &ctrl);

  01a2a	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01a2d	51		 push	 ecx
  01a2e	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01a31	52		 push	 edx
  01a32	e8 00 00 00 00	 call	 _RotateRect0@8

; 979  : 
; 980  : 				//draw the single-line gap
; 981  : 				ctrl.left = ctrl.right;

  01a37	8b 45 f0	 mov	 eax, DWORD PTR _ctrl$[ebp+8]
  01a3a	89 45 e8	 mov	 DWORD PTR _ctrl$[ebp], eax

; 982  : 				ctrl.right += 1;

  01a3d	8b 4d f0	 mov	 ecx, DWORD PTR _ctrl$[ebp+8]
  01a40	83 c1 01	 add	 ecx, 1
  01a43	89 4d f0	 mov	 DWORD PTR _ctrl$[ebp+8], ecx

; 983  : 				
; 984  : 				RotateRect0(sb, &ctrl);

  01a46	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01a49	52		 push	 edx
  01a4a	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01a4d	50		 push	 eax
  01a4e	e8 00 00 00 00	 call	 _RotateRect0@8

; 985  : 				
; 986  : 				if(fCustomDraw)

  01a53	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01a57	74 28		 je	 SHORT $L22876

; 987  : 					PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_PAGERIGHT, 0, 0, 0);

  01a59	6a 00		 push	 0
  01a5b	6a 00		 push	 0
  01a5d	6a 00		 push	 0
  01a5f	6a 03		 push	 3
  01a61	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01a64	51		 push	 ecx
  01a65	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01a68	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  01a6e	50		 push	 eax
  01a6f	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01a72	51		 push	 ecx
  01a73	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  01a76	52		 push	 edx
  01a77	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01a7c	83 c4 20	 add	 esp, 32			; 00000020H

; 988  : 				else

  01a7f	eb 22		 jmp	 SHORT $L22877
$L22876:

; 989  : 					PaintRect(hdc, &ctrl, GetSysColor(COLOR_SCROLLBAR));

  01a81	8b f4		 mov	 esi, esp
  01a83	6a 00		 push	 0
  01a85	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  01a8b	3b f4		 cmp	 esi, esp
  01a8d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01a92	50		 push	 eax
  01a93	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01a96	50		 push	 eax
  01a97	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01a9a	51		 push	 ecx
  01a9b	e8 00 00 00 00	 call	 _PaintRect
  01aa0	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22877:

; 990  : 
; 991  : 				RotateRect0(sb, &ctrl);

  01aa3	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01aa6	52		 push	 edx
  01aa7	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01aaa	50		 push	 eax
  01aab	e8 00 00 00 00	 call	 _RotateRect0@8

; 992  : 			}
; 993  : 			//otherwise, paint a blank if the thumb doesn't fit in
; 994  : 			else

  01ab0	eb 66		 jmp	 SHORT $L22870
$L22871:

; 995  : 			{
; 996  : 				RotateRect0(sb, &ctrl);

  01ab2	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01ab5	51		 push	 ecx
  01ab6	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01ab9	52		 push	 edx
  01aba	e8 00 00 00 00	 call	 _RotateRect0@8

; 997  : 	
; 998  : 				if(fCustomDraw)

  01abf	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01ac3	74 28		 je	 SHORT $L22879

; 999  : 					PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_PAGERIGHT, 0, 0, 0);

  01ac5	6a 00		 push	 0
  01ac7	6a 00		 push	 0
  01ac9	6a 00		 push	 0
  01acb	6a 03		 push	 3
  01acd	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01ad0	50		 push	 eax
  01ad1	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01ad4	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  01ada	52		 push	 edx
  01adb	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  01ade	50		 push	 eax
  01adf	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  01ae2	51		 push	 ecx
  01ae3	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01ae8	83 c4 20	 add	 esp, 32			; 00000020H

; 1000 : 				else

  01aeb	eb 1e		 jmp	 SHORT $L22880
$L22879:

; 1001 : 					DrawCheckedRect(hdc, &ctrl, crCheck1, crCheck2);

  01aed	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _crCheck2$[ebp]
  01af3	52		 push	 edx
  01af4	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _crCheck1$[ebp]
  01afa	50		 push	 eax
  01afb	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01afe	51		 push	 ecx
  01aff	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  01b02	52		 push	 edx
  01b03	e8 00 00 00 00	 call	 _DrawCheckedRect
  01b08	83 c4 10	 add	 esp, 16			; 00000010H
$L22880:

; 1002 : 				
; 1003 : 				RotateRect0(sb, &ctrl);

  01b0b	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01b0e	50		 push	 eax
  01b0f	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01b12	51		 push	 ecx
  01b13	e8 00 00 00 00	 call	 _RotateRect0@8
$L22870:

; 1004 : 			}
; 1005 : 		}
; 1006 : 
; 1007 : 		//RIGHT ARROW
; 1008 : 		SetRect(&ctrl, rect->right - butwidth, rect->top, rect->right, rect->bottom);

  01b18	8b f4		 mov	 esi, esp
  01b1a	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  01b1d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01b20	50		 push	 eax
  01b21	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  01b24	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01b27	52		 push	 edx
  01b28	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01b2b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01b2e	51		 push	 ecx
  01b2f	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  01b32	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01b35	2b 45 b0	 sub	 eax, DWORD PTR _butwidth$[ebp]
  01b38	50		 push	 eax
  01b39	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01b3c	51		 push	 ecx
  01b3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  01b43	3b f4		 cmp	 esi, esp
  01b45	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1009 : 
; 1010 : 		RotateRect0(sb, &ctrl);

  01b4a	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01b4d	52		 push	 edx
  01b4e	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01b51	50		 push	 eax
  01b52	e8 00 00 00 00	 call	 _RotateRect0@8

; 1011 : 
; 1012 : 		if(fCustomDraw)

  01b57	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01b5b	74 3d		 je	 SHORT $L22881

; 1013 : 			PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_LINERIGHT, fMouseDownR, fMouseOverR, uRightButFlags & DFCS_INACTIVE);

  01b5d	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _uRightButFlags$[ebp]
  01b63	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  01b69	51		 push	 ecx
  01b6a	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _fMouseOverR$[ebp]
  01b70	52		 push	 edx
  01b71	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _fMouseDownR$[ebp]
  01b77	50		 push	 eax
  01b78	6a 01		 push	 1
  01b7a	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01b7d	51		 push	 ecx
  01b7e	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01b81	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  01b87	50		 push	 eax
  01b88	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01b8b	51		 push	 ecx
  01b8c	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  01b8f	52		 push	 edx
  01b90	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01b95	83 c4 20	 add	 esp, 32			; 00000020H

; 1014 : 		else

  01b98	eb 29		 jmp	 SHORT $L22882
$L22881:

; 1015 : 			DrawScrollArrow(sb, hdc, &ctrl, uRightButFlags, fMouseDownR, fMouseOverR);

  01b9a	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _fMouseOverR$[ebp]
  01ba0	50		 push	 eax
  01ba1	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _fMouseDownR$[ebp]
  01ba7	51		 push	 ecx
  01ba8	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR _uRightButFlags$[ebp]
  01bae	52		 push	 edx
  01baf	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01bb2	50		 push	 eax
  01bb3	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01bb6	51		 push	 ecx
  01bb7	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01bba	52		 push	 edx
  01bbb	e8 00 00 00 00	 call	 _DrawScrollArrow
  01bc0	83 c4 18	 add	 esp, 24			; 00000018H
$L22882:

; 1016 : 
; 1017 : 		RotateRect0(sb, &ctrl);

  01bc3	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01bc6	50		 push	 eax
  01bc7	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01bca	51		 push	 ecx
  01bcb	e8 00 00 00 00	 call	 _RotateRect0@8

; 1018 : 	}
; 1019 : 	//not enough room for the scrollbar, so just draw the buttons (scaled in size to fit)
; 1020 : 	else

  01bd0	e9 e1 01 00 00	 jmp	 $L22883
$L22853:

; 1021 : 	{
; 1022 : 		butwidth = scrollwidth / 2;

  01bd5	8b 45 ac	 mov	 eax, DWORD PTR _scrollwidth$[ebp]
  01bd8	99		 cdq
  01bd9	2b c2		 sub	 eax, edx
  01bdb	d1 f8		 sar	 eax, 1
  01bdd	89 45 b0	 mov	 DWORD PTR _butwidth$[ebp], eax

; 1023 : 
; 1024 : 		//LEFT ARROW
; 1025 : 		SetRect(&ctrl, rect->left, rect->top, rect->left + butwidth, rect->bottom);

  01be0	8b f4		 mov	 esi, esp
  01be2	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  01be5	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01be8	50		 push	 eax
  01be9	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  01bec	8b 11		 mov	 edx, DWORD PTR [ecx]
  01bee	03 55 b0	 add	 edx, DWORD PTR _butwidth$[ebp]
  01bf1	52		 push	 edx
  01bf2	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  01bf5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01bf8	51		 push	 ecx
  01bf9	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  01bfc	8b 02		 mov	 eax, DWORD PTR [edx]
  01bfe	50		 push	 eax
  01bff	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01c02	51		 push	 ecx
  01c03	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  01c09	3b f4		 cmp	 esi, esp
  01c0b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1026 : 
; 1027 : 		RotateRect0(sb, &ctrl);

  01c10	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01c13	52		 push	 edx
  01c14	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01c17	50		 push	 eax
  01c18	e8 00 00 00 00	 call	 _RotateRect0@8

; 1028 : 		if(fCustomDraw)

  01c1d	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01c21	74 3a		 je	 SHORT $L22884

; 1029 : 			PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_LINELEFT, fMouseDownL, fMouseOverL, uLeftButFlags & DFCS_INACTIVE);

  01c23	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _uLeftButFlags$[ebp]
  01c29	81 e1 00 01 00
	00		 and	 ecx, 256		; 00000100H
  01c2f	51		 push	 ecx
  01c30	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _fMouseOverL$[ebp]
  01c36	52		 push	 edx
  01c37	8b 45 80	 mov	 eax, DWORD PTR _fMouseDownL$[ebp]
  01c3a	50		 push	 eax
  01c3b	6a 00		 push	 0
  01c3d	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01c40	51		 push	 ecx
  01c41	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01c44	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  01c4a	50		 push	 eax
  01c4b	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01c4e	51		 push	 ecx
  01c4f	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  01c52	52		 push	 edx
  01c53	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01c58	83 c4 20	 add	 esp, 32			; 00000020H

; 1030 : 		else	

  01c5b	eb 26		 jmp	 SHORT $L22885
$L22884:

; 1031 : 			DrawScrollArrow(sb, hdc, &ctrl, uLeftButFlags, fMouseDownL, fMouseOverL);

  01c5d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _fMouseOverL$[ebp]
  01c63	50		 push	 eax
  01c64	8b 4d 80	 mov	 ecx, DWORD PTR _fMouseDownL$[ebp]
  01c67	51		 push	 ecx
  01c68	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _uLeftButFlags$[ebp]
  01c6e	52		 push	 edx
  01c6f	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01c72	50		 push	 eax
  01c73	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01c76	51		 push	 ecx
  01c77	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01c7a	52		 push	 edx
  01c7b	e8 00 00 00 00	 call	 _DrawScrollArrow
  01c80	83 c4 18	 add	 esp, 24			; 00000018H
$L22885:

; 1032 : 		RotateRect0(sb, &ctrl);

  01c83	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01c86	50		 push	 eax
  01c87	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01c8a	51		 push	 ecx
  01c8b	e8 00 00 00 00	 call	 _RotateRect0@8

; 1033 : 
; 1034 : 		//RIGHT ARROW
; 1035 : 		OffsetRect(&ctrl, scrollwidth - butwidth, 0);

  01c90	8b f4		 mov	 esi, esp
  01c92	6a 00		 push	 0
  01c94	8b 55 ac	 mov	 edx, DWORD PTR _scrollwidth$[ebp]
  01c97	2b 55 b0	 sub	 edx, DWORD PTR _butwidth$[ebp]
  01c9a	52		 push	 edx
  01c9b	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01c9e	50		 push	 eax
  01c9f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  01ca5	3b f4		 cmp	 esi, esp
  01ca7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1036 : 		
; 1037 : 		RotateRect0(sb, &ctrl);

  01cac	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01caf	51		 push	 ecx
  01cb0	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01cb3	52		 push	 edx
  01cb4	e8 00 00 00 00	 call	 _RotateRect0@8

; 1038 : 		if(fCustomDraw)

  01cb9	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01cbd	74 3c		 je	 SHORT $L22886

; 1039 : 			PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_LINERIGHT, fMouseDownR, fMouseOverR, uRightButFlags & DFCS_INACTIVE);

  01cbf	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _uRightButFlags$[ebp]
  01cc5	25 00 01 00 00	 and	 eax, 256		; 00000100H
  01cca	50		 push	 eax
  01ccb	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _fMouseOverR$[ebp]
  01cd1	51		 push	 ecx
  01cd2	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _fMouseDownR$[ebp]
  01cd8	52		 push	 edx
  01cd9	6a 01		 push	 1
  01cdb	8d 45 e8	 lea	 eax, DWORD PTR _ctrl$[ebp]
  01cde	50		 push	 eax
  01cdf	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01ce2	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  01ce8	52		 push	 edx
  01ce9	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  01cec	50		 push	 eax
  01ced	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  01cf0	51		 push	 ecx
  01cf1	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01cf6	83 c4 20	 add	 esp, 32			; 00000020H

; 1040 : 		else

  01cf9	eb 29		 jmp	 SHORT $L22887
$L22886:

; 1041 : 			DrawScrollArrow(sb, hdc, &ctrl, uRightButFlags, fMouseDownR, fMouseOverR);		

  01cfb	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _fMouseOverR$[ebp]
  01d01	52		 push	 edx
  01d02	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _fMouseDownR$[ebp]
  01d08	50		 push	 eax
  01d09	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _uRightButFlags$[ebp]
  01d0f	51		 push	 ecx
  01d10	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01d13	52		 push	 edx
  01d14	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  01d17	50		 push	 eax
  01d18	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  01d1b	51		 push	 ecx
  01d1c	e8 00 00 00 00	 call	 _DrawScrollArrow
  01d21	83 c4 18	 add	 esp, 24			; 00000018H
$L22887:

; 1042 : 		RotateRect0(sb, &ctrl);

  01d24	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01d27	52		 push	 edx
  01d28	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01d2b	50		 push	 eax
  01d2c	e8 00 00 00 00	 call	 _RotateRect0@8

; 1043 : 
; 1044 : 		//if there is a gap between the buttons, fill it with a solid color
; 1045 : 		//if(butwidth & 0x0001)
; 1046 : 		if(ctrl.left != rect->left + butwidth)

  01d31	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  01d34	8b 11		 mov	 edx, DWORD PTR [ecx]
  01d36	03 55 b0	 add	 edx, DWORD PTR _butwidth$[ebp]
  01d39	39 55 e8	 cmp	 DWORD PTR _ctrl$[ebp], edx
  01d3c	74 78		 je	 SHORT $L22883

; 1047 : 		{
; 1048 : 			ctrl.left --;

  01d3e	8b 45 e8	 mov	 eax, DWORD PTR _ctrl$[ebp]
  01d41	83 e8 01	 sub	 eax, 1
  01d44	89 45 e8	 mov	 DWORD PTR _ctrl$[ebp], eax

; 1049 : 			ctrl.right -= butwidth;

  01d47	8b 4d f0	 mov	 ecx, DWORD PTR _ctrl$[ebp+8]
  01d4a	2b 4d b0	 sub	 ecx, DWORD PTR _butwidth$[ebp]
  01d4d	89 4d f0	 mov	 DWORD PTR _ctrl$[ebp+8], ecx

; 1050 : 			RotateRect0(sb, &ctrl);

  01d50	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01d53	52		 push	 edx
  01d54	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01d57	50		 push	 eax
  01d58	e8 00 00 00 00	 call	 _RotateRect0@8

; 1051 : 			
; 1052 : 			if(fCustomDraw)

  01d5d	83 7d 84 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  01d61	74 28		 je	 SHORT $L22889

; 1053 : 				PostCustomDrawNotify(hwnd, hdc, sb->nBarType, &ctrl, SB_PAGERIGHT, 0, 0, 0);

  01d63	6a 00		 push	 0
  01d65	6a 00		 push	 0
  01d67	6a 00		 push	 0
  01d69	6a 03		 push	 3
  01d6b	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01d6e	51		 push	 ecx
  01d6f	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01d72	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  01d78	50		 push	 eax
  01d79	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01d7c	51		 push	 ecx
  01d7d	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  01d80	52		 push	 edx
  01d81	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  01d86	83 c4 20	 add	 esp, 32			; 00000020H

; 1054 : 			else

  01d89	eb 1e		 jmp	 SHORT $L22890
$L22889:

; 1055 : 				DrawCheckedRect(hdc, &ctrl, crCheck1, crCheck2);

  01d8b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _crCheck2$[ebp]
  01d91	50		 push	 eax
  01d92	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  01d98	51		 push	 ecx
  01d99	8d 55 e8	 lea	 edx, DWORD PTR _ctrl$[ebp]
  01d9c	52		 push	 edx
  01d9d	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  01da0	50		 push	 eax
  01da1	e8 00 00 00 00	 call	 _DrawCheckedRect
  01da6	83 c4 10	 add	 esp, 16			; 00000010H
$L22890:

; 1056 : 
; 1057 : 			RotateRect0(sb, &ctrl);

  01da9	8d 4d e8	 lea	 ecx, DWORD PTR _ctrl$[ebp]
  01dac	51		 push	 ecx
  01dad	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  01db0	52		 push	 edx
  01db1	e8 00 00 00 00	 call	 _RotateRect0@8
$L22883:

; 1058 : 		}
; 1059 : 			
; 1060 : 	}
; 1061 : 
; 1062 : #ifdef CUSTOM_DRAW
; 1063 : 	PostCustomPrePostPaint(hwnd, hdc, sb, CDDS_POSTPAINT);

  01db6	6a 02		 push	 2
  01db8	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01dbb	50		 push	 eax
  01dbc	8b 4d 10	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01dbf	51		 push	 ecx
  01dc0	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  01dc3	52		 push	 edx
  01dc4	e8 00 00 00 00	 call	 _PostCustomPrePostPaint0
  01dc9	83 c4 10	 add	 esp, 16			; 00000010H

; 1064 : #endif
; 1065 : 
; 1066 : 	return fCustomDraw;

  01dcc	8b 45 84	 mov	 eax, DWORD PTR _fCustomDraw$[ebp]
$L22818:

; 1067 : }

  01dcf	52		 push	 edx
  01dd0	8b cd		 mov	 ecx, ebp
  01dd2	50		 push	 eax
  01dd3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23923
  01dd9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  01dde	58		 pop	 eax
  01ddf	5a		 pop	 edx
  01de0	5f		 pop	 edi
  01de1	5e		 pop	 esi
  01de2	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  01de8	3b ec		 cmp	 ebp, esp
  01dea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01def	8b e5		 mov	 esp, ebp
  01df1	5d		 pop	 ebp
  01df2	c3		 ret	 0
$L23923:
  01df3	05 00 00 00	 DD	 5
  01df7	00 00 00 00	 DD	 $L23922
$L23922:
  01dfb	e8 ff ff ff	 DD	 -24			; ffffffe8H
  01dff	10 00 00 00	 DD	 16			; 00000010H
  01e03	00 00 00 00	 DD	 $L23917
  01e07	d0 ff ff ff	 DD	 -48			; ffffffd0H
  01e0b	10 00 00 00	 DD	 16			; 00000010H
  01e0f	00 00 00 00	 DD	 $L23918
  01e13	b8 ff ff ff	 DD	 -72			; ffffffb8H
  01e17	10 00 00 00	 DD	 16			; 00000010H
  01e1b	00 00 00 00	 DD	 $L23919
  01e1f	a0 ff ff ff	 DD	 -96			; ffffffa0H
  01e23	04 00 00 00	 DD	 4
  01e27	00 00 00 00	 DD	 $L23920
  01e2b	94 ff ff ff	 DD	 -108			; ffffff94H
  01e2f	04 00 00 00	 DD	 4
  01e33	00 00 00 00	 DD	 $L23921
$L23921:
  01e37	74		 DB	 116			; 00000074H
  01e38	68		 DB	 104			; 00000068H
  01e39	75		 DB	 117			; 00000075H
  01e3a	6d		 DB	 109			; 0000006dH
  01e3b	62		 DB	 98			; 00000062H
  01e3c	70		 DB	 112			; 00000070H
  01e3d	6f		 DB	 111			; 0000006fH
  01e3e	73		 DB	 115			; 00000073H
  01e3f	00		 DB	 0
$L23920:
  01e40	74		 DB	 116			; 00000074H
  01e41	68		 DB	 104			; 00000068H
  01e42	75		 DB	 117			; 00000075H
  01e43	6d		 DB	 109			; 0000006dH
  01e44	62		 DB	 98			; 00000062H
  01e45	77		 DB	 119			; 00000077H
  01e46	69		 DB	 105			; 00000069H
  01e47	64		 DB	 100			; 00000064H
  01e48	74		 DB	 116			; 00000074H
  01e49	68		 DB	 104			; 00000068H
  01e4a	00		 DB	 0
$L23919:
  01e4b	73		 DB	 115			; 00000073H
  01e4c	62		 DB	 98			; 00000062H
  01e4d	6d		 DB	 109			; 0000006dH
  01e4e	00		 DB	 0
$L23918:
  01e4f	74		 DB	 116			; 00000074H
  01e50	68		 DB	 104			; 00000068H
  01e51	75		 DB	 117			; 00000075H
  01e52	6d		 DB	 109			; 0000006dH
  01e53	62		 DB	 98			; 00000062H
  01e54	00		 DB	 0
$L23917:
  01e55	63		 DB	 99			; 00000063H
  01e56	74		 DB	 116			; 00000074H
  01e57	72		 DB	 114			; 00000072H
  01e58	6c		 DB	 108			; 0000006cH
  01e59	00		 DB	 0
_NCDrawHScrollbar ENDP
; Function compile flags: /Odt /RTCsu
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_RotateRect0@8 PROC NEAR

; 133  : {

  01e60	55		 push	 ebp
  01e61	8b ec		 mov	 ebp, esp

; 134  : 	if(sb->nBarType == SB_VERT)

  01e63	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  01e66	83 b8 40 03 00
	00 01		 cmp	 DWORD PTR [eax+832], 1
  01e6d	75 09		 jne	 SHORT $L22475

; 135  : 		RotateRect(rect);

  01e6f	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  01e72	51		 push	 ecx
  01e73	e8 00 00 00 00	 call	 _RotateRect@4
$L22475:

; 136  : }

  01e78	3b ec		 cmp	 ebp, esp
  01e7a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01e7f	5d		 pop	 ebp
  01e80	c2 08 00	 ret	 8
_RotateRect0@8 ENDP
; Function compile flags: /Odt /RTCsu
_temp$ = -4						; size = 4
_rect$ = 8						; size = 4
_RotateRect@4 PROC NEAR

; 118  : {

  01e90	55		 push	 ebp
  01e91	8b ec		 mov	 ebp, esp
  01e93	51		 push	 ecx
  01e94	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 119  : 	int temp;
; 120  : 	temp = rect->left;

  01e9b	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  01e9e	8b 08		 mov	 ecx, DWORD PTR [eax]
  01ea0	89 4d fc	 mov	 DWORD PTR _temp$[ebp], ecx

; 121  : 	rect->left = rect->top;

  01ea3	8b 55 08	 mov	 edx, DWORD PTR _rect$[ebp]
  01ea6	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  01ea9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01eac	89 0a		 mov	 DWORD PTR [edx], ecx

; 122  : 	rect->top = temp;

  01eae	8b 55 08	 mov	 edx, DWORD PTR _rect$[ebp]
  01eb1	8b 45 fc	 mov	 eax, DWORD PTR _temp$[ebp]
  01eb4	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 123  : 
; 124  : 	temp = rect->right;

  01eb7	8b 4d 08	 mov	 ecx, DWORD PTR _rect$[ebp]
  01eba	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01ebd	89 55 fc	 mov	 DWORD PTR _temp$[ebp], edx

; 125  : 	rect->right = rect->bottom;

  01ec0	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  01ec3	8b 4d 08	 mov	 ecx, DWORD PTR _rect$[ebp]
  01ec6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01ec9	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 126  : 	rect->bottom = temp;

  01ecc	8b 45 08	 mov	 eax, DWORD PTR _rect$[ebp]
  01ecf	8b 4d fc	 mov	 ecx, DWORD PTR _temp$[ebp]
  01ed2	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 127  : }

  01ed5	8b e5		 mov	 esp, ebp
  01ed7	5d		 pop	 ebp
  01ed8	c2 04 00	 ret	 4
_RotateRect@4 ENDP
; Function compile flags: /Odt /RTCsu
_si$ = 8						; size = 4
_IsScrollInfoActive PROC NEAR

; 143  : {

  01ee0	55		 push	 ebp
  01ee1	8b ec		 mov	 ebp, esp

; 144  : 	if((si->nPage > (UINT)si->nMax
; 145  : 		|| si->nMax <= si->nMin || si->nMax == 0))

  01ee3	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  01ee6	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01ee9	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01eec	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  01eef	77 17		 ja	 SHORT $L22483
  01ef1	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  01ef4	8b 4d 08	 mov	 ecx, DWORD PTR _si$[ebp]
  01ef7	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01efa	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  01efd	7e 09		 jle	 SHORT $L22483
  01eff	8b 45 08	 mov	 eax, DWORD PTR _si$[ebp]
  01f02	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  01f06	75 04		 jne	 SHORT $L22482
$L22483:

; 146  : 		return FALSE;

  01f08	33 c0		 xor	 eax, eax
  01f0a	eb 05		 jmp	 SHORT $L22480
$L22482:

; 147  : 	else
; 148  : 		return TRUE;

  01f0c	b8 01 00 00 00	 mov	 eax, 1
$L22480:

; 149  : }

  01f11	5d		 pop	 ebp
  01f12	c3		 ret	 0
_IsScrollInfoActive ENDP
_TEXT	ENDS
EXTRN	__imp__BitBlt@36:NEAR
EXTRN	__imp__CreateBitmap@20:NEAR
EXTRN	__imp__CreateCompatibleBitmap@12:NEAR
EXTRN	__imp__CreateCompatibleDC@4:NEAR
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	__imp__DeleteObject@4:NEAR
EXTRN	__imp__UnrealizeObject@4:NEAR
EXTRN	__imp__GetStockObject@4:NEAR
EXTRN	__imp__SelectObject@8:NEAR
EXTRN	__imp__SetTextColor@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_height$22522 = -64					; size = 4
_width$22521 = -60					; size = 4
_rc$22520 = -52						; size = 16
_oldbm2$22519 = -32					; size = 4
_hbm2$22518 = -28					; size = 4
_oldbm1$22517 = -24					; size = 4
_hbm1$22516 = -20					; size = 4
_hdcmem2$22515 = -16					; size = 4
_hdcmem1$22514 = -12					; size = 4
_flags$ = -8						; size = 4
_ret$ = -4						; size = 4
_sbar$ = 8						; size = 4
_hdc$ = 12						; size = 4
_rect$ = 16						; size = 4
_arrow$ = 20						; size = 4
_fMouseDown$ = 24					; size = 4
_fMouseOver$ = 28					; size = 4
_DrawScrollArrow PROC NEAR

; 168  : {

  01f20	55		 push	 ebp
  01f21	8b ec		 mov	 ebp, esp
  01f23	83 ec 40	 sub	 esp, 64			; 00000040H
  01f26	56		 push	 esi
  01f27	57		 push	 edi
  01f28	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  01f2b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  01f30	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  01f35	f3 ab		 rep stosd

; 169  : 	UINT ret;
; 170  : 	UINT flags = arrow;

  01f37	8b 45 14	 mov	 eax, DWORD PTR _arrow$[ebp]
  01f3a	89 45 f8	 mov	 DWORD PTR _flags$[ebp], eax

; 171  : 
; 172  : 	//HACKY bit so this routine can be called by vertical and horizontal code
; 173  : 	if(sbar->nBarType == SB_VERT)

  01f3d	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  01f40	83 b9 40 03 00
	00 01		 cmp	 DWORD PTR [ecx+832], 1
  01f47	75 25		 jne	 SHORT $L22509

; 174  : 	{
; 175  : 		if(flags & DFCS_SCROLLLEFT)		flags = flags & ~DFCS_SCROLLLEFT  | DFCS_SCROLLUP;

  01f49	8b 55 f8	 mov	 edx, DWORD PTR _flags$[ebp]
  01f4c	83 e2 02	 and	 edx, 2
  01f4f	74 09		 je	 SHORT $L22510
  01f51	8b 45 f8	 mov	 eax, DWORD PTR _flags$[ebp]
  01f54	83 e0 fd	 and	 eax, -3			; fffffffdH
  01f57	89 45 f8	 mov	 DWORD PTR _flags$[ebp], eax
$L22510:

; 176  : 		if(flags & DFCS_SCROLLRIGHT)	flags = flags & ~DFCS_SCROLLRIGHT | DFCS_SCROLLDOWN;

  01f5a	8b 4d f8	 mov	 ecx, DWORD PTR _flags$[ebp]
  01f5d	83 e1 03	 and	 ecx, 3
  01f60	74 0c		 je	 SHORT $L22509
  01f62	8b 55 f8	 mov	 edx, DWORD PTR _flags$[ebp]
  01f65	83 e2 fc	 and	 edx, -4			; fffffffcH
  01f68	83 ca 01	 or	 edx, 1
  01f6b	89 55 f8	 mov	 DWORD PTR _flags$[ebp], edx
$L22509:

; 177  : 	}
; 178  : 
; 179  : 	if(fMouseDown) flags |= (DFCS_FLAT | DFCS_PUSHED);

  01f6e	83 7d 18 00	 cmp	 DWORD PTR _fMouseDown$[ebp], 0
  01f72	74 0b		 je	 SHORT $L22512
  01f74	8b 45 f8	 mov	 eax, DWORD PTR _flags$[ebp]
  01f77	0d 00 42 00 00	 or	 eax, 16896		; 00004200H
  01f7c	89 45 f8	 mov	 DWORD PTR _flags$[ebp], eax
$L22512:

; 180  : 
; 181  : #ifdef FLAT_SCROLLBARS
; 182  : 	if(sbar->fFlatScrollbar != CSBS_NORMAL)

  01f7f	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  01f82	83 b9 44 03 00
	00 00		 cmp	 DWORD PTR [ecx+836], 0
  01f89	0f 84 c0 03 00
	00		 je	 $L22513

; 183  : 	{
; 184  : 		HDC hdcmem1, hdcmem2;
; 185  : 		HBITMAP hbm1, oldbm1;
; 186  : 		HBITMAP hbm2, oldbm2;
; 187  : 		RECT rc;
; 188  : 		int width, height;
; 189  : 
; 190  : 		rc = *rect;

  01f8f	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  01f92	8b 02		 mov	 eax, DWORD PTR [edx]
  01f94	89 45 cc	 mov	 DWORD PTR _rc$22520[ebp], eax
  01f97	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  01f9a	89 4d d0	 mov	 DWORD PTR _rc$22520[ebp+4], ecx
  01f9d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01fa0	89 45 d4	 mov	 DWORD PTR _rc$22520[ebp+8], eax
  01fa3	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  01fa6	89 4d d8	 mov	 DWORD PTR _rc$22520[ebp+12], ecx

; 191  : 		width  = rc.right-rc.left;

  01fa9	8b 55 d4	 mov	 edx, DWORD PTR _rc$22520[ebp+8]
  01fac	2b 55 cc	 sub	 edx, DWORD PTR _rc$22520[ebp]
  01faf	89 55 c4	 mov	 DWORD PTR _width$22521[ebp], edx

; 192  : 		height = rc.bottom-rc.top;

  01fb2	8b 45 d8	 mov	 eax, DWORD PTR _rc$22520[ebp+12]
  01fb5	2b 45 d0	 sub	 eax, DWORD PTR _rc$22520[ebp+4]
  01fb8	89 45 c0	 mov	 DWORD PTR _height$22522[ebp], eax

; 193  : 		SetRect(&rc, 0, 0, width, height);

  01fbb	8b f4		 mov	 esi, esp
  01fbd	8b 4d c0	 mov	 ecx, DWORD PTR _height$22522[ebp]
  01fc0	51		 push	 ecx
  01fc1	8b 55 c4	 mov	 edx, DWORD PTR _width$22521[ebp]
  01fc4	52		 push	 edx
  01fc5	6a 00		 push	 0
  01fc7	6a 00		 push	 0
  01fc9	8d 45 cc	 lea	 eax, DWORD PTR _rc$22520[ebp]
  01fcc	50		 push	 eax
  01fcd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  01fd3	3b f4		 cmp	 esi, esp
  01fd5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 194  : 
; 195  : 		//MONOCHROME bitmap to convert the arrow to black/white mask
; 196  : 		hdcmem1 = CreateCompatibleDC(hdc);

  01fda	8b f4		 mov	 esi, esp
  01fdc	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  01fdf	51		 push	 ecx
  01fe0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  01fe6	3b f4		 cmp	 esi, esp
  01fe8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01fed	89 45 f4	 mov	 DWORD PTR _hdcmem1$22514[ebp], eax

; 197  : 		hbm1    = CreateBitmap(width, height, 1, 1, NULL);

  01ff0	8b f4		 mov	 esi, esp
  01ff2	6a 00		 push	 0
  01ff4	6a 01		 push	 1
  01ff6	6a 01		 push	 1
  01ff8	8b 55 c0	 mov	 edx, DWORD PTR _height$22522[ebp]
  01ffb	52		 push	 edx
  01ffc	8b 45 c4	 mov	 eax, DWORD PTR _width$22521[ebp]
  01fff	50		 push	 eax
  02000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateBitmap@20
  02006	3b f4		 cmp	 esi, esp
  02008	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0200d	89 45 ec	 mov	 DWORD PTR _hbm1$22516[ebp], eax

; 198  : 		UnrealizeObject(hbm1);

  02010	8b f4		 mov	 esi, esp
  02012	8b 4d ec	 mov	 ecx, DWORD PTR _hbm1$22516[ebp]
  02015	51		 push	 ecx
  02016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnrealizeObject@4
  0201c	3b f4		 cmp	 esi, esp
  0201e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 199  : 		oldbm1  = SelectObject(hdcmem1, hbm1);

  02023	8b f4		 mov	 esi, esp
  02025	8b 55 ec	 mov	 edx, DWORD PTR _hbm1$22516[ebp]
  02028	52		 push	 edx
  02029	8b 45 f4	 mov	 eax, DWORD PTR _hdcmem1$22514[ebp]
  0202c	50		 push	 eax
  0202d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  02033	3b f4		 cmp	 esi, esp
  02035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0203a	89 45 e8	 mov	 DWORD PTR _oldbm1$22517[ebp], eax

; 200  : 		
; 201  : 
; 202  : 		//NORMAL bitmap to draw the arrow into
; 203  : 		hdcmem2 = CreateCompatibleDC(hdc);

  0203d	8b f4		 mov	 esi, esp
  0203f	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02042	51		 push	 ecx
  02043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  02049	3b f4		 cmp	 esi, esp
  0204b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02050	89 45 f0	 mov	 DWORD PTR _hdcmem2$22515[ebp], eax

; 204  : 		hbm2    = CreateCompatibleBitmap(hdc, width, height);

  02053	8b f4		 mov	 esi, esp
  02055	8b 55 c0	 mov	 edx, DWORD PTR _height$22522[ebp]
  02058	52		 push	 edx
  02059	8b 45 c4	 mov	 eax, DWORD PTR _width$22521[ebp]
  0205c	50		 push	 eax
  0205d	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02060	51		 push	 ecx
  02061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleBitmap@12
  02067	3b f4		 cmp	 esi, esp
  02069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0206e	89 45 e4	 mov	 DWORD PTR _hbm2$22518[ebp], eax

; 205  : 		UnrealizeObject(hbm2);

  02071	8b f4		 mov	 esi, esp
  02073	8b 55 e4	 mov	 edx, DWORD PTR _hbm2$22518[ebp]
  02076	52		 push	 edx
  02077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnrealizeObject@4
  0207d	3b f4		 cmp	 esi, esp
  0207f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 206  : 		oldbm2  = SelectObject(hdcmem2, hbm2);

  02084	8b f4		 mov	 esi, esp
  02086	8b 45 e4	 mov	 eax, DWORD PTR _hbm2$22518[ebp]
  02089	50		 push	 eax
  0208a	8b 4d f0	 mov	 ecx, DWORD PTR _hdcmem2$22515[ebp]
  0208d	51		 push	 ecx
  0208e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  02094	3b f4		 cmp	 esi, esp
  02096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0209b	89 45 e0	 mov	 DWORD PTR _oldbm2$22519[ebp], eax

; 207  : 		
; 208  : 
; 209  : 		flags = flags & ~DFCS_PUSHED | DFCS_FLAT;	//just in case

  0209e	8b 55 f8	 mov	 edx, DWORD PTR _flags$[ebp]
  020a1	81 e2 ff fd ff
	ff		 and	 edx, -513		; fffffdffH
  020a7	81 ca 00 40 00
	00		 or	 edx, 16384		; 00004000H
  020ad	89 55 f8	 mov	 DWORD PTR _flags$[ebp], edx

; 210  : 		DrawFrameControl(hdcmem2, &rc, DFC_SCROLL, flags);

  020b0	8b f4		 mov	 esi, esp
  020b2	8b 45 f8	 mov	 eax, DWORD PTR _flags$[ebp]
  020b5	50		 push	 eax
  020b6	6a 03		 push	 3
  020b8	8d 4d cc	 lea	 ecx, DWORD PTR _rc$22520[ebp]
  020bb	51		 push	 ecx
  020bc	8b 55 f0	 mov	 edx, DWORD PTR _hdcmem2$22515[ebp]
  020bf	52		 push	 edx
  020c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  020c6	3b f4		 cmp	 esi, esp
  020c8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 211  : 
; 212  : 
; 213  : #ifndef HOT_TRACKING
; 214  : 		if(fMouseDown)
; 215  : 		{
; 216  : 			//uncomment these to make the cool scrollbars
; 217  : 			//look like the common controls flat scrollbars
; 218  : 			//fMouseDown = FALSE;
; 219  : 			//fMouseOver = TRUE;
; 220  : 		}
; 221  : #endif
; 222  : 		//draw a flat monochrome version of a scrollbar arrow (dark)
; 223  : 		if(fMouseDown)

  020cd	83 7d 18 00	 cmp	 DWORD PTR _fMouseDown$[ebp], 0
  020d1	0f 84 c8 00 00
	00		 je	 $L22524

; 224  : 		{
; 225  : 			SetBkColor(hdcmem2, GetSysColor(COLOR_BTNTEXT));

  020d7	8b f4		 mov	 esi, esp
  020d9	6a 12		 push	 18			; 00000012H
  020db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  020e1	3b f4		 cmp	 esi, esp
  020e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  020e8	8b f4		 mov	 esi, esp
  020ea	50		 push	 eax
  020eb	8b 45 f0	 mov	 eax, DWORD PTR _hdcmem2$22515[ebp]
  020ee	50		 push	 eax
  020ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  020f5	3b f4		 cmp	 esi, esp
  020f7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 226  : 			BitBlt(hdcmem1, 0, 0, width, height, hdcmem2, 0, 0, SRCCOPY);

  020fc	8b f4		 mov	 esi, esp
  020fe	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  02103	6a 00		 push	 0
  02105	6a 00		 push	 0
  02107	8b 4d f0	 mov	 ecx, DWORD PTR _hdcmem2$22515[ebp]
  0210a	51		 push	 ecx
  0210b	8b 55 c0	 mov	 edx, DWORD PTR _height$22522[ebp]
  0210e	52		 push	 edx
  0210f	8b 45 c4	 mov	 eax, DWORD PTR _width$22521[ebp]
  02112	50		 push	 eax
  02113	6a 00		 push	 0
  02115	6a 00		 push	 0
  02117	8b 4d f4	 mov	 ecx, DWORD PTR _hdcmem1$22514[ebp]
  0211a	51		 push	 ecx
  0211b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  02121	3b f4		 cmp	 esi, esp
  02123	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 227  : 			SetBkColor(hdc, 0x00ffffff);

  02128	8b f4		 mov	 esi, esp
  0212a	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  0212f	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02132	52		 push	 edx
  02133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  02139	3b f4		 cmp	 esi, esp
  0213b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 228  : 			SetTextColor(hdc, GetSysColor(COLOR_3DDKSHADOW));

  02140	8b f4		 mov	 esi, esp
  02142	6a 15		 push	 21			; 00000015H
  02144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  0214a	3b f4		 cmp	 esi, esp
  0214c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02151	8b f4		 mov	 esi, esp
  02153	50		 push	 eax
  02154	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02157	50		 push	 eax
  02158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8
  0215e	3b f4		 cmp	 esi, esp
  02160	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 229  : 			BitBlt(hdc, rect->left, rect->top, width, height, hdcmem1, 0, 0, SRCCOPY);

  02165	8b f4		 mov	 esi, esp
  02167	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0216c	6a 00		 push	 0
  0216e	6a 00		 push	 0
  02170	8b 4d f4	 mov	 ecx, DWORD PTR _hdcmem1$22514[ebp]
  02173	51		 push	 ecx
  02174	8b 55 c0	 mov	 edx, DWORD PTR _height$22522[ebp]
  02177	52		 push	 edx
  02178	8b 45 c4	 mov	 eax, DWORD PTR _width$22521[ebp]
  0217b	50		 push	 eax
  0217c	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0217f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02182	52		 push	 edx
  02183	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  02186	8b 08		 mov	 ecx, DWORD PTR [eax]
  02188	51		 push	 ecx
  02189	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  0218c	52		 push	 edx
  0218d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  02193	3b f4		 cmp	 esi, esp
  02195	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 230  : 		}
; 231  : 		//draw a flat monochrome version of a scrollbar arrow (grey)
; 232  : 		else if(fMouseOver)

  0219a	e9 2d 01 00 00	 jmp	 $L22527
$L22524:
  0219f	83 7d 1c 00	 cmp	 DWORD PTR _fMouseOver$[ebp], 0
  021a3	0f 84 ee 00 00
	00		 je	 $L22528

; 233  : 		{
; 234  : 			SetBkColor(hdcmem2, GetSysColor(COLOR_BTNTEXT));

  021a9	8b f4		 mov	 esi, esp
  021ab	6a 12		 push	 18			; 00000012H
  021ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  021b3	3b f4		 cmp	 esi, esp
  021b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  021ba	8b f4		 mov	 esi, esp
  021bc	50		 push	 eax
  021bd	8b 45 f0	 mov	 eax, DWORD PTR _hdcmem2$22515[ebp]
  021c0	50		 push	 eax
  021c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  021c7	3b f4		 cmp	 esi, esp
  021c9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 235  : 			FillRect(hdcmem1, &rc, GetStockObject(WHITE_BRUSH));

  021ce	8b f4		 mov	 esi, esp
  021d0	6a 00		 push	 0
  021d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStockObject@4
  021d8	3b f4		 cmp	 esi, esp
  021da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  021df	8b f4		 mov	 esi, esp
  021e1	50		 push	 eax
  021e2	8d 4d cc	 lea	 ecx, DWORD PTR _rc$22520[ebp]
  021e5	51		 push	 ecx
  021e6	8b 55 f4	 mov	 edx, DWORD PTR _hdcmem1$22514[ebp]
  021e9	52		 push	 edx
  021ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FillRect@12
  021f0	3b f4		 cmp	 esi, esp
  021f2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 236  : 			BitBlt(hdcmem1, 0, 0, width, height, hdcmem2, 0, 0, SRCINVERT);

  021f7	8b f4		 mov	 esi, esp
  021f9	68 46 00 66 00	 push	 6684742			; 00660046H
  021fe	6a 00		 push	 0
  02200	6a 00		 push	 0
  02202	8b 45 f0	 mov	 eax, DWORD PTR _hdcmem2$22515[ebp]
  02205	50		 push	 eax
  02206	8b 4d c0	 mov	 ecx, DWORD PTR _height$22522[ebp]
  02209	51		 push	 ecx
  0220a	8b 55 c4	 mov	 edx, DWORD PTR _width$22521[ebp]
  0220d	52		 push	 edx
  0220e	6a 00		 push	 0
  02210	6a 00		 push	 0
  02212	8b 45 f4	 mov	 eax, DWORD PTR _hdcmem1$22514[ebp]
  02215	50		 push	 eax
  02216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  0221c	3b f4		 cmp	 esi, esp
  0221e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 237  : 
; 238  : 			SetBkColor(hdc, GetSysColor(COLOR_3DSHADOW));

  02223	8b f4		 mov	 esi, esp
  02225	6a 10		 push	 16			; 00000010H
  02227	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  0222d	3b f4		 cmp	 esi, esp
  0222f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02234	8b f4		 mov	 esi, esp
  02236	50		 push	 eax
  02237	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0223a	51		 push	 ecx
  0223b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  02241	3b f4		 cmp	 esi, esp
  02243	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 239  : 			SetTextColor(hdc, 0x00ffffff);

  02248	8b f4		 mov	 esi, esp
  0224a	68 ff ff ff 00	 push	 16777215		; 00ffffffH
  0224f	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02252	52		 push	 edx
  02253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8
  02259	3b f4		 cmp	 esi, esp
  0225b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 240  : 			BitBlt(hdc, rect->left, rect->top, width, height, hdcmem1, 0, 0, SRCCOPY);

  02260	8b f4		 mov	 esi, esp
  02262	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  02267	6a 00		 push	 0
  02269	6a 00		 push	 0
  0226b	8b 45 f4	 mov	 eax, DWORD PTR _hdcmem1$22514[ebp]
  0226e	50		 push	 eax
  0226f	8b 4d c0	 mov	 ecx, DWORD PTR _height$22522[ebp]
  02272	51		 push	 ecx
  02273	8b 55 c4	 mov	 edx, DWORD PTR _width$22521[ebp]
  02276	52		 push	 edx
  02277	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  0227a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0227d	51		 push	 ecx
  0227e	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  02281	8b 02		 mov	 eax, DWORD PTR [edx]
  02283	50		 push	 eax
  02284	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02287	51		 push	 ecx
  02288	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  0228e	3b f4		 cmp	 esi, esp
  02290	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 241  : 		}
; 242  : 		//draw the arrow normally
; 243  : 		else

  02295	eb 35		 jmp	 SHORT $L22527
$L22528:

; 244  : 		{
; 245  : 			BitBlt(hdc, rect->left, rect->top, width, height, hdcmem2, 0, 0, SRCCOPY);

  02297	8b f4		 mov	 esi, esp
  02299	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0229e	6a 00		 push	 0
  022a0	6a 00		 push	 0
  022a2	8b 55 f0	 mov	 edx, DWORD PTR _hdcmem2$22515[ebp]
  022a5	52		 push	 edx
  022a6	8b 45 c0	 mov	 eax, DWORD PTR _height$22522[ebp]
  022a9	50		 push	 eax
  022aa	8b 4d c4	 mov	 ecx, DWORD PTR _width$22521[ebp]
  022ad	51		 push	 ecx
  022ae	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  022b1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  022b4	50		 push	 eax
  022b5	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  022b8	8b 11		 mov	 edx, DWORD PTR [ecx]
  022ba	52		 push	 edx
  022bb	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  022be	50		 push	 eax
  022bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  022c5	3b f4		 cmp	 esi, esp
  022c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L22527:

; 246  : 		}
; 247  : 
; 248  : 		SelectObject(hdcmem1, oldbm1);

  022cc	8b f4		 mov	 esi, esp
  022ce	8b 4d e8	 mov	 ecx, DWORD PTR _oldbm1$22517[ebp]
  022d1	51		 push	 ecx
  022d2	8b 55 f4	 mov	 edx, DWORD PTR _hdcmem1$22514[ebp]
  022d5	52		 push	 edx
  022d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  022dc	3b f4		 cmp	 esi, esp
  022de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 249  : 		SelectObject(hdcmem2, oldbm2);

  022e3	8b f4		 mov	 esi, esp
  022e5	8b 45 e0	 mov	 eax, DWORD PTR _oldbm2$22519[ebp]
  022e8	50		 push	 eax
  022e9	8b 4d f0	 mov	 ecx, DWORD PTR _hdcmem2$22515[ebp]
  022ec	51		 push	 ecx
  022ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  022f3	3b f4		 cmp	 esi, esp
  022f5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 250  : 		DeleteObject(hbm1);

  022fa	8b f4		 mov	 esi, esp
  022fc	8b 55 ec	 mov	 edx, DWORD PTR _hbm1$22516[ebp]
  022ff	52		 push	 edx
  02300	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  02306	3b f4		 cmp	 esi, esp
  02308	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 251  : 		DeleteObject(hbm2);

  0230d	8b f4		 mov	 esi, esp
  0230f	8b 45 e4	 mov	 eax, DWORD PTR _hbm2$22518[ebp]
  02312	50		 push	 eax
  02313	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  02319	3b f4		 cmp	 esi, esp
  0231b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 252  : 		DeleteDC(hdcmem1);

  02320	8b f4		 mov	 esi, esp
  02322	8b 4d f4	 mov	 ecx, DWORD PTR _hdcmem1$22514[ebp]
  02325	51		 push	 ecx
  02326	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  0232c	3b f4		 cmp	 esi, esp
  0232e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 253  : 		DeleteDC(hdcmem2);

  02333	8b f4		 mov	 esi, esp
  02335	8b 55 f0	 mov	 edx, DWORD PTR _hdcmem2$22515[ebp]
  02338	52		 push	 edx
  02339	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  0233f	3b f4		 cmp	 esi, esp
  02341	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 254  : 
; 255  : 		ret = 0;

  02346	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 256  : 	}
; 257  : 	else

  0234d	eb 20		 jmp	 SHORT $L22533
$L22513:

; 258  : #endif
; 259  : 	ret = DrawFrameControl(hdc, rect, DFC_SCROLL, flags);

  0234f	8b f4		 mov	 esi, esp
  02351	8b 45 f8	 mov	 eax, DWORD PTR _flags$[ebp]
  02354	50		 push	 eax
  02355	6a 03		 push	 3
  02357	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  0235a	51		 push	 ecx
  0235b	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  0235e	52		 push	 edx
  0235f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  02365	3b f4		 cmp	 esi, esp
  02367	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0236c	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
$L22533:

; 260  : 
; 261  : 	return ret;

  0236f	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 262  : }

  02372	52		 push	 edx
  02373	8b cd		 mov	 ecx, ebp
  02375	50		 push	 eax
  02376	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23930
  0237c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  02381	58		 pop	 eax
  02382	5a		 pop	 edx
  02383	5f		 pop	 edi
  02384	5e		 pop	 esi
  02385	83 c4 40	 add	 esp, 64			; 00000040H
  02388	3b ec		 cmp	 ebp, esp
  0238a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0238f	8b e5		 mov	 esp, ebp
  02391	5d		 pop	 ebp
  02392	c3		 ret	 0
$L23930:
  02393	01 00 00 00	 DD	 1
  02397	00 00 00 00	 DD	 $L23929
$L23929:
  0239b	cc ff ff ff	 DD	 -52			; ffffffccH
  0239f	10 00 00 00	 DD	 16			; 00000010H
  023a3	00 00 00 00	 DD	 $L23928
$L23928:
  023a7	72		 DB	 114			; 00000072H
  023a8	63		 DB	 99			; 00000063H
  023a9	00		 DB	 0
_DrawScrollArrow ENDP
; Function compile flags: /Odt /RTCsu
_c2$ = -8						; size = 4
_c1$ = -4						; size = 4
_GetSBForeColor PROC NEAR

; 312  : {

  023b0	55		 push	 ebp
  023b1	8b ec		 mov	 ebp, esp
  023b3	83 ec 08	 sub	 esp, 8
  023b6	56		 push	 esi
  023b7	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  023be	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 313  : 	COLORREF c1 = GetSysColor(COLOR_3DHILIGHT);

  023c5	8b f4		 mov	 esi, esp
  023c7	6a 14		 push	 20			; 00000014H
  023c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  023cf	3b f4		 cmp	 esi, esp
  023d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  023d6	89 45 fc	 mov	 DWORD PTR _c1$[ebp], eax

; 314  : 	COLORREF c2 = GetSysColor(COLOR_WINDOW);

  023d9	8b f4		 mov	 esi, esp
  023db	6a 05		 push	 5
  023dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  023e3	3b f4		 cmp	 esi, esp
  023e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  023ea	89 45 f8	 mov	 DWORD PTR _c2$[ebp], eax

; 315  : 
; 316  : 	if(c1 != 0xffffff && c1 == c2)

  023ed	81 7d fc ff ff
	ff 00		 cmp	 DWORD PTR _c1$[ebp], 16777215 ; 00ffffffH
  023f4	74 1b		 je	 SHORT $L22560
  023f6	8b 45 fc	 mov	 eax, DWORD PTR _c1$[ebp]
  023f9	3b 45 f8	 cmp	 eax, DWORD PTR _c2$[ebp]
  023fc	75 13		 jne	 SHORT $L22560

; 317  : 	{
; 318  : 		return GetSysColor(COLOR_BTNFACE);

  023fe	8b f4		 mov	 esi, esp
  02400	6a 0f		 push	 15			; 0000000fH
  02402	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  02408	3b f4		 cmp	 esi, esp
  0240a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0240f	eb 11		 jmp	 SHORT $L22557
$L22560:

; 319  : 	}
; 320  : 	else
; 321  : 	{
; 322  : 		return GetSysColor(COLOR_3DHILIGHT);

  02411	8b f4		 mov	 esi, esp
  02413	6a 14		 push	 20			; 00000014H
  02415	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  0241b	3b f4		 cmp	 esi, esp
  0241d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L22557:

; 323  : 	}
; 324  : }

  02422	5e		 pop	 esi
  02423	83 c4 08	 add	 esp, 8
  02426	3b ec		 cmp	 ebp, esp
  02428	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0242d	8b e5		 mov	 esp, ebp
  0242f	5d		 pop	 ebp
  02430	c3		 ret	 0
_GetSBForeColor ENDP
; Function compile flags: /Odt /RTCsu
_GetSBBackColor PROC NEAR

; 327  : {

  02440	55		 push	 ebp
  02441	8b ec		 mov	 ebp, esp
  02443	56		 push	 esi

; 328  : 	return GetSysColor(COLOR_SCROLLBAR);

  02444	8b f4		 mov	 esi, esp
  02446	6a 00		 push	 0
  02448	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  0244e	3b f4		 cmp	 esi, esp
  02450	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 329  : }

  02455	5e		 pop	 esi
  02456	3b ec		 cmp	 ebp, esp
  02458	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0245d	5d		 pop	 ebp
  0245e	c3		 ret	 0
_GetSBBackColor ENDP
_TEXT	ENDS
EXTRN	__imp__CreatePatternBrush@4:NEAR
EXTRN	__imp__SetBrushOrgEx@16:NEAR
EXTRN	__imp__PatBlt@24:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_bgold$ = -20						; size = 4
_fgold$ = -16						; size = 4
_hbrold$ = -12						; size = 4
_hbr$ = -8						; size = 4
_hbmp$ = -4						; size = 4
_hdc$ = 8						; size = 4
_rect$ = 12						; size = 4
_fg$ = 16						; size = 4
_bg$ = 20						; size = 4
_DrawCheckedRect PROC NEAR

; 336  : {

  02460	55		 push	 ebp
  02461	8b ec		 mov	 ebp, esp
  02463	83 ec 14	 sub	 esp, 20			; 00000014H
  02466	56		 push	 esi
  02467	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0246c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0246f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  02472	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  02475	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  02478	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 337  : 	static WORD wCheckPat[8] = 
; 338  : 	{ 
; 339  : 		0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555, 0xaaaa, 0x5555 
; 340  : 	};
; 341  : 
; 342  : 	HBITMAP hbmp;
; 343  : 	HBRUSH  hbr, hbrold;
; 344  : 	COLORREF fgold, bgold;
; 345  : 
; 346  : 	hbmp = CreateBitmap(8, 8, 1, 1, wCheckPat);

  0247b	8b f4		 mov	 esi, esp
  0247d	68 00 00 00 00	 push	 OFFSET FLAT:?wCheckPat@?1??DrawCheckedRect@@9@9
  02482	6a 01		 push	 1
  02484	6a 01		 push	 1
  02486	6a 08		 push	 8
  02488	6a 08		 push	 8
  0248a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateBitmap@20
  02490	3b f4		 cmp	 esi, esp
  02492	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02497	89 45 fc	 mov	 DWORD PTR _hbmp$[ebp], eax

; 347  : 	hbr  = CreatePatternBrush(hbmp);

  0249a	8b f4		 mov	 esi, esp
  0249c	8b 45 fc	 mov	 eax, DWORD PTR _hbmp$[ebp]
  0249f	50		 push	 eax
  024a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreatePatternBrush@4
  024a6	3b f4		 cmp	 esi, esp
  024a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  024ad	89 45 f8	 mov	 DWORD PTR _hbr$[ebp], eax

; 348  : 
; 349  : 	UnrealizeObject(hbr);

  024b0	8b f4		 mov	 esi, esp
  024b2	8b 4d f8	 mov	 ecx, DWORD PTR _hbr$[ebp]
  024b5	51		 push	 ecx
  024b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnrealizeObject@4
  024bc	3b f4		 cmp	 esi, esp
  024be	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 350  : 	SetBrushOrgEx(hdc, rect->left, rect->top, 0);

  024c3	8b f4		 mov	 esi, esp
  024c5	6a 00		 push	 0
  024c7	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  024ca	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  024cd	50		 push	 eax
  024ce	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  024d1	8b 11		 mov	 edx, DWORD PTR [ecx]
  024d3	52		 push	 edx
  024d4	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  024d7	50		 push	 eax
  024d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBrushOrgEx@16
  024de	3b f4		 cmp	 esi, esp
  024e0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 351  : 
; 352  : 	hbrold = (HBRUSH)SelectObject(hdc, hbr);

  024e5	8b f4		 mov	 esi, esp
  024e7	8b 4d f8	 mov	 ecx, DWORD PTR _hbr$[ebp]
  024ea	51		 push	 ecx
  024eb	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  024ee	52		 push	 edx
  024ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  024f5	3b f4		 cmp	 esi, esp
  024f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  024fc	89 45 f4	 mov	 DWORD PTR _hbrold$[ebp], eax

; 353  : 
; 354  : 	fgold = SetTextColor(hdc, fg);

  024ff	8b f4		 mov	 esi, esp
  02501	8b 45 10	 mov	 eax, DWORD PTR _fg$[ebp]
  02504	50		 push	 eax
  02505	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02508	51		 push	 ecx
  02509	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8
  0250f	3b f4		 cmp	 esi, esp
  02511	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02516	89 45 f0	 mov	 DWORD PTR _fgold$[ebp], eax

; 355  : 	bgold = SetBkColor(hdc, bg);

  02519	8b f4		 mov	 esi, esp
  0251b	8b 55 14	 mov	 edx, DWORD PTR _bg$[ebp]
  0251e	52		 push	 edx
  0251f	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  02522	50		 push	 eax
  02523	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  02529	3b f4		 cmp	 esi, esp
  0252b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02530	89 45 ec	 mov	 DWORD PTR _bgold$[ebp], eax

; 356  : 	
; 357  : 	PatBlt(hdc, rect->left, rect->top, 
; 358  : 				rect->right - rect->left, 
; 359  : 				rect->bottom - rect->top, 
; 360  : 				PATCOPY);

  02533	8b f4		 mov	 esi, esp
  02535	68 21 00 f0 00	 push	 15728673		; 00f00021H
  0253a	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  0253d	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  02540	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  02543	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  02546	50		 push	 eax
  02547	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  0254a	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  0254d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  02550	2b 02		 sub	 eax, DWORD PTR [edx]
  02552	50		 push	 eax
  02553	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  02556	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  02559	52		 push	 edx
  0255a	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0255d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0255f	51		 push	 ecx
  02560	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  02563	52		 push	 edx
  02564	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PatBlt@24
  0256a	3b f4		 cmp	 esi, esp
  0256c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 361  : 	
; 362  : 	SetBkColor(hdc, bgold);

  02571	8b f4		 mov	 esi, esp
  02573	8b 45 ec	 mov	 eax, DWORD PTR _bgold$[ebp]
  02576	50		 push	 eax
  02577	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0257a	51		 push	 ecx
  0257b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  02581	3b f4		 cmp	 esi, esp
  02583	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 363  : 	SetTextColor(hdc, fgold);

  02588	8b f4		 mov	 esi, esp
  0258a	8b 55 f0	 mov	 edx, DWORD PTR _fgold$[ebp]
  0258d	52		 push	 edx
  0258e	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  02591	50		 push	 eax
  02592	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTextColor@8
  02598	3b f4		 cmp	 esi, esp
  0259a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 364  : 	
; 365  : 	SelectObject(hdc, hbrold);

  0259f	8b f4		 mov	 esi, esp
  025a1	8b 4d f4	 mov	 ecx, DWORD PTR _hbrold$[ebp]
  025a4	51		 push	 ecx
  025a5	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  025a8	52		 push	 edx
  025a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  025af	3b f4		 cmp	 esi, esp
  025b1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 366  : 	DeleteObject(hbr);

  025b6	8b f4		 mov	 esi, esp
  025b8	8b 45 f8	 mov	 eax, DWORD PTR _hbr$[ebp]
  025bb	50		 push	 eax
  025bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  025c2	3b f4		 cmp	 esi, esp
  025c4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 367  : 	DeleteObject(hbmp);

  025c9	8b f4		 mov	 esi, esp
  025cb	8b 4d fc	 mov	 ecx, DWORD PTR _hbmp$[ebp]
  025ce	51		 push	 ecx
  025cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteObject@4
  025d5	3b f4		 cmp	 esi, esp
  025d7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 368  : }

  025dc	5e		 pop	 esi
  025dd	83 c4 14	 add	 esp, 20			; 00000014H
  025e0	3b ec		 cmp	 ebp, esp
  025e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  025e7	8b e5		 mov	 esp, ebp
  025e9	5d		 pop	 ebp
  025ea	c3		 ret	 0
_DrawCheckedRect ENDP
_TEXT	ENDS
EXTRN	__imp__MulDiv@12:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv92 = -44						; size = 4
_pagesize$22707 = -40					; size = 4
_adjust$ = -36						; size = 4
_thumbsize$ = -32					; size = 4
_thumbpos$ = -28					; size = 4
_startcoord$ = -24					; size = 4
_butsize$ = -20						; size = 4
_siMaxMin$ = -16					; size = 4
_workingsize$ = -12					; size = 4
_scrollsize$ = -8					; size = 4
_si$ = -4						; size = 4
_sbar$ = 8						; size = 4
_rect$ = 12						; size = 4
_pthumbsize$ = 16					; size = 4
_pthumbpos$ = 20					; size = 4
_CalcThumbSize PROC NEAR

; 534  : {

  025f0	55		 push	 ebp
  025f1	8b ec		 mov	 ebp, esp
  025f3	83 ec 2c	 sub	 esp, 44			; 0000002cH
  025f6	56		 push	 esi
  025f7	57		 push	 edi
  025f8	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  025fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  02600	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02605	f3 ab		 rep stosd

; 535  : 	SCROLLINFO *si;
; 536  : 	int scrollsize;			//total size of the scrollbar including arrow buttons
; 537  : 	int workingsize;		//working area (where the thumb can slide)
; 538  : 	int siMaxMin;
; 539  : 	int butsize;
; 540  : 	int startcoord;
; 541  : 	int thumbpos = 0, thumbsize = 0;

  02607	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _thumbpos$[ebp], 0
  0260e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _thumbsize$[ebp], 0

; 542  : 
; 543  : 	int adjust=0;

  02615	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _adjust$[ebp], 0

; 544  : 	static int count=0;
; 545  : 
; 546  : 	//work out the width (for a horizontal) or the height (for a vertical)
; 547  : 	//of a standard scrollbar button
; 548  : 	butsize = GetScrollMetric(sbar, SM_SCROLL_LENGTH);

  0261c	6a 00		 push	 0
  0261e	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  02621	50		 push	 eax
  02622	e8 00 00 00 00	 call	 _GetScrollMetric
  02627	83 c4 08	 add	 esp, 8
  0262a	89 45 ec	 mov	 DWORD PTR _butsize$[ebp], eax

; 549  : 
; 550  : 	if(1) //sbar->nBarType == SB_HORZ)

  0262d	b9 01 00 00 00	 mov	 ecx, 1
  02632	85 c9		 test	 ecx, ecx
  02634	74 16		 je	 SHORT $L22701

; 551  : 	{
; 552  : 		scrollsize = rect->right - rect->left;

  02636	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  02639	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0263c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0263f	2b 08		 sub	 ecx, DWORD PTR [eax]
  02641	89 4d f8	 mov	 DWORD PTR _scrollsize$[ebp], ecx

; 553  : 		startcoord = rect->left;

  02644	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  02647	8b 02		 mov	 eax, DWORD PTR [edx]
  02649	89 45 e8	 mov	 DWORD PTR _startcoord$[ebp], eax
$L22701:

; 554  : 	}
; 555  : 	/*else if(sbar->nBarType == SB_VERT)
; 556  : 	{
; 557  : 		scrollsize = rect->bottom - rect->top;
; 558  : 		startcoord = rect->top;
; 559  : 	}
; 560  : 	else
; 561  : 	{
; 562  : 		return 0;
; 563  : 	}*/
; 564  : 
; 565  : 	si = &sbar->scrollInfo;

  0264c	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  0264f	83 c1 08	 add	 ecx, 8
  02652	89 4d fc	 mov	 DWORD PTR _si$[ebp], ecx

; 566  : 	siMaxMin = si->nMax - si->nMin + 1;

  02655	8b 55 fc	 mov	 edx, DWORD PTR _si$[ebp]
  02658	8b 45 fc	 mov	 eax, DWORD PTR _si$[ebp]
  0265b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0265e	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  02661	83 c1 01	 add	 ecx, 1
  02664	89 4d f0	 mov	 DWORD PTR _siMaxMin$[ebp], ecx

; 567  : 	workingsize = scrollsize - butsize * 2;

  02667	8b 55 ec	 mov	 edx, DWORD PTR _butsize$[ebp]
  0266a	d1 e2		 shl	 edx, 1
  0266c	8b 45 f8	 mov	 eax, DWORD PTR _scrollsize$[ebp]
  0266f	2b c2		 sub	 eax, edx
  02671	89 45 f4	 mov	 DWORD PTR _workingsize$[ebp], eax

; 568  : 
; 569  : 	//
; 570  : 	// Work out the scrollbar thumb SIZE
; 571  : 	//
; 572  : 	if(si->nPage == 0)

  02674	8b 4d fc	 mov	 ecx, DWORD PTR _si$[ebp]
  02677	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0267b	75 08		 jne	 SHORT $L22702

; 573  : 	{
; 574  : 		thumbsize = butsize;

  0267d	8b 55 ec	 mov	 edx, DWORD PTR _butsize$[ebp]
  02680	89 55 e0	 mov	 DWORD PTR _thumbsize$[ebp], edx

; 575  : 	}
; 576  : 	else if(siMaxMin > 0)

  02683	eb 41		 jmp	 SHORT $L22703
$L22702:
  02685	83 7d f0 00	 cmp	 DWORD PTR _siMaxMin$[ebp], 0
  02689	7e 3b		 jle	 SHORT $L22703

; 577  : 	{
; 578  : 		thumbsize = MulDiv(si->nPage, workingsize, siMaxMin);

  0268b	8b f4		 mov	 esi, esp
  0268d	8b 45 f0	 mov	 eax, DWORD PTR _siMaxMin$[ebp]
  02690	50		 push	 eax
  02691	8b 4d f4	 mov	 ecx, DWORD PTR _workingsize$[ebp]
  02694	51		 push	 ecx
  02695	8b 55 fc	 mov	 edx, DWORD PTR _si$[ebp]
  02698	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0269b	50		 push	 eax
  0269c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  026a2	3b f4		 cmp	 esi, esp
  026a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  026a9	89 45 e0	 mov	 DWORD PTR _thumbsize$[ebp], eax

; 579  : 
; 580  : 		if(thumbsize < sbar->nMinThumbSize)

  026ac	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  026af	8b 55 e0	 mov	 edx, DWORD PTR _thumbsize$[ebp]
  026b2	3b 91 48 03 00
	00		 cmp	 edx, DWORD PTR [ecx+840]
  026b8	7d 0c		 jge	 SHORT $L22703

; 581  : 			thumbsize = sbar->nMinThumbSize;

  026ba	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  026bd	8b 88 48 03 00
	00		 mov	 ecx, DWORD PTR [eax+840]
  026c3	89 4d e0	 mov	 DWORD PTR _thumbsize$[ebp], ecx
$L22703:

; 582  : 	}
; 583  : 
; 584  : 	//
; 585  : 	// Work out the scrollbar thumb position
; 586  : 	//
; 587  : 	if(siMaxMin > 0)

  026c6	83 7d f0 00	 cmp	 DWORD PTR _siMaxMin$[ebp], 0
  026ca	7e 6f		 jle	 SHORT $L22706

; 588  : 	{
; 589  : 		int pagesize = max(1, si->nPage);

  026cc	8b 55 fc	 mov	 edx, DWORD PTR _si$[ebp]
  026cf	83 7a 10 01	 cmp	 DWORD PTR [edx+16], 1
  026d3	73 09		 jae	 SHORT $L23935
  026d5	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  026dc	eb 09		 jmp	 SHORT $L23936
$L23935:
  026de	8b 45 fc	 mov	 eax, DWORD PTR _si$[ebp]
  026e1	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  026e4	89 4d d4	 mov	 DWORD PTR tv92[ebp], ecx
$L23936:
  026e7	8b 55 d4	 mov	 edx, DWORD PTR tv92[ebp]
  026ea	89 55 d8	 mov	 DWORD PTR _pagesize$22707[ebp], edx

; 590  : 		thumbpos = MulDiv(si->nPos - si->nMin, workingsize-thumbsize, siMaxMin - pagesize);

  026ed	8b 45 f0	 mov	 eax, DWORD PTR _siMaxMin$[ebp]
  026f0	2b 45 d8	 sub	 eax, DWORD PTR _pagesize$22707[ebp]
  026f3	8b f4		 mov	 esi, esp
  026f5	50		 push	 eax
  026f6	8b 4d f4	 mov	 ecx, DWORD PTR _workingsize$[ebp]
  026f9	2b 4d e0	 sub	 ecx, DWORD PTR _thumbsize$[ebp]
  026fc	51		 push	 ecx
  026fd	8b 55 fc	 mov	 edx, DWORD PTR _si$[ebp]
  02700	8b 45 fc	 mov	 eax, DWORD PTR _si$[ebp]
  02703	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  02706	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  02709	51		 push	 ecx
  0270a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  02710	3b f4		 cmp	 esi, esp
  02712	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02717	89 45 e4	 mov	 DWORD PTR _thumbpos$[ebp], eax

; 591  : 		
; 592  : 		if(thumbpos < 0)						

  0271a	83 7d e4 00	 cmp	 DWORD PTR _thumbpos$[ebp], 0
  0271e	7d 07		 jge	 SHORT $L22708

; 593  : 			thumbpos = 0;

  02720	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _thumbpos$[ebp], 0
$L22708:

; 594  : 
; 595  : 		if(thumbpos >= workingsize-thumbsize)	

  02727	8b 55 f4	 mov	 edx, DWORD PTR _workingsize$[ebp]
  0272a	2b 55 e0	 sub	 edx, DWORD PTR _thumbsize$[ebp]
  0272d	39 55 e4	 cmp	 DWORD PTR _thumbpos$[ebp], edx
  02730	7c 09		 jl	 SHORT $L22706

; 596  : 			thumbpos = workingsize-thumbsize;

  02732	8b 45 f4	 mov	 eax, DWORD PTR _workingsize$[ebp]
  02735	2b 45 e0	 sub	 eax, DWORD PTR _thumbsize$[ebp]
  02738	89 45 e4	 mov	 DWORD PTR _thumbpos$[ebp], eax
$L22706:

; 597  : 	}
; 598  : 
; 599  : 	thumbpos += startcoord + butsize;

  0273b	8b 4d e8	 mov	 ecx, DWORD PTR _startcoord$[ebp]
  0273e	03 4d ec	 add	 ecx, DWORD PTR _butsize$[ebp]
  02741	03 4d e4	 add	 ecx, DWORD PTR _thumbpos$[ebp]
  02744	89 4d e4	 mov	 DWORD PTR _thumbpos$[ebp], ecx

; 600  : 
; 601  : 	*pthumbpos  = thumbpos;

  02747	8b 55 14	 mov	 edx, DWORD PTR _pthumbpos$[ebp]
  0274a	8b 45 e4	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  0274d	89 02		 mov	 DWORD PTR [edx], eax

; 602  : 	*pthumbsize = thumbsize;

  0274f	8b 4d 10	 mov	 ecx, DWORD PTR _pthumbsize$[ebp]
  02752	8b 55 e0	 mov	 edx, DWORD PTR _thumbsize$[ebp]
  02755	89 11		 mov	 DWORD PTR [ecx], edx

; 603  : 
; 604  : 	return 1;

  02757	b8 01 00 00 00	 mov	 eax, 1

; 605  : }

  0275c	5f		 pop	 edi
  0275d	5e		 pop	 esi
  0275e	83 c4 2c	 add	 esp, 44			; 0000002cH
  02761	3b ec		 cmp	 ebp, esp
  02763	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02768	8b e5		 mov	 esp, ebp
  0276a	5d		 pop	 ebp
  0276b	c3		 ret	 0
_CalcThumbSize ENDP
; Function compile flags: /Odt /RTCsu
_ret$ = -60						; size = 4
_nmcd$ = -52						; size = 48
_hwnd$ = 8						; size = 4
_hdc$ = 12						; size = 4
_sb$ = 16						; size = 4
_dwStage$ = 20						; size = 4
_PostCustomPrePostPaint0 PROC NEAR

; 684  : {

  02770	55		 push	 ebp
  02771	8b ec		 mov	 ebp, esp
  02773	83 ec 3c	 sub	 esp, 60			; 0000003cH
  02776	56		 push	 esi
  02777	57		 push	 edi
  02778	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0277b	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  02780	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02785	f3 ab		 rep stosd

; 685  : #ifdef CUSTOM_DRAW
; 686  : 	NMCSBCUSTOMDRAW	nmcd;
; 687  : 	LRESULT ret;
; 688  : 
; 689  : 	CoolSB_ZeroMemory(&nmcd, sizeof nmcd);

  02787	6a 30		 push	 48			; 00000030H
  02789	8d 45 cc	 lea	 eax, DWORD PTR _nmcd$[ebp]
  0278c	50		 push	 eax
  0278d	e8 00 00 00 00	 call	 _CoolSB_ZeroMemory
  02792	83 c4 08	 add	 esp, 8

; 690  : 	nmcd.hdr.hwndFrom = hwnd;

  02795	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  02798	89 4d cc	 mov	 DWORD PTR _nmcd$[ebp], ecx

; 691  : 	nmcd.hdr.idFrom   = GetWindowLong(hwnd, GWL_ID);

  0279b	8b f4		 mov	 esi, esp
  0279d	6a f4		 push	 -12			; fffffff4H
  0279f	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  027a2	52		 push	 edx
  027a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  027a9	3b f4		 cmp	 esi, esp
  027ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  027b0	89 45 d0	 mov	 DWORD PTR _nmcd$[ebp+4], eax

; 692  : 	nmcd.hdr.code     = NM_COOLSB_CUSTOMDRAW;

  027b3	c7 45 d4 01 f0
	ff ff		 mov	 DWORD PTR _nmcd$[ebp+8], -4095 ; fffff001H

; 693  : 	nmcd.nBar		  = sb->nBarType;

  027ba	8b 45 10	 mov	 eax, DWORD PTR _sb$[ebp]
  027bd	8b 88 40 03 00
	00		 mov	 ecx, DWORD PTR [eax+832]
  027c3	89 4d f8	 mov	 DWORD PTR _nmcd$[ebp+44], ecx

; 694  : 	nmcd.dwDrawStage  = dwStage;

  027c6	8b 55 14	 mov	 edx, DWORD PTR _dwStage$[ebp]
  027c9	89 55 d8	 mov	 DWORD PTR _nmcd$[ebp+12], edx

; 695  : 	nmcd.hdc		  = hdc;

  027cc	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  027cf	89 45 dc	 mov	 DWORD PTR _nmcd$[ebp+16], eax

; 696  : 
; 697  : 	hwnd = GetParent(hwnd);

  027d2	8b f4		 mov	 esi, esp
  027d4	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  027d7	51		 push	 ecx
  027d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  027de	3b f4		 cmp	 esi, esp
  027e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  027e5	89 45 08	 mov	 DWORD PTR _hwnd$[ebp], eax

; 698  : 	ret = SendMessage(hwnd, WM_NOTIFY, 0, (LPARAM)&nmcd);

  027e8	8b f4		 mov	 esi, esp
  027ea	8d 55 cc	 lea	 edx, DWORD PTR _nmcd$[ebp]
  027ed	52		 push	 edx
  027ee	6a 00		 push	 0
  027f0	6a 4e		 push	 78			; 0000004eH
  027f2	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  027f5	50		 push	 eax
  027f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  027fc	3b f4		 cmp	 esi, esp
  027fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02803	89 45 c4	 mov	 DWORD PTR _ret$[ebp], eax

; 699  : 	return ret;

  02806	8b 45 c4	 mov	 eax, DWORD PTR _ret$[ebp]

; 700  : #else
; 701  : 	return 0;
; 702  : #endif
; 703  : }

  02809	52		 push	 edx
  0280a	8b cd		 mov	 ecx, ebp
  0280c	50		 push	 eax
  0280d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23940
  02813	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  02818	58		 pop	 eax
  02819	5a		 pop	 edx
  0281a	5f		 pop	 edi
  0281b	5e		 pop	 esi
  0281c	83 c4 3c	 add	 esp, 60			; 0000003cH
  0281f	3b ec		 cmp	 ebp, esp
  02821	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02826	8b e5		 mov	 esp, ebp
  02828	5d		 pop	 ebp
  02829	c3		 ret	 0
$L23940:
  0282a	01 00 00 00	 DD	 1
  0282e	00 00 00 00	 DD	 $L23939
$L23939:
  02832	cc ff ff ff	 DD	 -52			; ffffffccH
  02836	30 00 00 00	 DD	 48			; 00000030H
  0283a	00 00 00 00	 DD	 $L23938
$L23938:
  0283e	6e		 DB	 110			; 0000006eH
  0283f	6d		 DB	 109			; 0000006dH
  02840	63		 DB	 99			; 00000063H
  02841	64		 DB	 100			; 00000064H
  02842	00		 DB	 0
_PostCustomPrePostPaint0 ENDP
; Function compile flags: /Odt /RTCsu
tv65 = -8						; size = 4
_bptr$ = -4						; size = 4
_ptr$ = 8						; size = 4
_bytes$ = 12						; size = 4
_CoolSB_ZeroMemory PROC NEAR

; 98   : {

  02850	55		 push	 ebp
  02851	8b ec		 mov	 ebp, esp
  02853	83 ec 08	 sub	 esp, 8
  02856	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0285d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 99   : 	BYTE *bptr = (BYTE *)ptr;

  02864	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  02867	89 45 fc	 mov	 DWORD PTR _bptr$[ebp], eax
$L22456:

; 100  : 
; 101  : 	while(bytes--) *bptr++ = 0;

  0286a	8b 4d 0c	 mov	 ecx, DWORD PTR _bytes$[ebp]
  0286d	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
  02870	8b 55 0c	 mov	 edx, DWORD PTR _bytes$[ebp]
  02873	83 ea 01	 sub	 edx, 1
  02876	89 55 0c	 mov	 DWORD PTR _bytes$[ebp], edx
  02879	83 7d f8 00	 cmp	 DWORD PTR tv65[ebp], 0
  0287d	74 11		 je	 SHORT $L22452
  0287f	8b 45 fc	 mov	 eax, DWORD PTR _bptr$[ebp]
  02882	c6 00 00	 mov	 BYTE PTR [eax], 0
  02885	8b 4d fc	 mov	 ecx, DWORD PTR _bptr$[ebp]
  02888	83 c1 01	 add	 ecx, 1
  0288b	89 4d fc	 mov	 DWORD PTR _bptr$[ebp], ecx
  0288e	eb da		 jmp	 SHORT $L22456
$L22452:

; 102  : }

  02890	8b e5		 mov	 esp, ebp
  02892	5d		 pop	 ebp
  02893	c3		 ret	 0
_CoolSB_ZeroMemory ENDP
; Function compile flags: /Odt /RTCsu
_rc$ = -24						; size = 16
_ret$ = -4						; size = 4
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_hdc$ = 16						; size = 4
_rect$ = 20						; size = 4
_uDrawFlags$ = 24					; size = 4
_NCDrawVScrollbar PROC NEAR

; 1074 : {

  028a0	55		 push	 ebp
  028a1	8b ec		 mov	 ebp, esp
  028a3	83 ec 1c	 sub	 esp, 28			; 0000001cH
  028a6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  028ab	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  028ae	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  028b1	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  028b4	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  028b7	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  028ba	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  028bd	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1075 : 	LRESULT ret;
; 1076 : 	RECT rc;
; 1077 : 
; 1078 : 	rc = *rect;

  028c0	8b 45 14	 mov	 eax, DWORD PTR _rect$[ebp]
  028c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  028c5	89 4d e8	 mov	 DWORD PTR _rc$[ebp], ecx
  028c8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  028cb	89 55 ec	 mov	 DWORD PTR _rc$[ebp+4], edx
  028ce	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  028d1	89 4d f0	 mov	 DWORD PTR _rc$[ebp+8], ecx
  028d4	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  028d7	89 55 f4	 mov	 DWORD PTR _rc$[ebp+12], edx

; 1079 : 	RotateRect(&rc);

  028da	8d 45 e8	 lea	 eax, DWORD PTR _rc$[ebp]
  028dd	50		 push	 eax
  028de	e8 00 00 00 00	 call	 _RotateRect@4

; 1080 : 	ret = NCDrawHScrollbar(sb, hwnd, hdc, &rc, uDrawFlags);

  028e3	8b 4d 18	 mov	 ecx, DWORD PTR _uDrawFlags$[ebp]
  028e6	51		 push	 ecx
  028e7	8d 55 e8	 lea	 edx, DWORD PTR _rc$[ebp]
  028ea	52		 push	 edx
  028eb	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  028ee	50		 push	 eax
  028ef	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  028f2	51		 push	 ecx
  028f3	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  028f6	52		 push	 edx
  028f7	e8 00 00 00 00	 call	 _NCDrawHScrollbar
  028fc	83 c4 14	 add	 esp, 20			; 00000014H
  028ff	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 1081 : 	RotateRect(&rc);

  02902	8d 45 e8	 lea	 eax, DWORD PTR _rc$[ebp]
  02905	50		 push	 eax
  02906	e8 00 00 00 00	 call	 _RotateRect@4

; 1082 : 	
; 1083 : 	return ret;

  0290b	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 1084 : }

  0290e	52		 push	 edx
  0290f	8b cd		 mov	 ecx, ebp
  02911	50		 push	 eax
  02912	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23945
  02918	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0291d	58		 pop	 eax
  0291e	5a		 pop	 edx
  0291f	83 c4 1c	 add	 esp, 28			; 0000001cH
  02922	3b ec		 cmp	 ebp, esp
  02924	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02929	8b e5		 mov	 esp, ebp
  0292b	5d		 pop	 ebp
  0292c	c3		 ret	 0
$L23945:
  0292d	01 00 00 00	 DD	 1
  02931	00 00 00 00	 DD	 $L23944
$L23944:
  02935	e8 ff ff ff	 DD	 -24			; ffffffe8H
  02939	10 00 00 00	 DD	 16			; 00000010H
  0293d	00 00 00 00	 DD	 $L23943
$L23943:
  02941	72		 DB	 114			; 00000072H
  02942	63		 DB	 99			; 00000063H
  02943	00		 DB	 0
_NCDrawVScrollbar ENDP
; Function compile flags: /Odt /RTCsu
_butwidth$23023 = -48					; size = 4
_butwidth$23021 = -44					; size = 4
_sbut$ = -40						; size = 4
_ctrl$ = -32						; size = 16
_xposr$ = -12						; size = 4
_xposl$ = -8						; size = 4
_i$ = -4						; size = 4
_sbar$ = 8						; size = 4
_hdc$ = 12						; size = 4
_rect$ = 16						; size = 4
_leftright$ = 20					; size = 4
_DrawHorzButtons PROC NEAR

; 1336 : {

  02950	55		 push	 ebp
  02951	8b ec		 mov	 ebp, esp
  02953	83 ec 30	 sub	 esp, 48			; 00000030H
  02956	56		 push	 esi
  02957	57		 push	 edi
  02958	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0295b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  02960	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02965	f3 ab		 rep stosd

; 1337 : 	int i;
; 1338 : 	int xposl, xposr;
; 1339 : 	RECT ctrl;
; 1340 : 	SCROLLBUT *sbut = sbar->sbButtons;

  02967	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  0296a	83 c0 2c	 add	 eax, 44			; 0000002cH
  0296d	89 45 d8	 mov	 DWORD PTR _sbut$[ebp], eax

; 1341 : 	
; 1342 : 	xposl = rect->left - sbar->nButSizeBefore;

  02970	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  02973	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  02976	8b 01		 mov	 eax, DWORD PTR [ecx]
  02978	2b 82 30 03 00
	00		 sub	 eax, DWORD PTR [edx+816]
  0297e	89 45 f8	 mov	 DWORD PTR _xposl$[ebp], eax

; 1343 : 	xposr = rect->right;

  02981	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  02984	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02987	89 55 f4	 mov	 DWORD PTR _xposr$[ebp], edx

; 1344 : 	
; 1345 : 	for(i = 0; i < sbar->nButtons; i++)

  0298a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02991	eb 09		 jmp	 SHORT $L23017
$L23018:
  02993	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  02996	83 c0 01	 add	 eax, 1
  02999	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$L23017:
  0299c	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  0299f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  029a2	3b 91 2c 03 00
	00		 cmp	 edx, DWORD PTR [ecx+812]
  029a8	0f 8d 2b 01 00
	00		 jge	 $L23019

; 1346 : 	{
; 1347 : 		if((leftright & SBBP_LEFT) && sbut[i].uPlacement == SBBP_LEFT)

  029ae	8b 45 14	 mov	 eax, DWORD PTR _leftright$[ebp]
  029b1	83 e0 01	 and	 eax, 1
  029b4	0f 84 87 00 00
	00		 je	 $L23020
  029ba	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  029bd	6b c9 30	 imul	 ecx, 48			; 00000030H
  029c0	8b 55 d8	 mov	 edx, DWORD PTR _sbut$[ebp]
  029c3	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  029c8	75 77		 jne	 SHORT $L23020

; 1348 : 		{
; 1349 : 			int butwidth = GetSingleButSize(sbar, &sbut[i]);

  029ca	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  029cd	6b c0 30	 imul	 eax, 48			; 00000030H
  029d0	03 45 d8	 add	 eax, DWORD PTR _sbut$[ebp]
  029d3	50		 push	 eax
  029d4	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  029d7	51		 push	 ecx
  029d8	e8 00 00 00 00	 call	 _GetSingleButSize
  029dd	83 c4 08	 add	 esp, 8
  029e0	89 45 d4	 mov	 DWORD PTR _butwidth$23021[ebp], eax

; 1350 : 			SetRect(&ctrl, xposl, rect->top, xposl + butwidth, rect->bottom);

  029e3	8b f4		 mov	 esi, esp
  029e5	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  029e8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  029eb	50		 push	 eax
  029ec	8b 4d f8	 mov	 ecx, DWORD PTR _xposl$[ebp]
  029ef	03 4d d4	 add	 ecx, DWORD PTR _butwidth$23021[ebp]
  029f2	51		 push	 ecx
  029f3	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  029f6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  029f9	50		 push	 eax
  029fa	8b 4d f8	 mov	 ecx, DWORD PTR _xposl$[ebp]
  029fd	51		 push	 ecx
  029fe	8d 55 e0	 lea	 edx, DWORD PTR _ctrl$[ebp]
  02a01	52		 push	 edx
  02a02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  02a08	3b f4		 cmp	 esi, esp
  02a0a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1351 : 			RotateRect0(sbar, &ctrl);

  02a0f	8d 45 e0	 lea	 eax, DWORD PTR _ctrl$[ebp]
  02a12	50		 push	 eax
  02a13	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  02a16	51		 push	 ecx
  02a17	e8 00 00 00 00	 call	 _RotateRect0@8

; 1352 : 			DrawScrollButton(&sbut[i], hdc, &ctrl, SBBS_NORMAL);

  02a1c	6a 00		 push	 0
  02a1e	8d 55 e0	 lea	 edx, DWORD PTR _ctrl$[ebp]
  02a21	52		 push	 edx
  02a22	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02a25	50		 push	 eax
  02a26	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  02a29	6b c9 30	 imul	 ecx, 48			; 00000030H
  02a2c	03 4d d8	 add	 ecx, DWORD PTR _sbut$[ebp]
  02a2f	51		 push	 ecx
  02a30	e8 00 00 00 00	 call	 _DrawScrollButton
  02a35	83 c4 10	 add	 esp, 16			; 00000010H

; 1353 : 			
; 1354 : 			xposl += butwidth;

  02a38	8b 55 f8	 mov	 edx, DWORD PTR _xposl$[ebp]
  02a3b	03 55 d4	 add	 edx, DWORD PTR _butwidth$23021[ebp]
  02a3e	89 55 f8	 mov	 DWORD PTR _xposl$[ebp], edx
$L23020:

; 1355 : 		}
; 1356 : 
; 1357 : 		if((leftright & SBBP_RIGHT) && sbut[i].uPlacement == SBBP_RIGHT)

  02a41	8b 45 14	 mov	 eax, DWORD PTR _leftright$[ebp]
  02a44	83 e0 02	 and	 eax, 2
  02a47	0f 84 87 00 00
	00		 je	 $L23022
  02a4d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  02a50	6b c9 30	 imul	 ecx, 48			; 00000030H
  02a53	8b 55 d8	 mov	 edx, DWORD PTR _sbut$[ebp]
  02a56	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  02a5b	75 77		 jne	 SHORT $L23022

; 1358 : 		{
; 1359 : 			int butwidth = GetSingleButSize(sbar, &sbut[i]);

  02a5d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  02a60	6b c0 30	 imul	 eax, 48			; 00000030H
  02a63	03 45 d8	 add	 eax, DWORD PTR _sbut$[ebp]
  02a66	50		 push	 eax
  02a67	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  02a6a	51		 push	 ecx
  02a6b	e8 00 00 00 00	 call	 _GetSingleButSize
  02a70	83 c4 08	 add	 esp, 8
  02a73	89 45 d0	 mov	 DWORD PTR _butwidth$23023[ebp], eax

; 1360 : 			SetRect(&ctrl, xposr, rect->top, xposr + butwidth, rect->bottom);

  02a76	8b f4		 mov	 esi, esp
  02a78	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  02a7b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02a7e	50		 push	 eax
  02a7f	8b 4d f4	 mov	 ecx, DWORD PTR _xposr$[ebp]
  02a82	03 4d d0	 add	 ecx, DWORD PTR _butwidth$23023[ebp]
  02a85	51		 push	 ecx
  02a86	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  02a89	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  02a8c	50		 push	 eax
  02a8d	8b 4d f4	 mov	 ecx, DWORD PTR _xposr$[ebp]
  02a90	51		 push	 ecx
  02a91	8d 55 e0	 lea	 edx, DWORD PTR _ctrl$[ebp]
  02a94	52		 push	 edx
  02a95	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  02a9b	3b f4		 cmp	 esi, esp
  02a9d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1361 : 			RotateRect0(sbar, &ctrl);

  02aa2	8d 45 e0	 lea	 eax, DWORD PTR _ctrl$[ebp]
  02aa5	50		 push	 eax
  02aa6	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  02aa9	51		 push	 ecx
  02aaa	e8 00 00 00 00	 call	 _RotateRect0@8

; 1362 : 			DrawScrollButton(&sbut[i], hdc, &ctrl, SBBS_NORMAL);

  02aaf	6a 00		 push	 0
  02ab1	8d 55 e0	 lea	 edx, DWORD PTR _ctrl$[ebp]
  02ab4	52		 push	 edx
  02ab5	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02ab8	50		 push	 eax
  02ab9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  02abc	6b c9 30	 imul	 ecx, 48			; 00000030H
  02abf	03 4d d8	 add	 ecx, DWORD PTR _sbut$[ebp]
  02ac2	51		 push	 ecx
  02ac3	e8 00 00 00 00	 call	 _DrawScrollButton
  02ac8	83 c4 10	 add	 esp, 16			; 00000010H

; 1363 : 			xposr += butwidth;

  02acb	8b 55 f4	 mov	 edx, DWORD PTR _xposr$[ebp]
  02ace	03 55 d0	 add	 edx, DWORD PTR _butwidth$23023[ebp]
  02ad1	89 55 f4	 mov	 DWORD PTR _xposr$[ebp], edx
$L23022:

; 1364 : 		}
; 1365 : 	}

  02ad4	e9 ba fe ff ff	 jmp	 $L23018
$L23019:

; 1366 : 	return 0;

  02ad9	33 c0		 xor	 eax, eax

; 1367 : }

  02adb	52		 push	 edx
  02adc	8b cd		 mov	 ecx, ebp
  02ade	50		 push	 eax
  02adf	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23949
  02ae5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  02aea	58		 pop	 eax
  02aeb	5a		 pop	 edx
  02aec	5f		 pop	 edi
  02aed	5e		 pop	 esi
  02aee	83 c4 30	 add	 esp, 48			; 00000030H
  02af1	3b ec		 cmp	 ebp, esp
  02af3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02af8	8b e5		 mov	 esp, ebp
  02afa	5d		 pop	 ebp
  02afb	c3		 ret	 0
$L23949:
  02afc	01 00 00 00	 DD	 1
  02b00	00 00 00 00	 DD	 $L23948
$L23948:
  02b04	e0 ff ff ff	 DD	 -32			; ffffffe0H
  02b08	10 00 00 00	 DD	 16			; 00000010H
  02b0c	00 00 00 00	 DD	 $L23947
$L23947:
  02b10	63		 DB	 99			; 00000063H
  02b11	74		 DB	 116			; 00000074H
  02b12	72		 DB	 114			; 00000072H
  02b13	6c		 DB	 108			; 0000006cH
  02b14	00		 DB	 0
_DrawHorzButtons ENDP
_TEXT	ENDS
EXTRN	__imp__FrameRect@12:NEAR
EXTRN	__imp__InflateRect@12:NEAR
EXTRN	__imp__IntersectClipRect@20:NEAR
EXTRN	__imp__SelectClipRgn@8:NEAR
EXTRN	__imp__WindowFromDC@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv67 = -92						; size = 4
_f$ = -88						; size = 4
_rect$ = -80						; size = 16
_hwnd$ = -60						; size = 4
_nmcd$ = -52						; size = 48
_sbut$ = 8						; size = 4
_hdc$ = 12						; size = 4
_pctrl$ = 16						; size = 4
_flags$ = 20						; size = 4
_DrawScrollButton PROC NEAR

; 1174 : {

  02b20	55		 push	 ebp
  02b21	8b ec		 mov	 ebp, esp
  02b23	83 ec 5c	 sub	 esp, 92			; 0000005cH
  02b26	56		 push	 esi
  02b27	57		 push	 edi
  02b28	8d 7d a4	 lea	 edi, DWORD PTR [ebp-92]
  02b2b	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  02b30	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  02b35	f3 ab		 rep stosd

; 1175 : 	NMCSBCUSTOMDRAW	nmcd;
; 1176 : 	HWND hwnd;
; 1177 : 	RECT rect = *pctrl;

  02b37	8b 45 10	 mov	 eax, DWORD PTR _pctrl$[ebp]
  02b3a	8b 08		 mov	 ecx, DWORD PTR [eax]
  02b3c	89 4d b0	 mov	 DWORD PTR _rect$[ebp], ecx
  02b3f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  02b42	89 55 b4	 mov	 DWORD PTR _rect$[ebp+4], edx
  02b45	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  02b48	89 4d b8	 mov	 DWORD PTR _rect$[ebp+8], ecx
  02b4b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  02b4e	89 55 bc	 mov	 DWORD PTR _rect$[ebp+12], edx

; 1178 : 	UINT f;
; 1179 : 
; 1180 : 	switch(sbut->uButType & SBBT_MASK)

  02b51	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02b54	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02b57	83 e1 1f	 and	 ecx, 31			; 0000001fH
  02b5a	89 4d a4	 mov	 DWORD PTR tv67[ebp], ecx
  02b5d	8b 55 a4	 mov	 edx, DWORD PTR tv67[ebp]
  02b60	83 ea 01	 sub	 edx, 1
  02b63	89 55 a4	 mov	 DWORD PTR tv67[ebp], edx
  02b66	83 7d a4 06	 cmp	 DWORD PTR tv67[ebp], 6
  02b6a	0f 87 6d 05 00
	00		 ja	 $L22967
  02b70	8b 45 a4	 mov	 eax, DWORD PTR tv67[ebp]
  02b73	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L23955[eax*4]
$L22970:

; 1181 : 	{
; 1182 : 	case SBBT_OWNERDRAW:
; 1183 : 
; 1184 : 		hwnd = WindowFromDC(hdc);

  02b7a	8b f4		 mov	 esi, esp
  02b7c	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02b7f	51		 push	 ecx
  02b80	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WindowFromDC@4
  02b86	3b f4		 cmp	 esi, esp
  02b88	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02b8d	89 45 c4	 mov	 DWORD PTR _hwnd$[ebp], eax

; 1185 : 
; 1186 : 		//fill in the standard header
; 1187 : 		nmcd.hdr.hwndFrom = hwnd;

  02b90	8b 55 c4	 mov	 edx, DWORD PTR _hwnd$[ebp]
  02b93	89 55 cc	 mov	 DWORD PTR _nmcd$[ebp], edx

; 1188 : 		nmcd.hdr.idFrom   = GetWindowLong(hwnd, GWL_ID);

  02b96	8b f4		 mov	 esi, esp
  02b98	6a f4		 push	 -12			; fffffff4H
  02b9a	8b 45 c4	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02b9d	50		 push	 eax
  02b9e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  02ba4	3b f4		 cmp	 esi, esp
  02ba6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02bab	89 45 d0	 mov	 DWORD PTR _nmcd$[ebp+4], eax

; 1189 : 		nmcd.hdr.code     = NM_COOLSB_CUSTOMDRAW;

  02bae	c7 45 d4 01 f0
	ff ff		 mov	 DWORD PTR _nmcd$[ebp+8], -4095 ; fffff001H

; 1190 : 
; 1191 : 		nmcd.dwDrawStage  = CDDS_ITEMPREPAINT;

  02bb5	c7 45 d8 01 00
	01 00		 mov	 DWORD PTR _nmcd$[ebp+12], 65537 ; 00010001H

; 1192 : 		nmcd.nBar		  = SB_INSBUT;

  02bbc	c7 45 f8 fe ff
	ff ff		 mov	 DWORD PTR _nmcd$[ebp+44], -2 ; fffffffeH

; 1193 : 		nmcd.rect		  = *pctrl;

  02bc3	8b 4d 10	 mov	 ecx, DWORD PTR _pctrl$[ebp]
  02bc6	8b 11		 mov	 edx, DWORD PTR [ecx]
  02bc8	89 55 e0	 mov	 DWORD PTR _nmcd$[ebp+20], edx
  02bcb	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  02bce	89 45 e4	 mov	 DWORD PTR _nmcd$[ebp+24], eax
  02bd1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02bd4	89 55 e8	 mov	 DWORD PTR _nmcd$[ebp+28], edx
  02bd7	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  02bda	89 45 ec	 mov	 DWORD PTR _nmcd$[ebp+32], eax

; 1194 : 		nmcd.uItem		  = sbut->uCmdId;

  02bdd	8b 4d 08	 mov	 ecx, DWORD PTR _sbut$[ebp]
  02be0	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02be3	89 55 f0	 mov	 DWORD PTR _nmcd$[ebp+36], edx

; 1195 : 		nmcd.hdc		  = hdc;

  02be6	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02be9	89 45 dc	 mov	 DWORD PTR _nmcd$[ebp+16], eax

; 1196 : 		nmcd.uState		  = flags;

  02bec	8b 4d 14	 mov	 ecx, DWORD PTR _flags$[ebp]
  02bef	89 4d f4	 mov	 DWORD PTR _nmcd$[ebp+40], ecx

; 1197 : 
; 1198 : 		IntersectClipRect(hdc, rect.left, rect.top, rect.right, rect.bottom);

  02bf2	8b f4		 mov	 esi, esp
  02bf4	8b 55 bc	 mov	 edx, DWORD PTR _rect$[ebp+12]
  02bf7	52		 push	 edx
  02bf8	8b 45 b8	 mov	 eax, DWORD PTR _rect$[ebp+8]
  02bfb	50		 push	 eax
  02bfc	8b 4d b4	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  02bff	51		 push	 ecx
  02c00	8b 55 b0	 mov	 edx, DWORD PTR _rect$[ebp]
  02c03	52		 push	 edx
  02c04	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02c07	50		 push	 eax
  02c08	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IntersectClipRect@20
  02c0e	3b f4		 cmp	 esi, esp
  02c10	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1199 : 		SendMessage(GetParent(hwnd), WM_NOTIFY, nmcd.hdr.idFrom, (LPARAM)&nmcd);

  02c15	8b f4		 mov	 esi, esp
  02c17	8d 4d cc	 lea	 ecx, DWORD PTR _nmcd$[ebp]
  02c1a	51		 push	 ecx
  02c1b	8b 55 d0	 mov	 edx, DWORD PTR _nmcd$[ebp+4]
  02c1e	52		 push	 edx
  02c1f	6a 4e		 push	 78			; 0000004eH
  02c21	8b fc		 mov	 edi, esp
  02c23	8b 45 c4	 mov	 eax, DWORD PTR _hwnd$[ebp]
  02c26	50		 push	 eax
  02c27	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  02c2d	3b fc		 cmp	 edi, esp
  02c2f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02c34	50		 push	 eax
  02c35	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  02c3b	3b f4		 cmp	 esi, esp
  02c3d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1200 : 		SelectClipRgn(hdc, NULL);

  02c42	8b f4		 mov	 esi, esp
  02c44	6a 00		 push	 0
  02c46	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02c49	51		 push	 ecx
  02c4a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectClipRgn@8
  02c50	3b f4		 cmp	 esi, esp
  02c52	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1201 : 
; 1202 : 		break;

  02c57	e9 81 04 00 00	 jmp	 $L22967
$L22973:

; 1203 : 
; 1204 : 	case SBBT_FIXED:
; 1205 : 		flags &= ~SBBS_PUSHED;

  02c5c	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  02c5f	83 e2 fe	 and	 edx, -2			; fffffffeH
  02c62	89 55 14	 mov	 DWORD PTR _flags$[ebp], edx
$L22974:

; 1206 : 
; 1207 : 	case SBBT_TOGGLEBUTTON:
; 1208 : 		if(sbut->uState != SBBS_NORMAL)

  02c65	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02c68	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  02c6c	74 09		 je	 SHORT $L22976

; 1209 : 			flags |= SBBS_PUSHED;

  02c6e	8b 4d 14	 mov	 ecx, DWORD PTR _flags$[ebp]
  02c71	83 c9 01	 or	 ecx, 1
  02c74	89 4d 14	 mov	 DWORD PTR _flags$[ebp], ecx
$L22976:

; 1210 : 
; 1211 : 		//intentionally fall through here...
; 1212 : 
; 1213 : 	case SBBT_PUSHBUTTON: 
; 1214 : 		
; 1215 : 		f = flags & SBBS_PUSHED ? DFCS_PUSHED | DFCS_FLAT : 0;

  02c77	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  02c7a	83 e2 01	 and	 edx, 1
  02c7d	f7 da		 neg	 edx
  02c7f	1b d2		 sbb	 edx, edx
  02c81	81 e2 00 42 00
	00		 and	 edx, 16896		; 00004200H
  02c87	89 55 a8	 mov	 DWORD PTR _f$[ebp], edx

; 1216 : 		if(sbut->uButType & SBBM_LEFTARROW)

  02c8a	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02c8d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02c90	83 e1 40	 and	 ecx, 64			; 00000040H
  02c93	74 25		 je	 SHORT $L22977

; 1217 : 		{
; 1218 : 			DrawFrameControl(hdc, &rect, DFC_SCROLL, DFCS_SCROLLLEFT | f);

  02c95	8b 55 a8	 mov	 edx, DWORD PTR _f$[ebp]
  02c98	83 ca 02	 or	 edx, 2
  02c9b	8b f4		 mov	 esi, esp
  02c9d	52		 push	 edx
  02c9e	6a 03		 push	 3
  02ca0	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  02ca3	50		 push	 eax
  02ca4	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02ca7	51		 push	 ecx
  02ca8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  02cae	3b f4		 cmp	 esi, esp
  02cb0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1219 : 		}
; 1220 : 		else if(sbut->uButType & SBBM_RIGHTARROW)

  02cb5	e9 c4 03 00 00	 jmp	 $L22978
$L22977:
  02cba	8b 55 08	 mov	 edx, DWORD PTR _sbut$[ebp]
  02cbd	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02cc0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02cc5	74 25		 je	 SHORT $L22979

; 1221 : 		{
; 1222 : 			DrawFrameControl(hdc, &rect, DFC_SCROLL, DFCS_SCROLLRIGHT | f);

  02cc7	8b 4d a8	 mov	 ecx, DWORD PTR _f$[ebp]
  02cca	83 c9 03	 or	 ecx, 3
  02ccd	8b f4		 mov	 esi, esp
  02ccf	51		 push	 ecx
  02cd0	6a 03		 push	 3
  02cd2	8d 55 b0	 lea	 edx, DWORD PTR _rect$[ebp]
  02cd5	52		 push	 edx
  02cd6	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02cd9	50		 push	 eax
  02cda	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  02ce0	3b f4		 cmp	 esi, esp
  02ce2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1223 : 		}
; 1224 : 		else if(sbut->uButType & SBBM_UPARROW)

  02ce7	e9 92 03 00 00	 jmp	 $L22978
$L22979:
  02cec	8b 4d 08	 mov	 ecx, DWORD PTR _sbut$[ebp]
  02cef	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  02cf2	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  02cf8	74 22		 je	 SHORT $L22981

; 1225 : 		{
; 1226 : 			DrawFrameControl(hdc, &rect, DFC_SCROLL, DFCS_SCROLLUP | f);

  02cfa	8b f4		 mov	 esi, esp
  02cfc	8b 45 a8	 mov	 eax, DWORD PTR _f$[ebp]
  02cff	50		 push	 eax
  02d00	6a 03		 push	 3
  02d02	8d 4d b0	 lea	 ecx, DWORD PTR _rect$[ebp]
  02d05	51		 push	 ecx
  02d06	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02d09	52		 push	 edx
  02d0a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  02d10	3b f4		 cmp	 esi, esp
  02d12	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1227 : 		}
; 1228 : 		else if(sbut->uButType & SBBM_DOWNARROW)

  02d17	e9 62 03 00 00	 jmp	 $L22978
$L22981:
  02d1c	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02d1f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02d22	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  02d28	74 25		 je	 SHORT $L22983

; 1229 : 		{
; 1230 : 			DrawFrameControl(hdc, &rect, DFC_SCROLL, DFCS_SCROLLDOWN | f);

  02d2a	8b 55 a8	 mov	 edx, DWORD PTR _f$[ebp]
  02d2d	83 ca 01	 or	 edx, 1
  02d30	8b f4		 mov	 esi, esp
  02d32	52		 push	 edx
  02d33	6a 03		 push	 3
  02d35	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  02d38	50		 push	 eax
  02d39	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02d3c	51		 push	 ecx
  02d3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  02d43	3b f4		 cmp	 esi, esp
  02d45	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1231 : 		}
; 1232 : 		else

  02d4a	e9 2f 03 00 00	 jmp	 $L22978
$L22983:

; 1233 : 		{
; 1234 : 			//
; 1235 : 			if(flags & SBBS_PUSHED)

  02d4f	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  02d52	83 e2 01	 and	 edx, 1
  02d55	0f 84 d7 00 00
	00		 je	 $L22985

; 1236 : 			{
; 1237 : 				if(sbut->uButType & SBBM_RECESSED)

  02d5b	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02d5e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02d61	83 e1 20	 and	 ecx, 32			; 00000020H
  02d64	0f 84 8e 00 00
	00		 je	 $L22986

; 1238 : 				{
; 1239 : 					InflateRect(&rect, -1, -1);

  02d6a	8b f4		 mov	 esi, esp
  02d6c	6a ff		 push	 -1
  02d6e	6a ff		 push	 -1
  02d70	8d 55 b0	 lea	 edx, DWORD PTR _rect$[ebp]
  02d73	52		 push	 edx
  02d74	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
  02d7a	3b f4		 cmp	 esi, esp
  02d7c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1240 : 					DrawEdge(hdc, &rect, EDGE_SUNKEN, BF_RECT|BF_FLAT);

  02d81	8b f4		 mov	 esi, esp
  02d83	68 0f 40 00 00	 push	 16399			; 0000400fH
  02d88	6a 0a		 push	 10			; 0000000aH
  02d8a	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  02d8d	50		 push	 eax
  02d8e	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02d91	51		 push	 ecx
  02d92	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawEdge@16
  02d98	3b f4		 cmp	 esi, esp
  02d9a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1241 : 					InflateRect(&rect, 1, 1);

  02d9f	8b f4		 mov	 esi, esp
  02da1	6a 01		 push	 1
  02da3	6a 01		 push	 1
  02da5	8d 55 b0	 lea	 edx, DWORD PTR _rect$[ebp]
  02da8	52		 push	 edx
  02da9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
  02daf	3b f4		 cmp	 esi, esp
  02db1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1242 : 
; 1243 : 					FrameRect(hdc, &rect, GetSysColorBrush(COLOR_3DDKSHADOW));

  02db6	8b f4		 mov	 esi, esp
  02db8	6a 15		 push	 21			; 00000015H
  02dba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColorBrush@4
  02dc0	3b f4		 cmp	 esi, esp
  02dc2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02dc7	8b f4		 mov	 esi, esp
  02dc9	50		 push	 eax
  02dca	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  02dcd	50		 push	 eax
  02dce	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02dd1	51		 push	 ecx
  02dd2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FrameRect@12
  02dd8	3b f4		 cmp	 esi, esp
  02dda	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1244 : 					InflateRect(&rect, -2, -2);

  02ddf	8b f4		 mov	 esi, esp
  02de1	6a fe		 push	 -2			; fffffffeH
  02de3	6a fe		 push	 -2			; fffffffeH
  02de5	8d 55 b0	 lea	 edx, DWORD PTR _rect$[ebp]
  02de8	52		 push	 edx
  02de9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
  02def	3b f4		 cmp	 esi, esp
  02df1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1245 : 				}
; 1246 : 				else

  02df6	eb 35		 jmp	 SHORT $L22987
$L22986:

; 1247 : 				{
; 1248 : 					DrawEdge(hdc, &rect, EDGE_SUNKEN, BF_RECT | BF_FLAT | BF_ADJUST);

  02df8	8b f4		 mov	 esi, esp
  02dfa	68 0f 60 00 00	 push	 24591			; 0000600fH
  02dff	6a 0a		 push	 10			; 0000000aH
  02e01	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  02e04	50		 push	 eax
  02e05	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02e08	51		 push	 ecx
  02e09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawEdge@16
  02e0f	3b f4		 cmp	 esi, esp
  02e11	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1249 : 					InflateRect(&rect, 1, 1);

  02e16	8b f4		 mov	 esi, esp
  02e18	6a 01		 push	 1
  02e1a	6a 01		 push	 1
  02e1c	8d 55 b0	 lea	 edx, DWORD PTR _rect$[ebp]
  02e1f	52		 push	 edx
  02e20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
  02e26	3b f4		 cmp	 esi, esp
  02e28	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L22987:

; 1250 : 				}
; 1251 : 			}
; 1252 : 			else

  02e2d	e9 dc 00 00 00	 jmp	 $L22988
$L22985:

; 1253 : 			{
; 1254 : 				// draw the button borders
; 1255 : 				if(sbut->uButType & SBBM_TYPE2)

  02e32	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02e35	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02e38	81 e1 00 08 00
	00		 and	 ecx, 2048		; 00000800H
  02e3e	74 34		 je	 SHORT $L22989

; 1256 : 				{
; 1257 : 					DrawFrameControl(hdc, &rect, DFC_BUTTON, DFCS_BUTTONPUSH);

  02e40	8b f4		 mov	 esi, esp
  02e42	6a 10		 push	 16			; 00000010H
  02e44	6a 04		 push	 4
  02e46	8d 55 b0	 lea	 edx, DWORD PTR _rect$[ebp]
  02e49	52		 push	 edx
  02e4a	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02e4d	50		 push	 eax
  02e4e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  02e54	3b f4		 cmp	 esi, esp
  02e56	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1258 : 					InflateRect(&rect, -2, -2);

  02e5b	8b f4		 mov	 esi, esp
  02e5d	6a fe		 push	 -2			; fffffffeH
  02e5f	6a fe		 push	 -2			; fffffffeH
  02e61	8d 4d b0	 lea	 ecx, DWORD PTR _rect$[ebp]
  02e64	51		 push	 ecx
  02e65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
  02e6b	3b f4		 cmp	 esi, esp
  02e6d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1259 : 				}
; 1260 : 
; 1261 : 				else if(sbut->uButType & SBBM_TYPE3)

  02e72	eb 71		 jmp	 SHORT $L22990
$L22989:
  02e74	8b 55 08	 mov	 edx, DWORD PTR _sbut$[ebp]
  02e77	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02e7a	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  02e7f	74 34		 je	 SHORT $L22991

; 1262 : 				{
; 1263 : 					DrawFrameControl(hdc, &rect, DFC_BUTTON, DFCS_BUTTONPUSH);

  02e81	8b f4		 mov	 esi, esp
  02e83	6a 10		 push	 16			; 00000010H
  02e85	6a 04		 push	 4
  02e87	8d 4d b0	 lea	 ecx, DWORD PTR _rect$[ebp]
  02e8a	51		 push	 ecx
  02e8b	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02e8e	52		 push	 edx
  02e8f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawFrameControl@16
  02e95	3b f4		 cmp	 esi, esp
  02e97	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1264 : 					InflateRect(&rect, -1, -1);

  02e9c	8b f4		 mov	 esi, esp
  02e9e	6a ff		 push	 -1
  02ea0	6a ff		 push	 -1
  02ea2	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  02ea5	50		 push	 eax
  02ea6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
  02eac	3b f4		 cmp	 esi, esp
  02eae	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1265 : 				}
; 1266 : 				else

  02eb3	eb 30		 jmp	 SHORT $L22990
$L22991:

; 1267 : 				{
; 1268 : 					DrawEdge(hdc, &rect, EDGE_RAISED, BF_RECT | BF_ADJUST);

  02eb5	8b f4		 mov	 esi, esp
  02eb7	68 0f 20 00 00	 push	 8207			; 0000200fH
  02ebc	6a 05		 push	 5
  02ebe	8d 4d b0	 lea	 ecx, DWORD PTR _rect$[ebp]
  02ec1	51		 push	 ecx
  02ec2	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02ec5	52		 push	 edx
  02ec6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DrawEdge@16
  02ecc	3b f4		 cmp	 esi, esp
  02ece	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1269 : 					rect.bottom++;

  02ed3	8b 45 bc	 mov	 eax, DWORD PTR _rect$[ebp+12]
  02ed6	83 c0 01	 add	 eax, 1
  02ed9	89 45 bc	 mov	 DWORD PTR _rect$[ebp+12], eax

; 1270 : 					rect.right++;

  02edc	8b 4d b8	 mov	 ecx, DWORD PTR _rect$[ebp+8]
  02edf	83 c1 01	 add	 ecx, 1
  02ee2	89 4d b8	 mov	 DWORD PTR _rect$[ebp+8], ecx
$L22990:

; 1271 : 				}
; 1272 : 			
; 1273 : 				OffsetRect(&rect, -1, -1);

  02ee5	8b f4		 mov	 esi, esp
  02ee7	6a ff		 push	 -1
  02ee9	6a ff		 push	 -1
  02eeb	8d 55 b0	 lea	 edx, DWORD PTR _rect$[ebp]
  02eee	52		 push	 edx
  02eef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  02ef5	3b f4		 cmp	 esi, esp
  02ef7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1274 : 				rect.top++;	rect.left++;

  02efc	8b 45 b4	 mov	 eax, DWORD PTR _rect$[ebp+4]
  02eff	83 c0 01	 add	 eax, 1
  02f02	89 45 b4	 mov	 DWORD PTR _rect$[ebp+4], eax
  02f05	8b 4d b0	 mov	 ecx, DWORD PTR _rect$[ebp]
  02f08	83 c1 01	 add	 ecx, 1
  02f0b	89 4d b0	 mov	 DWORD PTR _rect$[ebp], ecx
$L22988:

; 1275 : 			}
; 1276 : 
; 1277 : 			if(sbut->hBmp)

  02f0e	8b 55 08	 mov	 edx, DWORD PTR _sbut$[ebp]
  02f11	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  02f15	0f 84 90 00 00
	00		 je	 $L22993

; 1278 : 			{
; 1279 : 				PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  02f1b	8b f4		 mov	 esi, esp
  02f1d	6a 0f		 push	 15			; 0000000fH
  02f1f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  02f25	3b f4		 cmp	 esi, esp
  02f27	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02f2c	50		 push	 eax
  02f2d	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  02f30	50		 push	 eax
  02f31	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02f34	51		 push	 ecx
  02f35	e8 00 00 00 00	 call	 _PaintRect
  02f3a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1280 : 
; 1281 : 				if(flags & SBBS_PUSHED)	

  02f3d	8b 55 14	 mov	 edx, DWORD PTR _flags$[ebp]
  02f40	83 e2 01	 and	 edx, 1
  02f43	74 12		 je	 SHORT $L22994

; 1282 : 				{
; 1283 : 					rect.top++; rect.left++;

  02f45	8b 45 b4	 mov	 eax, DWORD PTR _rect$[ebp+4]
  02f48	83 c0 01	 add	 eax, 1
  02f4b	89 45 b4	 mov	 DWORD PTR _rect$[ebp+4], eax
  02f4e	8b 4d b0	 mov	 ecx, DWORD PTR _rect$[ebp]
  02f51	83 c1 01	 add	 ecx, 1
  02f54	89 4d b0	 mov	 DWORD PTR _rect$[ebp], ecx
$L22994:

; 1284 : 				}
; 1285 : 
; 1286 : 				IntersectClipRect(hdc, rect.left, rect.top, rect.right,rect.bottom);

  02f57	8b f4		 mov	 esi, esp
  02f59	8b 55 bc	 mov	 edx, DWORD PTR _rect$[ebp+12]
  02f5c	52		 push	 edx
  02f5d	8b 45 b8	 mov	 eax, DWORD PTR _rect$[ebp+8]
  02f60	50		 push	 eax
  02f61	8b 4d b4	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  02f64	51		 push	 ecx
  02f65	8b 55 b0	 mov	 edx, DWORD PTR _rect$[ebp]
  02f68	52		 push	 edx
  02f69	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  02f6c	50		 push	 eax
  02f6d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IntersectClipRect@20
  02f73	3b f4		 cmp	 esi, esp
  02f75	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1287 : 				DrawImage(hdc, sbut->hBmp, &rect);

  02f7a	8d 4d b0	 lea	 ecx, DWORD PTR _rect$[ebp]
  02f7d	51		 push	 ecx
  02f7e	8b 55 08	 mov	 edx, DWORD PTR _sbut$[ebp]
  02f81	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  02f84	50		 push	 eax
  02f85	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  02f88	51		 push	 ecx
  02f89	e8 00 00 00 00	 call	 _DrawImage
  02f8e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1288 : 				SelectClipRgn(hdc, 0);

  02f91	8b f4		 mov	 esi, esp
  02f93	6a 00		 push	 0
  02f95	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02f98	52		 push	 edx
  02f99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectClipRgn@8
  02f9f	3b f4		 cmp	 esi, esp
  02fa1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1289 : 			}
; 1290 : 			else if(sbut->hEmf)

  02fa6	e9 d3 00 00 00	 jmp	 $L22978
$L22993:
  02fab	8b 45 08	 mov	 eax, DWORD PTR _sbut$[ebp]
  02fae	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  02fb2	0f 84 a4 00 00
	00		 je	 $L22996

; 1291 : 			{
; 1292 : 				PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  02fb8	8b f4		 mov	 esi, esp
  02fba	6a 0f		 push	 15			; 0000000fH
  02fbc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  02fc2	3b f4		 cmp	 esi, esp
  02fc4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  02fc9	50		 push	 eax
  02fca	8d 4d b0	 lea	 ecx, DWORD PTR _rect$[ebp]
  02fcd	51		 push	 ecx
  02fce	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  02fd1	52		 push	 edx
  02fd2	e8 00 00 00 00	 call	 _PaintRect
  02fd7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1293 : 				InflateRect(&rect, -1, -1);		

  02fda	8b f4		 mov	 esi, esp
  02fdc	6a ff		 push	 -1
  02fde	6a ff		 push	 -1
  02fe0	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  02fe3	50		 push	 eax
  02fe4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InflateRect@12
  02fea	3b f4		 cmp	 esi, esp
  02fec	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1294 : 
; 1295 : 				if(flags & SBBS_PUSHED)	

  02ff1	8b 4d 14	 mov	 ecx, DWORD PTR _flags$[ebp]
  02ff4	83 e1 01	 and	 ecx, 1
  02ff7	74 12		 je	 SHORT $L22997

; 1296 : 				{
; 1297 : 					rect.top++; rect.left++;

  02ff9	8b 55 b4	 mov	 edx, DWORD PTR _rect$[ebp+4]
  02ffc	83 c2 01	 add	 edx, 1
  02fff	89 55 b4	 mov	 DWORD PTR _rect$[ebp+4], edx
  03002	8b 45 b0	 mov	 eax, DWORD PTR _rect$[ebp]
  03005	83 c0 01	 add	 eax, 1
  03008	89 45 b0	 mov	 DWORD PTR _rect$[ebp], eax
$L22997:

; 1298 : 				}
; 1299 : 
; 1300 : 				IntersectClipRect(hdc, rect.left, rect.top, rect.right,rect.bottom);

  0300b	8b f4		 mov	 esi, esp
  0300d	8b 4d bc	 mov	 ecx, DWORD PTR _rect$[ebp+12]
  03010	51		 push	 ecx
  03011	8b 55 b8	 mov	 edx, DWORD PTR _rect$[ebp+8]
  03014	52		 push	 edx
  03015	8b 45 b4	 mov	 eax, DWORD PTR _rect$[ebp+4]
  03018	50		 push	 eax
  03019	8b 4d b0	 mov	 ecx, DWORD PTR _rect$[ebp]
  0301c	51		 push	 ecx
  0301d	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  03020	52		 push	 edx
  03021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IntersectClipRect@20
  03027	3b f4		 cmp	 esi, esp
  03029	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1301 : 				DrawMetaFile(hdc, sbut->hEmf, &rect);

  0302e	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  03031	50		 push	 eax
  03032	8b 4d 08	 mov	 ecx, DWORD PTR _sbut$[ebp]
  03035	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  03038	52		 push	 edx
  03039	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  0303c	50		 push	 eax
  0303d	e8 00 00 00 00	 call	 _DrawMetaFile
  03042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1302 : 				SelectClipRgn(hdc, 0);

  03045	8b f4		 mov	 esi, esp
  03047	6a 00		 push	 0
  03049	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0304c	51		 push	 ecx
  0304d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectClipRgn@8
  03053	3b f4		 cmp	 esi, esp
  03055	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1303 : 			}
; 1304 : 			else

  0305a	eb 22		 jmp	 SHORT $L22978
$L22996:

; 1305 : 			{
; 1306 : 				PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  0305c	8b f4		 mov	 esi, esp
  0305e	6a 0f		 push	 15			; 0000000fH
  03060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  03066	3b f4		 cmp	 esi, esp
  03068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0306d	50		 push	 eax
  0306e	8d 55 b0	 lea	 edx, DWORD PTR _rect$[ebp]
  03071	52		 push	 edx
  03072	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  03075	50		 push	 eax
  03076	e8 00 00 00 00	 call	 _PaintRect
  0307b	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22978:

; 1307 : 			}
; 1308 : 		}
; 1309 : 			
; 1310 : 
; 1311 : 		break;

  0307e	eb 5d		 jmp	 SHORT $L22967
$L22999:

; 1312 : 
; 1313 : 	case SBBT_BLANK:
; 1314 : 		PaintRect(hdc, &rect, GetSysColor(COLOR_3DFACE));

  03080	8b f4		 mov	 esi, esp
  03082	6a 0f		 push	 15			; 0000000fH
  03084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  0308a	3b f4		 cmp	 esi, esp
  0308c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03091	50		 push	 eax
  03092	8d 4d b0	 lea	 ecx, DWORD PTR _rect$[ebp]
  03095	51		 push	 ecx
  03096	8b 55 0c	 mov	 edx, DWORD PTR _hdc$[ebp]
  03099	52		 push	 edx
  0309a	e8 00 00 00 00	 call	 _PaintRect
  0309f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1315 : 		break;

  030a2	eb 39		 jmp	 SHORT $L22967
$L23000:

; 1316 : 
; 1317 : 	case SBBT_FLAT:
; 1318 : 		DrawBlankButton(hdc, &rect, BF_FLAT);

  030a4	68 00 40 00 00	 push	 16384			; 00004000H
  030a9	8d 45 b0	 lea	 eax, DWORD PTR _rect$[ebp]
  030ac	50		 push	 eax
  030ad	8b 4d 0c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  030b0	51		 push	 ecx
  030b1	e8 00 00 00 00	 call	 _DrawBlankButton
  030b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1319 : 		break;

  030b9	eb 22		 jmp	 SHORT $L22967
$L23001:

; 1320 : 
; 1321 : 	case SBBT_DARK:
; 1322 : 		PaintRect(hdc, &rect, GetSysColor(COLOR_3DDKSHADOW));

  030bb	8b f4		 mov	 esi, esp
  030bd	6a 15		 push	 21			; 00000015H
  030bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  030c5	3b f4		 cmp	 esi, esp
  030c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  030cc	50		 push	 eax
  030cd	8d 55 b0	 lea	 edx, DWORD PTR _rect$[ebp]
  030d0	52		 push	 edx
  030d1	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  030d4	50		 push	 eax
  030d5	e8 00 00 00 00	 call	 _PaintRect
  030da	83 c4 0c	 add	 esp, 12			; 0000000cH
$L22967:

; 1323 : 		break;
; 1324 : 	}
; 1325 : 	
; 1326 : 	return 0;

  030dd	33 c0		 xor	 eax, eax

; 1327 : }

  030df	52		 push	 edx
  030e0	8b cd		 mov	 ecx, ebp
  030e2	50		 push	 eax
  030e3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23954
  030e9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  030ee	58		 pop	 eax
  030ef	5a		 pop	 edx
  030f0	5f		 pop	 edi
  030f1	5e		 pop	 esi
  030f2	83 c4 5c	 add	 esp, 92			; 0000005cH
  030f5	3b ec		 cmp	 ebp, esp
  030f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  030fc	8b e5		 mov	 esp, ebp
  030fe	5d		 pop	 ebp
  030ff	c3		 ret	 0
$L23954:
  03100	02 00 00 00	 DD	 2
  03104	00 00 00 00	 DD	 $L23953
$L23953:
  03108	cc ff ff ff	 DD	 -52			; ffffffccH
  0310c	30 00 00 00	 DD	 48			; 00000030H
  03110	00 00 00 00	 DD	 $L23951
  03114	b0 ff ff ff	 DD	 -80			; ffffffb0H
  03118	10 00 00 00	 DD	 16			; 00000010H
  0311c	00 00 00 00	 DD	 $L23952
$L23952:
  03120	72		 DB	 114			; 00000072H
  03121	65		 DB	 101			; 00000065H
  03122	63		 DB	 99			; 00000063H
  03123	74		 DB	 116			; 00000074H
  03124	00		 DB	 0
$L23951:
  03125	6e		 DB	 110			; 0000006eH
  03126	6d		 DB	 109			; 0000006dH
  03127	63		 DB	 99			; 00000063H
  03128	64		 DB	 100			; 00000064H
  03129	00		 DB	 0
$L23955:
  0312a	00 00 00 00	 DD	 $L22976
  0312e	00 00 00 00	 DD	 $L22974
  03132	00 00 00 00	 DD	 $L22973
  03136	00 00 00 00	 DD	 $L23000
  0313a	00 00 00 00	 DD	 $L22999
  0313e	00 00 00 00	 DD	 $L23001
  03142	00 00 00 00	 DD	 $L22970
_DrawScrollButton ENDP
_TEXT	ENDS
EXTRN	__imp__GetObjectA@12:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_colorOld$ = -108					; size = 4
_delta$ = -100						; size = 8
_p$ = -84						; size = 8
_rcDest$ = -68						; size = 16
_hOldBM$ = -48						; size = 4
_memdc$ = -44						; size = 4
_cy$ = -40						; size = 4
_cx$ = -36						; size = 4
_bm$ = -28						; size = 24
_hdc$ = 8						; size = 4
_hBitmap$ = 12						; size = 4
_rc$ = 16						; size = 4
_DrawImage PROC NEAR

; 1103 : {

  03150	55		 push	 ebp
  03151	8b ec		 mov	 ebp, esp
  03153	83 ec 6c	 sub	 esp, 108		; 0000006cH
  03156	56		 push	 esi
  03157	57		 push	 edi
  03158	8d 7d 94	 lea	 edi, DWORD PTR [ebp-108]
  0315b	b9 1b 00 00 00	 mov	 ecx, 27			; 0000001bH
  03160	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  03165	f3 ab		 rep stosd

; 1104 : 	BITMAP bm;
; 1105 : 	int cx;
; 1106 : 	int cy;   
; 1107 : 	HDC memdc;
; 1108 : 	HBITMAP hOldBM;
; 1109 : 	RECT  rcDest = *rc;   

  03167	8b 45 10	 mov	 eax, DWORD PTR _rc$[ebp]
  0316a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0316c	89 4d bc	 mov	 DWORD PTR _rcDest$[ebp], ecx
  0316f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03172	89 55 c0	 mov	 DWORD PTR _rcDest$[ebp+4], edx
  03175	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  03178	89 4d c4	 mov	 DWORD PTR _rcDest$[ebp+8], ecx
  0317b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0317e	89 55 c8	 mov	 DWORD PTR _rcDest$[ebp+12], edx

; 1110 : 	POINT p;
; 1111 : 	SIZE  delta;
; 1112 : 	COLORREF colorOld;
; 1113 : 
; 1114 : 	if(hBitmap == NULL) 

  03181	83 7d 0c 00	 cmp	 DWORD PTR _hBitmap$[ebp], 0
  03185	75 05		 jne	 SHORT $L22937

; 1115 : 		return;

  03187	e9 91 01 00 00	 jmp	 $L22926
$L22937:

; 1116 : 
; 1117 : 	// center bitmap in caller's rectangle   
; 1118 : 	GetObject(hBitmap, sizeof bm, &bm);   

  0318c	8b f4		 mov	 esi, esp
  0318e	8d 45 e4	 lea	 eax, DWORD PTR _bm$[ebp]
  03191	50		 push	 eax
  03192	6a 18		 push	 24			; 00000018H
  03194	8b 4d 0c	 mov	 ecx, DWORD PTR _hBitmap$[ebp]
  03197	51		 push	 ecx
  03198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12
  0319e	3b f4		 cmp	 esi, esp
  031a0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1119 : 	
; 1120 : 	cx = bm.bmWidth;

  031a5	8b 55 e8	 mov	 edx, DWORD PTR _bm$[ebp+4]
  031a8	89 55 dc	 mov	 DWORD PTR _cx$[ebp], edx

; 1121 : 	cy = bm.bmHeight;

  031ab	8b 45 ec	 mov	 eax, DWORD PTR _bm$[ebp+8]
  031ae	89 45 d8	 mov	 DWORD PTR _cy$[ebp], eax

; 1122 : 
; 1123 : 	delta.cx = (rc->right-rc->left - cx) / 2;

  031b1	8b 4d 10	 mov	 ecx, DWORD PTR _rc$[ebp]
  031b4	8b 55 10	 mov	 edx, DWORD PTR _rc$[ebp]
  031b7	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  031ba	2b 02		 sub	 eax, DWORD PTR [edx]
  031bc	2b 45 dc	 sub	 eax, DWORD PTR _cx$[ebp]
  031bf	99		 cdq
  031c0	2b c2		 sub	 eax, edx
  031c2	d1 f8		 sar	 eax, 1
  031c4	89 45 9c	 mov	 DWORD PTR _delta$[ebp], eax

; 1124 : 	delta.cy = (rc->bottom-rc->top - cy) / 2;

  031c7	8b 45 10	 mov	 eax, DWORD PTR _rc$[ebp]
  031ca	8b 4d 10	 mov	 ecx, DWORD PTR _rc$[ebp]
  031cd	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  031d0	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  031d3	2b 45 d8	 sub	 eax, DWORD PTR _cy$[ebp]
  031d6	99		 cdq
  031d7	2b c2		 sub	 eax, edx
  031d9	d1 f8		 sar	 eax, 1
  031db	89 45 a0	 mov	 DWORD PTR _delta$[ebp+4], eax

; 1125 : 	
; 1126 : 	if(rc->right-rc->left > cx)

  031de	8b 55 10	 mov	 edx, DWORD PTR _rc$[ebp]
  031e1	8b 45 10	 mov	 eax, DWORD PTR _rc$[ebp]
  031e4	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  031e7	2b 08		 sub	 ecx, DWORD PTR [eax]
  031e9	3b 4d dc	 cmp	 ecx, DWORD PTR _cx$[ebp]
  031ec	7e 4c		 jle	 SHORT $L22938

; 1127 : 	{
; 1128 : 		SetRect(&rcDest, rc->left+delta.cx, rc->top + delta.cy, 0, 0);   

  031ee	8b f4		 mov	 esi, esp
  031f0	6a 00		 push	 0
  031f2	6a 00		 push	 0
  031f4	8b 55 10	 mov	 edx, DWORD PTR _rc$[ebp]
  031f7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  031fa	03 45 a0	 add	 eax, DWORD PTR _delta$[ebp+4]
  031fd	50		 push	 eax
  031fe	8b 4d 10	 mov	 ecx, DWORD PTR _rc$[ebp]
  03201	8b 11		 mov	 edx, DWORD PTR [ecx]
  03203	03 55 9c	 add	 edx, DWORD PTR _delta$[ebp]
  03206	52		 push	 edx
  03207	8d 45 bc	 lea	 eax, DWORD PTR _rcDest$[ebp]
  0320a	50		 push	 eax
  0320b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  03211	3b f4		 cmp	 esi, esp
  03213	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1129 : 		rcDest.right = rcDest.left + cx;

  03218	8b 4d bc	 mov	 ecx, DWORD PTR _rcDest$[ebp]
  0321b	03 4d dc	 add	 ecx, DWORD PTR _cx$[ebp]
  0321e	89 4d c4	 mov	 DWORD PTR _rcDest$[ebp+8], ecx

; 1130 : 		rcDest.bottom = rcDest.top + cy;

  03221	8b 55 c0	 mov	 edx, DWORD PTR _rcDest$[ebp+4]
  03224	03 55 d8	 add	 edx, DWORD PTR _cy$[ebp]
  03227	89 55 c8	 mov	 DWORD PTR _rcDest$[ebp+12], edx

; 1131 : 		p.x = 0;

  0322a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 1132 : 		p.y = 0;

  03231	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+4], 0

; 1133 : 	}
; 1134 : 	else

  03238	eb 10		 jmp	 SHORT $L22939
$L22938:

; 1135 : 	{
; 1136 : 		p.x = -delta.cx;   

  0323a	8b 45 9c	 mov	 eax, DWORD PTR _delta$[ebp]
  0323d	f7 d8		 neg	 eax
  0323f	89 45 ac	 mov	 DWORD PTR _p$[ebp], eax

; 1137 : 		p.y = -delta.cy;

  03242	8b 4d a0	 mov	 ecx, DWORD PTR _delta$[ebp+4]
  03245	f7 d9		 neg	 ecx
  03247	89 4d b0	 mov	 DWORD PTR _p$[ebp+4], ecx
$L22939:

; 1138 : 	}
; 1139 :    
; 1140 : 	// select checkmark into memory DC
; 1141 : 	memdc = CreateCompatibleDC(hdc);

  0324a	8b f4		 mov	 esi, esp
  0324c	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  0324f	52		 push	 edx
  03250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateCompatibleDC@4
  03256	3b f4		 cmp	 esi, esp
  03258	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0325d	89 45 d4	 mov	 DWORD PTR _memdc$[ebp], eax

; 1142 : 	hOldBM = (HBITMAP)SelectObject(memdc, hBitmap);

  03260	8b f4		 mov	 esi, esp
  03262	8b 45 0c	 mov	 eax, DWORD PTR _hBitmap$[ebp]
  03265	50		 push	 eax
  03266	8b 4d d4	 mov	 ecx, DWORD PTR _memdc$[ebp]
  03269	51		 push	 ecx
  0326a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  03270	3b f4		 cmp	 esi, esp
  03272	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03277	89 45 d0	 mov	 DWORD PTR _hOldBM$[ebp], eax

; 1143 :    
; 1144 : 	// set BG color based on selected state   
; 1145 : 	colorOld = SetBkColor(hdc, GetSysColor(COLOR_3DFACE));

  0327a	8b f4		 mov	 esi, esp
  0327c	6a 0f		 push	 15			; 0000000fH
  0327e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  03284	3b f4		 cmp	 esi, esp
  03286	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0328b	8b f4		 mov	 esi, esp
  0328d	50		 push	 eax
  0328e	8b 55 08	 mov	 edx, DWORD PTR _hdc$[ebp]
  03291	52		 push	 edx
  03292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  03298	3b f4		 cmp	 esi, esp
  0329a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0329f	89 45 94	 mov	 DWORD PTR _colorOld$[ebp], eax

; 1146 : 
; 1147 : 	BitBlt(hdc, rcDest.left, rcDest.top, rcDest.right-rcDest.left, rcDest.bottom-rcDest.top, memdc, p.x, p.y, SRCCOPY);

  032a2	8b f4		 mov	 esi, esp
  032a4	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  032a9	8b 45 b0	 mov	 eax, DWORD PTR _p$[ebp+4]
  032ac	50		 push	 eax
  032ad	8b 4d ac	 mov	 ecx, DWORD PTR _p$[ebp]
  032b0	51		 push	 ecx
  032b1	8b 55 d4	 mov	 edx, DWORD PTR _memdc$[ebp]
  032b4	52		 push	 edx
  032b5	8b 45 c8	 mov	 eax, DWORD PTR _rcDest$[ebp+12]
  032b8	2b 45 c0	 sub	 eax, DWORD PTR _rcDest$[ebp+4]
  032bb	50		 push	 eax
  032bc	8b 4d c4	 mov	 ecx, DWORD PTR _rcDest$[ebp+8]
  032bf	2b 4d bc	 sub	 ecx, DWORD PTR _rcDest$[ebp]
  032c2	51		 push	 ecx
  032c3	8b 55 c0	 mov	 edx, DWORD PTR _rcDest$[ebp+4]
  032c6	52		 push	 edx
  032c7	8b 45 bc	 mov	 eax, DWORD PTR _rcDest$[ebp]
  032ca	50		 push	 eax
  032cb	8b 4d 08	 mov	 ecx, DWORD PTR _hdc$[ebp]
  032ce	51		 push	 ecx
  032cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BitBlt@36
  032d5	3b f4		 cmp	 esi, esp
  032d7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1148 : 
; 1149 : 	// restore
; 1150 : 	SetBkColor(hdc, colorOld);

  032dc	8b f4		 mov	 esi, esp
  032de	8b 55 94	 mov	 edx, DWORD PTR _colorOld$[ebp]
  032e1	52		 push	 edx
  032e2	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  032e5	50		 push	 eax
  032e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetBkColor@8
  032ec	3b f4		 cmp	 esi, esp
  032ee	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1151 : 	SelectObject(memdc, hOldBM);

  032f3	8b f4		 mov	 esi, esp
  032f5	8b 4d d0	 mov	 ecx, DWORD PTR _hOldBM$[ebp]
  032f8	51		 push	 ecx
  032f9	8b 55 d4	 mov	 edx, DWORD PTR _memdc$[ebp]
  032fc	52		 push	 edx
  032fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectObject@8
  03303	3b f4		 cmp	 esi, esp
  03305	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1152 : 	DeleteDC(memdc);

  0330a	8b f4		 mov	 esi, esp
  0330c	8b 45 d4	 mov	 eax, DWORD PTR _memdc$[ebp]
  0330f	50		 push	 eax
  03310	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  03316	3b f4		 cmp	 esi, esp
  03318	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L22926:

; 1153 : }

  0331d	52		 push	 edx
  0331e	8b cd		 mov	 ecx, ebp
  03320	50		 push	 eax
  03321	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23962
  03327	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0332c	58		 pop	 eax
  0332d	5a		 pop	 edx
  0332e	5f		 pop	 edi
  0332f	5e		 pop	 esi
  03330	83 c4 6c	 add	 esp, 108		; 0000006cH
  03333	3b ec		 cmp	 ebp, esp
  03335	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0333a	8b e5		 mov	 esp, ebp
  0333c	5d		 pop	 ebp
  0333d	c3		 ret	 0
$L23962:
  0333e	04 00 00 00	 DD	 4
  03342	00 00 00 00	 DD	 $L23961
$L23961:
  03346	e4 ff ff ff	 DD	 -28			; ffffffe4H
  0334a	18 00 00 00	 DD	 24			; 00000018H
  0334e	00 00 00 00	 DD	 $L23957
  03352	bc ff ff ff	 DD	 -68			; ffffffbcH
  03356	10 00 00 00	 DD	 16			; 00000010H
  0335a	00 00 00 00	 DD	 $L23958
  0335e	ac ff ff ff	 DD	 -84			; ffffffacH
  03362	08 00 00 00	 DD	 8
  03366	00 00 00 00	 DD	 $L23959
  0336a	9c ff ff ff	 DD	 -100			; ffffff9cH
  0336e	08 00 00 00	 DD	 8
  03372	00 00 00 00	 DD	 $L23960
$L23960:
  03376	64		 DB	 100			; 00000064H
  03377	65		 DB	 101			; 00000065H
  03378	6c		 DB	 108			; 0000006cH
  03379	74		 DB	 116			; 00000074H
  0337a	61		 DB	 97			; 00000061H
  0337b	00		 DB	 0
$L23959:
  0337c	70		 DB	 112			; 00000070H
  0337d	00		 DB	 0
$L23958:
  0337e	72		 DB	 114			; 00000072H
  0337f	63		 DB	 99			; 00000063H
  03380	44		 DB	 68			; 00000044H
  03381	65		 DB	 101			; 00000065H
  03382	73		 DB	 115			; 00000073H
  03383	74		 DB	 116			; 00000074H
  03384	00		 DB	 0
$L23957:
  03385	62		 DB	 98			; 00000062H
  03386	6d		 DB	 109			; 0000006dH
  03387	00		 DB	 0
_DrawImage ENDP
_TEXT	ENDS
EXTRN	__imp__PlayEnhMetaFile@12:NEAR
EXTRN	__imp__SetWindowOrgEx@16:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_pt$ = -36						; size = 8
_rc$ = -20						; size = 16
_hdc$ = 8						; size = 4
_hemf$ = 12						; size = 4
_rect$ = 16						; size = 4
_DrawMetaFile PROC NEAR

; 1159 : {

  03390	55		 push	 ebp
  03391	8b ec		 mov	 ebp, esp
  03393	83 ec 28	 sub	 esp, 40			; 00000028H
  03396	56		 push	 esi
  03397	57		 push	 edi
  03398	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0339b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  033a0	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  033a5	f3 ab		 rep stosd

; 1160 : 	RECT rc;
; 1161 : 	POINT pt;
; 1162 : 
; 1163 : 	SetRect(&rc, 0, 0, rect->right-rect->left, rect->bottom-rect->top);

  033a7	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  033aa	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  033ad	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  033b0	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  033b3	8b f4		 mov	 esi, esp
  033b5	52		 push	 edx
  033b6	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  033b9	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  033bc	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  033bf	2b 11		 sub	 edx, DWORD PTR [ecx]
  033c1	52		 push	 edx
  033c2	6a 00		 push	 0
  033c4	6a 00		 push	 0
  033c6	8d 45 ec	 lea	 eax, DWORD PTR _rc$[ebp]
  033c9	50		 push	 eax
  033ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  033d0	3b f4		 cmp	 esi, esp
  033d2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1164 : 	SetWindowOrgEx(hdc, -rect->left, -rect->top, &pt);

  033d7	8b f4		 mov	 esi, esp
  033d9	8d 4d dc	 lea	 ecx, DWORD PTR _pt$[ebp]
  033dc	51		 push	 ecx
  033dd	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  033e0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  033e3	f7 d8		 neg	 eax
  033e5	50		 push	 eax
  033e6	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  033e9	8b 11		 mov	 edx, DWORD PTR [ecx]
  033eb	f7 da		 neg	 edx
  033ed	52		 push	 edx
  033ee	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  033f1	50		 push	 eax
  033f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowOrgEx@16
  033f8	3b f4		 cmp	 esi, esp
  033fa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1165 : 	PlayEnhMetaFile(hdc, hemf, &rc);

  033ff	8b f4		 mov	 esi, esp
  03401	8d 4d ec	 lea	 ecx, DWORD PTR _rc$[ebp]
  03404	51		 push	 ecx
  03405	8b 55 0c	 mov	 edx, DWORD PTR _hemf$[ebp]
  03408	52		 push	 edx
  03409	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  0340c	50		 push	 eax
  0340d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PlayEnhMetaFile@12
  03413	3b f4		 cmp	 esi, esp
  03415	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1166 : 	SetWindowOrgEx(hdc, pt.x, pt.y, 0);

  0341a	8b f4		 mov	 esi, esp
  0341c	6a 00		 push	 0
  0341e	8b 4d e0	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  03421	51		 push	 ecx
  03422	8b 55 dc	 mov	 edx, DWORD PTR _pt$[ebp]
  03425	52		 push	 edx
  03426	8b 45 08	 mov	 eax, DWORD PTR _hdc$[ebp]
  03429	50		 push	 eax
  0342a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowOrgEx@16
  03430	3b f4		 cmp	 esi, esp
  03432	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1167 : }

  03437	52		 push	 edx
  03438	8b cd		 mov	 ecx, ebp
  0343a	50		 push	 eax
  0343b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23967
  03441	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  03446	58		 pop	 eax
  03447	5a		 pop	 edx
  03448	5f		 pop	 edi
  03449	5e		 pop	 esi
  0344a	83 c4 28	 add	 esp, 40			; 00000028H
  0344d	3b ec		 cmp	 ebp, esp
  0344f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03454	8b e5		 mov	 esp, ebp
  03456	5d		 pop	 ebp
  03457	c3		 ret	 0
$L23967:
  03458	02 00 00 00	 DD	 2
  0345c	00 00 00 00	 DD	 $L23966
$L23966:
  03460	ec ff ff ff	 DD	 -20			; ffffffecH
  03464	10 00 00 00	 DD	 16			; 00000010H
  03468	00 00 00 00	 DD	 $L23964
  0346c	dc ff ff ff	 DD	 -36			; ffffffdcH
  03470	08 00 00 00	 DD	 8
  03474	00 00 00 00	 DD	 $L23965
$L23965:
  03478	70		 DB	 112			; 00000070H
  03479	74		 DB	 116			; 00000074H
  0347a	00		 DB	 0
$L23964:
  0347b	72		 DB	 114			; 00000072H
  0347c	63		 DB	 99			; 00000063H
  0347d	00		 DB	 0
_DrawMetaFile ENDP
; Function compile flags: /Odt /RTCsu
_rc$ = -20						; size = 16
_sbar$ = 8						; size = 4
_hdc$ = 12						; size = 4
_rect$ = 16						; size = 4
_leftright$ = 20					; size = 4
_DrawVertButtons PROC NEAR

; 1370 : {

  03480	55		 push	 ebp
  03481	8b ec		 mov	 ebp, esp
  03483	83 ec 18	 sub	 esp, 24			; 00000018H
  03486	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0348b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0348e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  03491	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  03494	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  03497	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0349a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1371 : 	RECT rc = *rect;

  0349d	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  034a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  034a2	89 4d ec	 mov	 DWORD PTR _rc$[ebp], ecx
  034a5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  034a8	89 55 f0	 mov	 DWORD PTR _rc$[ebp+4], edx
  034ab	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  034ae	89 4d f4	 mov	 DWORD PTR _rc$[ebp+8], ecx
  034b1	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  034b4	89 55 f8	 mov	 DWORD PTR _rc$[ebp+12], edx

; 1372 : 	RotateRect(&rc);

  034b7	8d 45 ec	 lea	 eax, DWORD PTR _rc$[ebp]
  034ba	50		 push	 eax
  034bb	e8 00 00 00 00	 call	 _RotateRect@4

; 1373 : 	DrawHorzButtons(sbar, hdc, &rc, leftright);

  034c0	8b 4d 14	 mov	 ecx, DWORD PTR _leftright$[ebp]
  034c3	51		 push	 ecx
  034c4	8d 55 ec	 lea	 edx, DWORD PTR _rc$[ebp]
  034c7	52		 push	 edx
  034c8	8b 45 0c	 mov	 eax, DWORD PTR _hdc$[ebp]
  034cb	50		 push	 eax
  034cc	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  034cf	51		 push	 ecx
  034d0	e8 00 00 00 00	 call	 _DrawHorzButtons
  034d5	83 c4 10	 add	 esp, 16			; 00000010H

; 1374 : 	return 0;

  034d8	33 c0		 xor	 eax, eax

; 1375 : }

  034da	52		 push	 edx
  034db	8b cd		 mov	 ecx, ebp
  034dd	50		 push	 eax
  034de	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23971
  034e4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  034e9	58		 pop	 eax
  034ea	5a		 pop	 edx
  034eb	83 c4 18	 add	 esp, 24			; 00000018H
  034ee	3b ec		 cmp	 ebp, esp
  034f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  034f5	8b e5		 mov	 esp, ebp
  034f7	5d		 pop	 ebp
  034f8	c3		 ret	 0
$L23971:
  034f9	01 00 00 00	 DD	 1
  034fd	00 00 00 00	 DD	 $L23970
$L23970:
  03501	ec ff ff ff	 DD	 -20			; ffffffecH
  03505	10 00 00 00	 DD	 16			; 00000010H
  03509	00 00 00 00	 DD	 $L23969
$L23969:
  0350d	72		 DB	 114			; 00000072H
  0350e	63		 DB	 99			; 00000063H
  0350f	00		 DB	 0
_DrawVertButtons ENDP
_TEXT	ENDS
EXTRN	__imp__PtInRect@12:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_pt$ = -60						; size = 8
_vrect$ = -44						; size = 16
_hrect$ = -20						; size = 16
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCHitTest PROC NEAR

; 1627 : {

  03510	55		 push	 ebp
  03511	8b ec		 mov	 ebp, esp
  03513	83 ec 40	 sub	 esp, 64			; 00000040H
  03516	56		 push	 esi
  03517	57		 push	 edi
  03518	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  0351b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  03520	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  03525	f3 ab		 rep stosd

; 1628 : 	RECT hrect;
; 1629 : 	RECT vrect;
; 1630 : 	POINT pt;
; 1631 : 
; 1632 : 	pt.x = LOWORD(lParam);

  03527	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0352a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0352f	0f b7 c8	 movzx	 ecx, ax
  03532	89 4d c4	 mov	 DWORD PTR _pt$[ebp], ecx

; 1633 : 	pt.y = HIWORD(lParam);

  03535	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  03538	c1 ea 10	 shr	 edx, 16			; 00000010H
  0353b	0f b7 c2	 movzx	 eax, dx
  0353e	89 45 c8	 mov	 DWORD PTR _pt$[ebp+4], eax

; 1634 : 	
; 1635 : 	//work out exactly where the Horizontal and Vertical scrollbars are
; 1636 : 	GetHScrollRect(sw, hwnd, &hrect);

  03541	8d 4d ec	 lea	 ecx, DWORD PTR _hrect$[ebp]
  03544	51		 push	 ecx
  03545	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03548	52		 push	 edx
  03549	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0354c	50		 push	 eax
  0354d	e8 00 00 00 00	 call	 _GetHScrollRect
  03552	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1637 : 	GetVScrollRect(sw, hwnd, &vrect);

  03555	8d 4d d4	 lea	 ecx, DWORD PTR _vrect$[ebp]
  03558	51		 push	 ecx
  03559	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0355c	52		 push	 edx
  0355d	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  03560	50		 push	 eax
  03561	e8 00 00 00 00	 call	 _GetVScrollRect
  03566	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1638 : 	
; 1639 : 	//Clicked in the horizontal scrollbar area
; 1640 : 	if(sw->sbarHorz.fScrollVisible && PtInRect(&hrect, pt))

  03569	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0356c	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  03570	74 26		 je	 SHORT $L23117
  03572	8b f4		 mov	 esi, esp
  03574	8b 55 c8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  03577	52		 push	 edx
  03578	8b 45 c4	 mov	 eax, DWORD PTR _pt$[ebp]
  0357b	50		 push	 eax
  0357c	8d 4d ec	 lea	 ecx, DWORD PTR _hrect$[ebp]
  0357f	51		 push	 ecx
  03580	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  03586	3b f4		 cmp	 esi, esp
  03588	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0358d	85 c0		 test	 eax, eax
  0358f	74 07		 je	 SHORT $L23117

; 1641 : 	{
; 1642 : 		return HTHSCROLL;

  03591	b8 06 00 00 00	 mov	 eax, 6
  03596	eb 59		 jmp	 SHORT $L23109
$L23117:

; 1643 : 	}
; 1644 : 	//Clicked in the vertical scrollbar area
; 1645 : 	else if(sw->sbarVert.fScrollVisible && PtInRect(&vrect, pt))

  03598	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0359b	83 ba 58 03 00
	00 00		 cmp	 DWORD PTR [edx+856], 0
  035a2	74 26		 je	 SHORT $L23119
  035a4	8b f4		 mov	 esi, esp
  035a6	8b 45 c8	 mov	 eax, DWORD PTR _pt$[ebp+4]
  035a9	50		 push	 eax
  035aa	8b 4d c4	 mov	 ecx, DWORD PTR _pt$[ebp]
  035ad	51		 push	 ecx
  035ae	8d 55 d4	 lea	 edx, DWORD PTR _vrect$[ebp]
  035b1	52		 push	 edx
  035b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  035b8	3b f4		 cmp	 esi, esp
  035ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  035bf	85 c0		 test	 eax, eax
  035c1	74 07		 je	 SHORT $L23119

; 1646 : 	{
; 1647 : 		return HTVSCROLL;

  035c3	b8 07 00 00 00	 mov	 eax, 7
  035c8	eb 27		 jmp	 SHORT $L23109
$L23119:

; 1648 : 	}
; 1649 : 	//clicked somewhere else
; 1650 : 	else
; 1651 : 	{
; 1652 : 		return CallWindowProc(sw->oldproc, hwnd, WM_NCHITTEST, wParam, lParam);

  035ca	8b f4		 mov	 esi, esp
  035cc	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  035cf	50		 push	 eax
  035d0	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  035d3	51		 push	 ecx
  035d4	68 84 00 00 00	 push	 132			; 00000084H
  035d9	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  035dc	52		 push	 edx
  035dd	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  035e0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  035e3	51		 push	 ecx
  035e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  035ea	3b f4		 cmp	 esi, esp
  035ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23109:

; 1653 : 	}
; 1654 : }

  035f1	52		 push	 edx
  035f2	8b cd		 mov	 ecx, ebp
  035f4	50		 push	 eax
  035f5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23977
  035fb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  03600	58		 pop	 eax
  03601	5a		 pop	 edx
  03602	5f		 pop	 edi
  03603	5e		 pop	 esi
  03604	83 c4 40	 add	 esp, 64			; 00000040H
  03607	3b ec		 cmp	 ebp, esp
  03609	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0360e	8b e5		 mov	 esp, ebp
  03610	5d		 pop	 ebp
  03611	c3		 ret	 0
$L23977:
  03612	03 00 00 00	 DD	 3
  03616	00 00 00 00	 DD	 $L23976
$L23976:
  0361a	ec ff ff ff	 DD	 -20			; ffffffecH
  0361e	10 00 00 00	 DD	 16			; 00000010H
  03622	00 00 00 00	 DD	 $L23973
  03626	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0362a	10 00 00 00	 DD	 16			; 00000010H
  0362e	00 00 00 00	 DD	 $L23974
  03632	c4 ff ff ff	 DD	 -60			; ffffffc4H
  03636	08 00 00 00	 DD	 8
  0363a	00 00 00 00	 DD	 $L23975
$L23975:
  0363e	70		 DB	 112			; 00000070H
  0363f	74		 DB	 116			; 00000074H
  03640	00		 DB	 0
$L23974:
  03641	76		 DB	 118			; 00000076H
  03642	72		 DB	 114			; 00000072H
  03643	65		 DB	 101			; 00000065H
  03644	63		 DB	 99			; 00000063H
  03645	74		 DB	 116			; 00000074H
  03646	00		 DB	 0
$L23973:
  03647	68		 DB	 104			; 00000068H
  03648	72		 DB	 114			; 00000072H
  03649	65		 DB	 101			; 00000065H
  0364a	63		 DB	 99			; 00000063H
  0364b	74		 DB	 116			; 00000074H
  0364c	00		 DB	 0
_NCHitTest ENDP
_TEXT	ENDS
EXTRN	__imp__SetCapture@4:NEAR
EXTRN	__imp__SetTimer@16:NEAR
EXTRN	__imp__KillTimer@8:NEAR
_BSS	SEGMENT
_rcThumbBounds DB 010H DUP (?)
_nThumbSize DD	01H DUP (?)
_nThumbPos DD	01H DUP (?)
_nThumbMouseOffset DD 01H DUP (?)
_nThumbPos0 DD	01H DUP (?)
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
_TEXT	SEGMENT
tv143 = -80						; size = 4
_pt$ = -72						; size = 8
_sbut$ = -60						; size = 4
_sb$ = -56						; size = 4
_hdc$ = -52						; size = 4
_winrect$ = -44						; size = 16
_rect$ = -20						; size = 16
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCLButtonDown PROC NEAR

; 1928 : {

  03650	55		 push	 ebp
  03651	8b ec		 mov	 ebp, esp
  03653	83 ec 50	 sub	 esp, 80			; 00000050H
  03656	56		 push	 esi
  03657	57		 push	 edi
  03658	8d 7d b0	 lea	 edi, DWORD PTR [ebp-80]
  0365b	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  03660	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  03665	f3 ab		 rep stosd

; 1929 : 	RECT rect, winrect;
; 1930 : 	HDC hdc;
; 1931 : 	SCROLLBAR *sb;
; 1932 : 	SCROLLBUT *sbut = 0;

  03667	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _sbut$[ebp], 0

; 1933 : 	POINT pt;
; 1934 : 
; 1935 : 	pt.x = LOWORD(lParam);

  0366e	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  03671	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  03676	0f b7 c8	 movzx	 ecx, ax
  03679	89 4d b8	 mov	 DWORD PTR _pt$[ebp], ecx

; 1936 : 	pt.y = HIWORD(lParam);

  0367c	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0367f	c1 ea 10	 shr	 edx, 16			; 00000010H
  03682	0f b7 c2	 movzx	 eax, dx
  03685	89 45 bc	 mov	 DWORD PTR _pt$[ebp+4], eax

; 1937 : 
; 1938 : 	hwndCurCoolSB = hwnd;

  03688	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0368b	89 0d 00 00 00
	00		 mov	 DWORD PTR _hwndCurCoolSB, ecx

; 1939 : 
; 1940 : 	//
; 1941 : 	//	HORIZONTAL SCROLLBAR PROCESSING
; 1942 : 	//
; 1943 : 	if(wParam == HTHSCROLL)

  03691	83 7d 10 06	 cmp	 DWORD PTR _wParam$[ebp], 6
  03695	75 66		 jne	 SHORT $L23305

; 1944 : 	{
; 1945 : 		uScrollTimerMsg = WM_HSCROLL;

  03697	c7 05 00 00 00
	00 14 01 00 00	 mov	 DWORD PTR _uScrollTimerMsg, 276 ; 00000114H

; 1946 : 		uCurrentScrollbar = SB_HORZ;

  036a1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uCurrentScrollbar, 0

; 1947 : 		sb = &sw->sbarHorz;

  036ab	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  036ae	83 c2 08	 add	 edx, 8
  036b1	89 55 c8	 mov	 DWORD PTR _sb$[ebp], edx

; 1948 : 
; 1949 : 		//get the total area of the normal Horz scrollbar area
; 1950 : 		GetHScrollRect(sw, hwnd, &rect);

  036b4	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  036b7	50		 push	 eax
  036b8	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  036bb	51		 push	 ecx
  036bc	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  036bf	52		 push	 edx
  036c0	e8 00 00 00 00	 call	 _GetHScrollRect
  036c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1951 : 		uCurrentScrollPortion = GetHorzPortion(sb, hwnd, &rect, LOWORD(lParam), HIWORD(lParam));

  036c8	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  036cb	c1 e8 10	 shr	 eax, 16			; 00000010H
  036ce	0f b7 c8	 movzx	 ecx, ax
  036d1	51		 push	 ecx
  036d2	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  036d5	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  036db	0f b7 c2	 movzx	 eax, dx
  036de	50		 push	 eax
  036df	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  036e2	51		 push	 ecx
  036e3	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  036e6	52		 push	 edx
  036e7	8b 45 c8	 mov	 eax, DWORD PTR _sb$[ebp]
  036ea	50		 push	 eax
  036eb	e8 00 00 00 00	 call	 _GetHorzPortion
  036f0	83 c4 14	 add	 esp, 20			; 00000014H
  036f3	a3 00 00 00 00	 mov	 DWORD PTR _uCurrentScrollPortion, eax

; 1952 : 	}
; 1953 : 	//
; 1954 : 	//	VERTICAL SCROLLBAR PROCESSING
; 1955 : 	//
; 1956 : 	else if(wParam == HTVSCROLL)

  036f8	e9 a2 00 00 00	 jmp	 $L23310
$L23305:
  036fd	83 7d 10 07	 cmp	 DWORD PTR _wParam$[ebp], 7
  03701	75 66		 jne	 SHORT $L23311

; 1957 : 	{
; 1958 : 		uScrollTimerMsg = WM_VSCROLL;

  03703	c7 05 00 00 00
	00 15 01 00 00	 mov	 DWORD PTR _uScrollTimerMsg, 277 ; 00000115H

; 1959 : 		uCurrentScrollbar = SB_VERT;

  0370d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _uCurrentScrollbar, 1

; 1960 : 		sb = &sw->sbarVert;

  03717	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0371a	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  03720	89 4d c8	 mov	 DWORD PTR _sb$[ebp], ecx

; 1961 : 
; 1962 : 		//get the total area of the normal Horz scrollbar area
; 1963 : 		GetVScrollRect(sw, hwnd, &rect);

  03723	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  03726	52		 push	 edx
  03727	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0372a	50		 push	 eax
  0372b	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0372e	51		 push	 ecx
  0372f	e8 00 00 00 00	 call	 _GetVScrollRect
  03734	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1964 : 		uCurrentScrollPortion = GetVertPortion(sb, hwnd, &rect, LOWORD(lParam), HIWORD(lParam));

  03737	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0373a	c1 ea 10	 shr	 edx, 16			; 00000010H
  0373d	0f b7 c2	 movzx	 eax, dx
  03740	50		 push	 eax
  03741	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  03744	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0374a	0f b7 d1	 movzx	 edx, cx
  0374d	52		 push	 edx
  0374e	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  03751	50		 push	 eax
  03752	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03755	51		 push	 ecx
  03756	8b 55 c8	 mov	 edx, DWORD PTR _sb$[ebp]
  03759	52		 push	 edx
  0375a	e8 00 00 00 00	 call	 _GetVertPortion
  0375f	83 c4 14	 add	 esp, 20			; 00000014H
  03762	a3 00 00 00 00	 mov	 DWORD PTR _uCurrentScrollPortion, eax

; 1965 : 	}
; 1966 : 	//
; 1967 : 	//	NORMAL PROCESSING
; 1968 : 	//
; 1969 : 	else

  03767	eb 36		 jmp	 SHORT $L23310
$L23311:

; 1970 : 	{
; 1971 : 		uCurrentScrollPortion = HTSCROLL_NONE;

  03769	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uCurrentScrollPortion, -1

; 1972 : 		return CallWindowProc(sw->oldproc, hwnd, WM_NCLBUTTONDOWN, wParam, lParam);

  03773	8b f4		 mov	 esi, esp
  03775	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  03778	50		 push	 eax
  03779	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0377c	51		 push	 ecx
  0377d	68 a1 00 00 00	 push	 161			; 000000a1H
  03782	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03785	52		 push	 edx
  03786	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  03789	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0378c	51		 push	 ecx
  0378d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  03793	3b f4		 cmp	 esi, esp
  03795	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0379a	e9 27 04 00 00	 jmp	 $L23294
$L23310:

; 1973 : 	}
; 1974 : 
; 1975 : 	//
; 1976 : 	// we can now share the same code for vertical
; 1977 : 	// and horizontal scrollbars
; 1978 : 	//
; 1979 : 	switch(uCurrentScrollPortion)

  0379f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentScrollPortion
  037a5	89 55 b0	 mov	 DWORD PTR tv143[ebp], edx
  037a8	81 7d b0 80 00
	00 00		 cmp	 DWORD PTR tv143[ebp], 128 ; 00000080H
  037af	0f 87 d3 03 00
	00		 ja	 $L23337
  037b5	8b 45 b0	 mov	 eax, DWORD PTR tv143[ebp]
  037b8	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L23979[eax]
  037bf	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L23985[ecx*4]
$L23321:

; 1980 : 	{
; 1981 : 	//inserted buttons to the left/right
; 1982 : #ifdef INCLUDE_BUTTONS
; 1983 : 	case HTSCROLL_INSERTED:  
; 1984 : 
; 1985 : #ifdef HOT_TRACKING
; 1986 : 		KillTimer(hwnd, uMouseOverId);

  037c6	8b f4		 mov	 esi, esp
  037c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uMouseOverId
  037ce	52		 push	 edx
  037cf	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  037d2	50		 push	 eax
  037d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8
  037d9	3b f4		 cmp	 esi, esp
  037db	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1987 : 		uMouseOverId = 0;

  037e0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uMouseOverId, 0

; 1988 : 		uMouseOverScrollbar = COOLSB_NONE;

  037ea	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uMouseOverScrollbar, -1

; 1989 : #endif
; 1990 : 
; 1991 : 		//find the index of the button that has been clicked
; 1992 : 		//adjust the rectangle to give the button's rectangle
; 1993 : 		uCurrentButton = GetButtonFromPt(sb, &rect, pt, TRUE);

  037f4	6a 01		 push	 1
  037f6	8b 4d bc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  037f9	51		 push	 ecx
  037fa	8b 55 b8	 mov	 edx, DWORD PTR _pt$[ebp]
  037fd	52		 push	 edx
  037fe	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  03801	50		 push	 eax
  03802	8b 4d c8	 mov	 ecx, DWORD PTR _sb$[ebp]
  03805	51		 push	 ecx
  03806	e8 00 00 00 00	 call	 _GetButtonFromPt
  0380b	83 c4 14	 add	 esp, 20			; 00000014H
  0380e	a3 00 00 00 00	 mov	 DWORD PTR _uCurrentButton, eax

; 1994 : 
; 1995 : 		sbut = &sb->sbButtons[uCurrentButton];

  03813	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  03819	6b d2 30	 imul	 edx, 48			; 00000030H
  0381c	8b 45 c8	 mov	 eax, DWORD PTR _sb$[ebp]
  0381f	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  03823	89 4d c4	 mov	 DWORD PTR _sbut$[ebp], ecx

; 1996 : 		
; 1997 : 		//post a notification message
; 1998 : 		PostMouseNotify(hwnd, NM_CLICK, sb->nBarType, &rect, sbut->uCmdId, pt);

  03826	8b 55 bc	 mov	 edx, DWORD PTR _pt$[ebp+4]
  03829	52		 push	 edx
  0382a	8b 45 b8	 mov	 eax, DWORD PTR _pt$[ebp]
  0382d	50		 push	 eax
  0382e	8b 4d c4	 mov	 ecx, DWORD PTR _sbut$[ebp]
  03831	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  03834	52		 push	 edx
  03835	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  03838	50		 push	 eax
  03839	8b 4d c8	 mov	 ecx, DWORD PTR _sb$[ebp]
  0383c	8b 91 40 03 00
	00		 mov	 edx, DWORD PTR [ecx+832]
  03842	52		 push	 edx
  03843	6a fe		 push	 -2			; fffffffeH
  03845	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03848	50		 push	 eax
  03849	e8 00 00 00 00	 call	 _PostMouseNotify0
  0384e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1999 : 
; 2000 : 		GetWindowRect(hwnd, &winrect);

  03851	8b f4		 mov	 esi, esp
  03853	8d 4d d4	 lea	 ecx, DWORD PTR _winrect$[ebp]
  03856	51		 push	 ecx
  03857	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0385a	52		 push	 edx
  0385b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  03861	3b f4		 cmp	 esi, esp
  03863	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2001 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  03868	8b 45 d8	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  0386b	f7 d8		 neg	 eax
  0386d	8b f4		 mov	 esi, esp
  0386f	50		 push	 eax
  03870	8b 4d d4	 mov	 ecx, DWORD PTR _winrect$[ebp]
  03873	f7 d9		 neg	 ecx
  03875	51		 push	 ecx
  03876	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  03879	52		 push	 edx
  0387a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  03880	3b f4		 cmp	 esi, esp
  03882	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2002 : 		hdc = GetWindowDC(hwnd);

  03887	8b f4		 mov	 esi, esp
  03889	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0388c	50		 push	 eax
  0388d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  03893	3b f4		 cmp	 esi, esp
  03895	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0389a	89 45 cc	 mov	 DWORD PTR _hdc$[ebp], eax

; 2003 : 			
; 2004 : 		DrawScrollButton(sbut, hdc, &rect, SBBS_PUSHED);

  0389d	6a 01		 push	 1
  0389f	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  038a2	51		 push	 ecx
  038a3	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  038a6	52		 push	 edx
  038a7	8b 45 c4	 mov	 eax, DWORD PTR _sbut$[ebp]
  038aa	50		 push	 eax
  038ab	e8 00 00 00 00	 call	 _DrawScrollButton
  038b0	83 c4 10	 add	 esp, 16			; 00000010H

; 2005 : 
; 2006 : 		ReleaseDC(hwnd, hdc);

  038b3	8b f4		 mov	 esi, esp
  038b5	8b 4d cc	 mov	 ecx, DWORD PTR _hdc$[ebp]
  038b8	51		 push	 ecx
  038b9	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  038bc	52		 push	 edx
  038bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  038c3	3b f4		 cmp	 esi, esp
  038c5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2007 : 	
; 2008 : 		break;

  038ca	e9 e2 02 00 00	 jmp	 $L23318
$L23322:

; 2009 : #endif	//INCLUDE_BUTTONS
; 2010 : 
; 2011 : 	case HTSCROLL_THUMB: 
; 2012 : 
; 2013 : 		//if the scrollbar is disabled, then do no further processing
; 2014 : 		if(!IsScrollbarActive(sb))

  038cf	8b 45 c8	 mov	 eax, DWORD PTR _sb$[ebp]
  038d2	50		 push	 eax
  038d3	e8 00 00 00 00	 call	 _IsScrollbarActive
  038d8	83 c4 04	 add	 esp, 4
  038db	85 c0		 test	 eax, eax
  038dd	75 07		 jne	 SHORT $L23323

; 2015 : 			return 0;

  038df	33 c0		 xor	 eax, eax
  038e1	e9 e0 02 00 00	 jmp	 $L23294
$L23323:

; 2016 : 		
; 2017 : 		GetRealScrollRect(sb, &rect);

  038e6	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  038e9	51		 push	 ecx
  038ea	8b 55 c8	 mov	 edx, DWORD PTR _sb$[ebp]
  038ed	52		 push	 edx
  038ee	e8 00 00 00 00	 call	 _GetRealScrollRect
  038f3	83 c4 08	 add	 esp, 8

; 2018 : 		RotateRect0(sb, &rect);

  038f6	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  038f9	50		 push	 eax
  038fa	8b 4d c8	 mov	 ecx, DWORD PTR _sb$[ebp]
  038fd	51		 push	 ecx
  038fe	e8 00 00 00 00	 call	 _RotateRect0@8

; 2019 : 		CalcThumbSize(sb, &rect, &nThumbSize, &nThumbPos);

  03903	68 00 00 00 00	 push	 OFFSET FLAT:_nThumbPos
  03908	68 00 00 00 00	 push	 OFFSET FLAT:_nThumbSize
  0390d	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  03910	52		 push	 edx
  03911	8b 45 c8	 mov	 eax, DWORD PTR _sb$[ebp]
  03914	50		 push	 eax
  03915	e8 00 00 00 00	 call	 _CalcThumbSize
  0391a	83 c4 10	 add	 esp, 16			; 00000010H

; 2020 : 		RotateRect0(sb, &rect);

  0391d	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  03920	51		 push	 ecx
  03921	8b 55 c8	 mov	 edx, DWORD PTR _sb$[ebp]
  03924	52		 push	 edx
  03925	e8 00 00 00 00	 call	 _RotateRect0@8

; 2021 : 		
; 2022 : 		//remember the bounding rectangle of the scrollbar work area
; 2023 : 		rcThumbBounds = rect;

  0392a	8b 45 ec	 mov	 eax, DWORD PTR _rect$[ebp]
  0392d	a3 00 00 00 00	 mov	 DWORD PTR _rcThumbBounds, eax
  03932	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  03935	89 0d 04 00 00
	00		 mov	 DWORD PTR _rcThumbBounds+4, ecx
  0393b	8b 55 f4	 mov	 edx, DWORD PTR _rect$[ebp+8]
  0393e	89 15 08 00 00
	00		 mov	 DWORD PTR _rcThumbBounds+8, edx
  03944	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp+12]
  03947	a3 0c 00 00 00	 mov	 DWORD PTR _rcThumbBounds+12, eax

; 2024 : 		
; 2025 : 		sw->fThumbTracking = TRUE;

  0394c	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0394f	c7 81 a0 06 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+1696], 1

; 2026 : 		sb->scrollInfo.nTrackPos = sb->scrollInfo.nPos;

  03959	8b 55 c8	 mov	 edx, DWORD PTR _sb$[ebp]
  0395c	8b 45 c8	 mov	 eax, DWORD PTR _sb$[ebp]
  0395f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  03962	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 2027 : 		
; 2028 : 		if(wParam == HTVSCROLL) 

  03965	83 7d 10 07	 cmp	 DWORD PTR _wParam$[ebp], 7
  03969	75 11		 jne	 SHORT $L23324

; 2029 : 			nThumbMouseOffset = pt.y - nThumbPos;

  0396b	8b 55 bc	 mov	 edx, DWORD PTR _pt$[ebp+4]
  0396e	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _nThumbPos
  03974	89 15 00 00 00
	00		 mov	 DWORD PTR _nThumbMouseOffset, edx

; 2030 : 		else

  0397a	eb 0e		 jmp	 SHORT $L23325
$L23324:

; 2031 : 			nThumbMouseOffset = pt.x - nThumbPos;

  0397c	8b 45 b8	 mov	 eax, DWORD PTR _pt$[ebp]
  0397f	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _nThumbPos
  03985	a3 00 00 00 00	 mov	 DWORD PTR _nThumbMouseOffset, eax
$L23325:

; 2032 : 
; 2033 : 		nLastPos = -sb->scrollInfo.nPos;

  0398a	8b 4d c8	 mov	 ecx, DWORD PTR _sb$[ebp]
  0398d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  03990	f7 da		 neg	 edx
  03992	89 15 00 00 00
	00		 mov	 DWORD PTR _nLastPos, edx

; 2034 : 		nThumbPos0 = nThumbPos;

  03998	a1 00 00 00 00	 mov	 eax, DWORD PTR _nThumbPos
  0399d	a3 00 00 00 00	 mov	 DWORD PTR _nThumbPos0, eax

; 2035 : 	
; 2036 : 		//if(sb->fFlatScrollbar)
; 2037 : 		//{
; 2038 : 			GetWindowRect(hwnd, &winrect);

  039a2	8b f4		 mov	 esi, esp
  039a4	8d 4d d4	 lea	 ecx, DWORD PTR _winrect$[ebp]
  039a7	51		 push	 ecx
  039a8	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  039ab	52		 push	 edx
  039ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  039b2	3b f4		 cmp	 esi, esp
  039b4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2039 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  039b9	8b 45 d8	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  039bc	f7 d8		 neg	 eax
  039be	8b f4		 mov	 esi, esp
  039c0	50		 push	 eax
  039c1	8b 4d d4	 mov	 ecx, DWORD PTR _winrect$[ebp]
  039c4	f7 d9		 neg	 ecx
  039c6	51		 push	 ecx
  039c7	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  039ca	52		 push	 edx
  039cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  039d1	3b f4		 cmp	 esi, esp
  039d3	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2040 : 			hdc = GetWindowDC(hwnd);

  039d8	8b f4		 mov	 esi, esp
  039da	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  039dd	50		 push	 eax
  039de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  039e4	3b f4		 cmp	 esi, esp
  039e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  039eb	89 45 cc	 mov	 DWORD PTR _hdc$[ebp], eax

; 2041 : 			NCDrawScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_THUMB);

  039ee	6a 05		 push	 5
  039f0	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  039f3	51		 push	 ecx
  039f4	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  039f7	52		 push	 edx
  039f8	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  039fb	50		 push	 eax
  039fc	8b 4d c8	 mov	 ecx, DWORD PTR _sb$[ebp]
  039ff	51		 push	 ecx
  03a00	e8 00 00 00 00	 call	 _NCDrawScrollbar
  03a05	83 c4 14	 add	 esp, 20			; 00000014H

; 2042 : 			ReleaseDC(hwnd, hdc);

  03a08	8b f4		 mov	 esi, esp
  03a0a	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  03a0d	52		 push	 edx
  03a0e	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03a11	50		 push	 eax
  03a12	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  03a18	3b f4		 cmp	 esi, esp
  03a1a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2043 : 		//}
; 2044 : 
; 2045 : 		break;

  03a1f	e9 8d 01 00 00	 jmp	 $L23318
$L23326:

; 2046 : 
; 2047 : 		//Any part of the scrollbar
; 2048 : 	case HTSCROLL_LEFT:  
; 2049 : 		if(sb->fScrollFlags & ESB_DISABLE_LEFT)		return 0;

  03a24	8b 4d c8	 mov	 ecx, DWORD PTR _sb$[ebp]
  03a27	8b 11		 mov	 edx, DWORD PTR [ecx]
  03a29	83 e2 01	 and	 edx, 1
  03a2c	74 07		 je	 SHORT $L23327
  03a2e	33 c0		 xor	 eax, eax
  03a30	e9 91 01 00 00	 jmp	 $L23294
$L23327:

; 2050 : 		else										goto target1;

  03a35	eb 11		 jmp	 SHORT $target1$23329
$L23330:

; 2051 : 	
; 2052 : 	case HTSCROLL_RIGHT: 
; 2053 : 		if(sb->fScrollFlags & ESB_DISABLE_RIGHT)	return 0;

  03a37	8b 45 c8	 mov	 eax, DWORD PTR _sb$[ebp]
  03a3a	8b 08		 mov	 ecx, DWORD PTR [eax]
  03a3c	83 e1 02	 and	 ecx, 2
  03a3f	74 07		 je	 SHORT $target1$23329
  03a41	33 c0		 xor	 eax, eax
  03a43	e9 7e 01 00 00	 jmp	 $L23294
$target1$23329:

; 2054 : 		else										goto target1;
; 2055 : 
; 2056 : 		goto target1;	
; 2057 : 
; 2058 : 	case HTSCROLL_PAGELEFT:  case HTSCROLL_PAGERIGHT:
; 2059 : 
; 2060 : 		target1:
; 2061 : 
; 2062 : 		//if the scrollbar is disabled, then do no further processing
; 2063 : 		if(!IsScrollbarActive(sb))

  03a48	8b 55 c8	 mov	 edx, DWORD PTR _sb$[ebp]
  03a4b	52		 push	 edx
  03a4c	e8 00 00 00 00	 call	 _IsScrollbarActive
  03a51	83 c4 04	 add	 esp, 4
  03a54	85 c0		 test	 eax, eax
  03a56	75 05		 jne	 SHORT $L23334

; 2064 : 			break;

  03a58	e9 54 01 00 00	 jmp	 $L23318
$L23334:

; 2065 : 
; 2066 : 		//ajust the horizontal rectangle to NOT include
; 2067 : 		//any inserted buttons
; 2068 : 		GetRealScrollRect(sb, &rect);

  03a5d	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  03a60	50		 push	 eax
  03a61	8b 4d c8	 mov	 ecx, DWORD PTR _sb$[ebp]
  03a64	51		 push	 ecx
  03a65	e8 00 00 00 00	 call	 _GetRealScrollRect
  03a6a	83 c4 08	 add	 esp, 8

; 2069 : 
; 2070 : 		SendScrollMessage(hwnd, uScrollTimerMsg, uCurrentScrollPortion, 0);

  03a6d	6a 00		 push	 0
  03a6f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentScrollPortion
  03a75	52		 push	 edx
  03a76	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerMsg
  03a7b	50		 push	 eax
  03a7c	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03a7f	51		 push	 ecx
  03a80	e8 00 00 00 00	 call	 _SendScrollMessage
  03a85	83 c4 10	 add	 esp, 16			; 00000010H

; 2071 : 
; 2072 : 		// Check what area the mouse is now over :
; 2073 : 		// If the scroll thumb has moved under the mouse in response to 
; 2074 : 		// a call to SetScrollPos etc, then we don't hilight the scrollbar margin
; 2075 : 		if(uCurrentScrollbar == SB_HORZ)

  03a88	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  03a8f	75 23		 jne	 SHORT $L23335

; 2076 : 			uScrollTimerPortion = GetHorzScrollPortion(sb, hwnd, &rect, pt.x, pt.y);

  03a91	8b 55 bc	 mov	 edx, DWORD PTR _pt$[ebp+4]
  03a94	52		 push	 edx
  03a95	8b 45 b8	 mov	 eax, DWORD PTR _pt$[ebp]
  03a98	50		 push	 eax
  03a99	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  03a9c	51		 push	 ecx
  03a9d	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03aa0	52		 push	 edx
  03aa1	8b 45 c8	 mov	 eax, DWORD PTR _sb$[ebp]
  03aa4	50		 push	 eax
  03aa5	e8 00 00 00 00	 call	 _GetHorzScrollPortion
  03aaa	83 c4 14	 add	 esp, 20			; 00000014H
  03aad	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerPortion, eax

; 2077 : 		else

  03ab2	eb 21		 jmp	 SHORT $L23336
$L23335:

; 2078 : 			uScrollTimerPortion = GetVertScrollPortion(sb, hwnd, &rect, pt.x, pt.y);

  03ab4	8b 4d bc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  03ab7	51		 push	 ecx
  03ab8	8b 55 b8	 mov	 edx, DWORD PTR _pt$[ebp]
  03abb	52		 push	 edx
  03abc	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  03abf	50		 push	 eax
  03ac0	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03ac3	51		 push	 ecx
  03ac4	8b 55 c8	 mov	 edx, DWORD PTR _sb$[ebp]
  03ac7	52		 push	 edx
  03ac8	e8 00 00 00 00	 call	 _GetVertScrollPortion
  03acd	83 c4 14	 add	 esp, 20			; 00000014H
  03ad0	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerPortion, eax
$L23336:

; 2079 : 
; 2080 : 		GetWindowRect(hwnd, &winrect);

  03ad5	8b f4		 mov	 esi, esp
  03ad7	8d 45 d4	 lea	 eax, DWORD PTR _winrect$[ebp]
  03ada	50		 push	 eax
  03adb	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03ade	51		 push	 ecx
  03adf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  03ae5	3b f4		 cmp	 esi, esp
  03ae7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2081 : 		OffsetRect(&rect, -winrect.left, -winrect.top);

  03aec	8b 55 d8	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  03aef	f7 da		 neg	 edx
  03af1	8b f4		 mov	 esi, esp
  03af3	52		 push	 edx
  03af4	8b 45 d4	 mov	 eax, DWORD PTR _winrect$[ebp]
  03af7	f7 d8		 neg	 eax
  03af9	50		 push	 eax
  03afa	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  03afd	51		 push	 ecx
  03afe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  03b04	3b f4		 cmp	 esi, esp
  03b06	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2082 : 		hdc = GetWindowDC(hwnd);

  03b0b	8b f4		 mov	 esi, esp
  03b0d	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03b10	52		 push	 edx
  03b11	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  03b17	3b f4		 cmp	 esi, esp
  03b19	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03b1e	89 45 cc	 mov	 DWORD PTR _hdc$[ebp], eax

; 2083 : 			
; 2084 : #ifndef HOT_TRACKING
; 2085 : 		//if we aren't hot-tracking, then don't highlight 
; 2086 : 		//the scrollbar thumb unless we click on it
; 2087 : 		if(uScrollTimerPortion == HTSCROLL_THUMB)
; 2088 : 			uScrollTimerPortion = HTSCROLL_NONE;
; 2089 : #endif
; 2090 : 		NCDrawScrollbar(sb, hwnd, hdc, &rect, uScrollTimerPortion);

  03b21	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerPortion
  03b26	50		 push	 eax
  03b27	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  03b2a	51		 push	 ecx
  03b2b	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  03b2e	52		 push	 edx
  03b2f	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03b32	50		 push	 eax
  03b33	8b 4d c8	 mov	 ecx, DWORD PTR _sb$[ebp]
  03b36	51		 push	 ecx
  03b37	e8 00 00 00 00	 call	 _NCDrawScrollbar
  03b3c	83 c4 14	 add	 esp, 20			; 00000014H

; 2091 : 		ReleaseDC(hwnd, hdc);

  03b3f	8b f4		 mov	 esi, esp
  03b41	8b 55 cc	 mov	 edx, DWORD PTR _hdc$[ebp]
  03b44	52		 push	 edx
  03b45	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03b48	50		 push	 eax
  03b49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  03b4f	3b f4		 cmp	 esi, esp
  03b51	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2092 : 
; 2093 : 		//Post the scroll message!!!!
; 2094 : 		uScrollTimerPortion = uCurrentScrollPortion;

  03b56	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uCurrentScrollPortion
  03b5c	89 0d 00 00 00
	00		 mov	 DWORD PTR _uScrollTimerPortion, ecx

; 2095 : 
; 2096 : 		//set a timer going on the first click.
; 2097 : 		//if this one expires, then we can start off a more regular timer
; 2098 : 		//to generate the auto-scroll behaviour
; 2099 : #pragma warning( disable: 4244)
; 2100 : 		uScrollTimerId = SetTimer(hwnd, COOLSB_TIMERID1, COOLSB_TIMERINTERVAL1, 0);

  03b62	8b f4		 mov	 esi, esp
  03b64	6a 00		 push	 0
  03b66	68 2c 01 00 00	 push	 300			; 0000012cH
  03b6b	68 fd ff 00 00	 push	 65533			; 0000fffdH
  03b70	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03b73	52		 push	 edx
  03b74	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  03b7a	3b f4		 cmp	 esi, esp
  03b7c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03b81	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerId, eax

; 2101 : #pragma warning( default: 4244)
; 2102 : 		break;

  03b86	eb 29		 jmp	 SHORT $L23318
$L23337:

; 2103 : 	default:
; 2104 : 		return CallWindowProc(sw->oldproc, hwnd, WM_NCLBUTTONDOWN, wParam, lParam);

  03b88	8b f4		 mov	 esi, esp
  03b8a	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  03b8d	50		 push	 eax
  03b8e	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  03b91	51		 push	 ecx
  03b92	68 a1 00 00 00	 push	 161			; 000000a1H
  03b97	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03b9a	52		 push	 edx
  03b9b	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  03b9e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  03ba1	51		 push	 ecx
  03ba2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  03ba8	3b f4		 cmp	 esi, esp
  03baa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03baf	eb 15		 jmp	 SHORT $L23294
$L23318:

; 2105 : 		//return 0;
; 2106 : 	}
; 2107 : 		
; 2108 : 	SetCapture(hwnd);

  03bb1	8b f4		 mov	 esi, esp
  03bb3	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03bb6	52		 push	 edx
  03bb7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCapture@4
  03bbd	3b f4		 cmp	 esi, esp
  03bbf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2109 : 	return 0;

  03bc4	33 c0		 xor	 eax, eax
$L23294:

; 2110 : }

  03bc6	52		 push	 edx
  03bc7	8b cd		 mov	 ecx, ebp
  03bc9	50		 push	 eax
  03bca	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23984
  03bd0	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  03bd5	58		 pop	 eax
  03bd6	5a		 pop	 edx
  03bd7	5f		 pop	 edi
  03bd8	5e		 pop	 esi
  03bd9	83 c4 50	 add	 esp, 80			; 00000050H
  03bdc	3b ec		 cmp	 ebp, esp
  03bde	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03be3	8b e5		 mov	 esp, ebp
  03be5	5d		 pop	 ebp
  03be6	c3		 ret	 0
$L23984:
  03be7	03 00 00 00	 DD	 3
  03beb	00 00 00 00	 DD	 $L23983
$L23983:
  03bef	ec ff ff ff	 DD	 -20			; ffffffecH
  03bf3	10 00 00 00	 DD	 16			; 00000010H
  03bf7	00 00 00 00	 DD	 $L23980
  03bfb	d4 ff ff ff	 DD	 -44			; ffffffd4H
  03bff	10 00 00 00	 DD	 16			; 00000010H
  03c03	00 00 00 00	 DD	 $L23981
  03c07	b8 ff ff ff	 DD	 -72			; ffffffb8H
  03c0b	08 00 00 00	 DD	 8
  03c0f	00 00 00 00	 DD	 $L23982
$L23982:
  03c13	70		 DB	 112			; 00000070H
  03c14	74		 DB	 116			; 00000074H
  03c15	00		 DB	 0
$L23981:
  03c16	77		 DB	 119			; 00000077H
  03c17	69		 DB	 105			; 00000069H
  03c18	6e		 DB	 110			; 0000006eH
  03c19	72		 DB	 114			; 00000072H
  03c1a	65		 DB	 101			; 00000065H
  03c1b	63		 DB	 99			; 00000063H
  03c1c	74		 DB	 116			; 00000074H
  03c1d	00		 DB	 0
$L23980:
  03c1e	72		 DB	 114			; 00000072H
  03c1f	65		 DB	 101			; 00000065H
  03c20	63		 DB	 99			; 00000063H
  03c21	74		 DB	 116			; 00000074H
  03c22	00		 DB	 0
$L23985:
  03c23	00 00 00 00	 DD	 $L23326
  03c27	00 00 00 00	 DD	 $L23330
  03c2b	00 00 00 00	 DD	 $target1$23329
  03c2f	00 00 00 00	 DD	 $L23322
  03c33	00 00 00 00	 DD	 $L23321
  03c37	00 00 00 00	 DD	 $L23337
$L23979:
  03c3b	00		 DB	 0
  03c3c	01		 DB	 1
  03c3d	02		 DB	 2
  03c3e	02		 DB	 2
  03c3f	05		 DB	 5
  03c40	03		 DB	 3
  03c41	05		 DB	 5
  03c42	05		 DB	 5
  03c43	05		 DB	 5
  03c44	05		 DB	 5
  03c45	05		 DB	 5
  03c46	05		 DB	 5
  03c47	05		 DB	 5
  03c48	05		 DB	 5
  03c49	05		 DB	 5
  03c4a	05		 DB	 5
  03c4b	05		 DB	 5
  03c4c	05		 DB	 5
  03c4d	05		 DB	 5
  03c4e	05		 DB	 5
  03c4f	05		 DB	 5
  03c50	05		 DB	 5
  03c51	05		 DB	 5
  03c52	05		 DB	 5
  03c53	05		 DB	 5
  03c54	05		 DB	 5
  03c55	05		 DB	 5
  03c56	05		 DB	 5
  03c57	05		 DB	 5
  03c58	05		 DB	 5
  03c59	05		 DB	 5
  03c5a	05		 DB	 5
  03c5b	05		 DB	 5
  03c5c	05		 DB	 5
  03c5d	05		 DB	 5
  03c5e	05		 DB	 5
  03c5f	05		 DB	 5
  03c60	05		 DB	 5
  03c61	05		 DB	 5
  03c62	05		 DB	 5
  03c63	05		 DB	 5
  03c64	05		 DB	 5
  03c65	05		 DB	 5
  03c66	05		 DB	 5
  03c67	05		 DB	 5
  03c68	05		 DB	 5
  03c69	05		 DB	 5
  03c6a	05		 DB	 5
  03c6b	05		 DB	 5
  03c6c	05		 DB	 5
  03c6d	05		 DB	 5
  03c6e	05		 DB	 5
  03c6f	05		 DB	 5
  03c70	05		 DB	 5
  03c71	05		 DB	 5
  03c72	05		 DB	 5
  03c73	05		 DB	 5
  03c74	05		 DB	 5
  03c75	05		 DB	 5
  03c76	05		 DB	 5
  03c77	05		 DB	 5
  03c78	05		 DB	 5
  03c79	05		 DB	 5
  03c7a	05		 DB	 5
  03c7b	05		 DB	 5
  03c7c	05		 DB	 5
  03c7d	05		 DB	 5
  03c7e	05		 DB	 5
  03c7f	05		 DB	 5
  03c80	05		 DB	 5
  03c81	05		 DB	 5
  03c82	05		 DB	 5
  03c83	05		 DB	 5
  03c84	05		 DB	 5
  03c85	05		 DB	 5
  03c86	05		 DB	 5
  03c87	05		 DB	 5
  03c88	05		 DB	 5
  03c89	05		 DB	 5
  03c8a	05		 DB	 5
  03c8b	05		 DB	 5
  03c8c	05		 DB	 5
  03c8d	05		 DB	 5
  03c8e	05		 DB	 5
  03c8f	05		 DB	 5
  03c90	05		 DB	 5
  03c91	05		 DB	 5
  03c92	05		 DB	 5
  03c93	05		 DB	 5
  03c94	05		 DB	 5
  03c95	05		 DB	 5
  03c96	05		 DB	 5
  03c97	05		 DB	 5
  03c98	05		 DB	 5
  03c99	05		 DB	 5
  03c9a	05		 DB	 5
  03c9b	05		 DB	 5
  03c9c	05		 DB	 5
  03c9d	05		 DB	 5
  03c9e	05		 DB	 5
  03c9f	05		 DB	 5
  03ca0	05		 DB	 5
  03ca1	05		 DB	 5
  03ca2	05		 DB	 5
  03ca3	05		 DB	 5
  03ca4	05		 DB	 5
  03ca5	05		 DB	 5
  03ca6	05		 DB	 5
  03ca7	05		 DB	 5
  03ca8	05		 DB	 5
  03ca9	05		 DB	 5
  03caa	05		 DB	 5
  03cab	05		 DB	 5
  03cac	05		 DB	 5
  03cad	05		 DB	 5
  03cae	05		 DB	 5
  03caf	05		 DB	 5
  03cb0	05		 DB	 5
  03cb1	05		 DB	 5
  03cb2	05		 DB	 5
  03cb3	05		 DB	 5
  03cb4	05		 DB	 5
  03cb5	05		 DB	 5
  03cb6	05		 DB	 5
  03cb7	05		 DB	 5
  03cb8	05		 DB	 5
  03cb9	05		 DB	 5
  03cba	05		 DB	 5
  03cbb	04		 DB	 4
_NCLButtonDown ENDP
; Function compile flags: /Odt /RTCsu
_si$ = -4						; size = 4
_sb$ = 8						; size = 4
_IsScrollbarActive PROC NEAR

; 155  : {

  03cc0	55		 push	 ebp
  03cc1	8b ec		 mov	 ebp, esp
  03cc3	51		 push	 ecx
  03cc4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 156  : 	SCROLLINFO *si = &sb->scrollInfo;

  03ccb	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03cce	83 c0 08	 add	 eax, 8
  03cd1	89 45 fc	 mov	 DWORD PTR _si$[ebp], eax

; 157  : 	if(((sb->fScrollFlags & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH) ||
; 158  : 		!(sb->fScrollFlags & CSBS_THUMBALWAYS) && !IsScrollInfoActive(si))

  03cd4	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  03cd7	8b 11		 mov	 edx, DWORD PTR [ecx]
  03cd9	83 e2 03	 and	 edx, 3
  03cdc	83 fa 03	 cmp	 edx, 3
  03cdf	74 1a		 je	 SHORT $L22491
  03ce1	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  03ce4	8b 08		 mov	 ecx, DWORD PTR [eax]
  03ce6	83 e1 04	 and	 ecx, 4
  03ce9	75 14		 jne	 SHORT $L22490
  03ceb	8b 55 fc	 mov	 edx, DWORD PTR _si$[ebp]
  03cee	52		 push	 edx
  03cef	e8 00 00 00 00	 call	 _IsScrollInfoActive
  03cf4	83 c4 04	 add	 esp, 4
  03cf7	85 c0		 test	 eax, eax
  03cf9	75 04		 jne	 SHORT $L22490
$L22491:

; 159  : 		return FALSE;

  03cfb	33 c0		 xor	 eax, eax
  03cfd	eb 05		 jmp	 SHORT $L22488
$L22490:

; 160  : 	else
; 161  : 		return TRUE;

  03cff	b8 01 00 00 00	 mov	 eax, 1
$L22488:

; 162  : }

  03d04	83 c4 04	 add	 esp, 4
  03d07	3b ec		 cmp	 ebp, esp
  03d09	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03d0e	8b e5		 mov	 esp, ebp
  03d10	5d		 pop	 ebp
  03d11	c3		 ret	 0
_IsScrollbarActive ENDP
; Function compile flags: /Odt /RTCsu
_hwnd$ = 8						; size = 4
_scrMsg$ = 12						; size = 4
_scrId$ = 16						; size = 4
_pos$ = 20						; size = 4
_SendScrollMessage PROC NEAR

; 401  : {

  03d20	55		 push	 ebp
  03d21	8b ec		 mov	 ebp, esp
  03d23	56		 push	 esi

; 402  : 	SendMessage(hwnd, scrMsg, MAKEWPARAM(scrId, pos), 0);

  03d24	8b f4		 mov	 esi, esp
  03d26	6a 00		 push	 0
  03d28	8b 45 10	 mov	 eax, DWORD PTR _scrId$[ebp]
  03d2b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  03d30	0f b7 c8	 movzx	 ecx, ax
  03d33	8b 55 14	 mov	 edx, DWORD PTR _pos$[ebp]
  03d36	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  03d3c	0f b7 c2	 movzx	 eax, dx
  03d3f	c1 e0 10	 shl	 eax, 16			; 00000010H
  03d42	0b c8		 or	 ecx, eax
  03d44	51		 push	 ecx
  03d45	8b 4d 0c	 mov	 ecx, DWORD PTR _scrMsg$[ebp]
  03d48	51		 push	 ecx
  03d49	8b 55 08	 mov	 edx, DWORD PTR _hwnd$[ebp]
  03d4c	52		 push	 edx
  03d4d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  03d53	3b f4		 cmp	 esi, esp
  03d55	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 403  : }

  03d5a	5e		 pop	 esi
  03d5b	3b ec		 cmp	 ebp, esp
  03d5d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03d62	5d		 pop	 ebp
  03d63	c3		 ret	 0
_SendScrollMessage ENDP
; Function compile flags: /Odt /RTCsu
_workingwidth$ = -36					; size = 4
_scrollwidth$ = -32					; size = 4
_butwidth$ = -28					; size = 4
_thumbpos$ = -20					; size = 4
_thumbwidth$ = -8					; size = 4
_sbar$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetHorzScrollPortion PROC NEAR

; 614  : {

  03d70	55		 push	 ebp
  03d71	8b ec		 mov	 ebp, esp
  03d73	83 ec 24	 sub	 esp, 36			; 00000024H
  03d76	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  03d7b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  03d7e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  03d81	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  03d84	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  03d87	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  03d8a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  03d8d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  03d90	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  03d93	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 615  : 	int thumbwidth, thumbpos;
; 616  : 	int butwidth = GetScrollMetric(sbar, SM_SCROLL_LENGTH);

  03d96	6a 00		 push	 0
  03d98	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  03d9b	50		 push	 eax
  03d9c	e8 00 00 00 00	 call	 _GetScrollMetric
  03da1	83 c4 08	 add	 esp, 8
  03da4	89 45 e4	 mov	 DWORD PTR _butwidth$[ebp], eax

; 617  : 	int scrollwidth  = rect->right-rect->left;

  03da7	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  03daa	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  03dad	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  03db0	2b 02		 sub	 eax, DWORD PTR [edx]
  03db2	89 45 e0	 mov	 DWORD PTR _scrollwidth$[ebp], eax

; 618  : 	int workingwidth = scrollwidth - butwidth*2;

  03db5	8b 4d e4	 mov	 ecx, DWORD PTR _butwidth$[ebp]
  03db8	d1 e1		 shl	 ecx, 1
  03dba	8b 55 e0	 mov	 edx, DWORD PTR _scrollwidth$[ebp]
  03dbd	2b d1		 sub	 edx, ecx
  03dbf	89 55 dc	 mov	 DWORD PTR _workingwidth$[ebp], edx

; 619  : 
; 620  : 	if(y < rect->top || y >= rect->bottom)

  03dc2	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03dc5	8b 4d 18	 mov	 ecx, DWORD PTR _y$[ebp]
  03dc8	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  03dcb	7c 0b		 jl	 SHORT $L22728
  03dcd	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  03dd0	8b 45 18	 mov	 eax, DWORD PTR _y$[ebp]
  03dd3	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  03dd6	7c 08		 jl	 SHORT $L22727
$L22728:

; 621  : 		return HTSCROLL_NONE;

  03dd8	83 c8 ff	 or	 eax, -1
  03ddb	e9 d1 00 00 00	 jmp	 $L22721
$L22727:

; 622  : 
; 623  : 	CalcThumbSize(sbar, rect, &thumbwidth, &thumbpos);

  03de0	8d 4d ec	 lea	 ecx, DWORD PTR _thumbpos$[ebp]
  03de3	51		 push	 ecx
  03de4	8d 55 f8	 lea	 edx, DWORD PTR _thumbwidth$[ebp]
  03de7	52		 push	 edx
  03de8	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03deb	50		 push	 eax
  03dec	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  03def	51		 push	 ecx
  03df0	e8 00 00 00 00	 call	 _CalcThumbSize
  03df5	83 c4 10	 add	 esp, 16			; 00000010H

; 624  : 
; 625  : 	//if we have had to scale the buttons to fit in the rect,
; 626  : 	//then adjust the button width accordingly
; 627  : 	if(scrollwidth <= butwidth * 2)

  03df8	8b 55 e4	 mov	 edx, DWORD PTR _butwidth$[ebp]
  03dfb	d1 e2		 shl	 edx, 1
  03dfd	39 55 e0	 cmp	 DWORD PTR _scrollwidth$[ebp], edx
  03e00	7f 0b		 jg	 SHORT $L22729

; 628  : 	{
; 629  : 		butwidth = scrollwidth / 2;	

  03e02	8b 45 e0	 mov	 eax, DWORD PTR _scrollwidth$[ebp]
  03e05	99		 cdq
  03e06	2b c2		 sub	 eax, edx
  03e08	d1 f8		 sar	 eax, 1
  03e0a	89 45 e4	 mov	 DWORD PTR _butwidth$[ebp], eax
$L22729:

; 630  : 	}
; 631  : 
; 632  : 	//check for left button click
; 633  : 	if(x >= rect->left && x < rect->left + butwidth)

  03e0d	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03e10	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  03e13	3b 08		 cmp	 ecx, DWORD PTR [eax]
  03e15	7c 14		 jl	 SHORT $L22730
  03e17	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  03e1a	8b 02		 mov	 eax, DWORD PTR [edx]
  03e1c	03 45 e4	 add	 eax, DWORD PTR _butwidth$[ebp]
  03e1f	39 45 14	 cmp	 DWORD PTR _x$[ebp], eax
  03e22	7d 07		 jge	 SHORT $L22730

; 634  : 	{
; 635  : 		return HTSCROLL_LEFT;	

  03e24	33 c0		 xor	 eax, eax
  03e26	e9 86 00 00 00	 jmp	 $L22721
$L22730:

; 636  : 	}
; 637  : 	//check for right button click
; 638  : 	else if(x >= rect->right-butwidth && x < rect->right)

  03e2b	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp]
  03e2e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  03e31	2b 55 e4	 sub	 edx, DWORD PTR _butwidth$[ebp]
  03e34	39 55 14	 cmp	 DWORD PTR _x$[ebp], edx
  03e37	7c 12		 jl	 SHORT $L22731
  03e39	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03e3c	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  03e3f	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  03e42	7d 07		 jge	 SHORT $L22731

; 639  : 	{
; 640  : 		return HTSCROLL_RIGHT;

  03e44	b8 01 00 00 00	 mov	 eax, 1
  03e49	eb 66		 jmp	 SHORT $L22721
$L22731:

; 641  : 	}
; 642  : 	
; 643  : 	//if the thumb is too big to fit (i.e. it isn't visible)
; 644  : 	//then return a NULL scrollbar area
; 645  : 	if(thumbwidth >= workingwidth)

  03e4b	8b 55 f8	 mov	 edx, DWORD PTR _thumbwidth$[ebp]
  03e4e	3b 55 dc	 cmp	 edx, DWORD PTR _workingwidth$[ebp]
  03e51	7c 05		 jl	 SHORT $L22733

; 646  : 		return HTSCROLL_NONE;

  03e53	83 c8 ff	 or	 eax, -1
  03e56	eb 59		 jmp	 SHORT $L22721
$L22733:

; 647  : 	
; 648  : 	//check for point in the thumbbar
; 649  : 	if(x >= thumbpos && x < thumbpos+thumbwidth)

  03e58	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  03e5b	3b 45 ec	 cmp	 eax, DWORD PTR _thumbpos$[ebp]
  03e5e	7c 12		 jl	 SHORT $L22734
  03e60	8b 4d ec	 mov	 ecx, DWORD PTR _thumbpos$[ebp]
  03e63	03 4d f8	 add	 ecx, DWORD PTR _thumbwidth$[ebp]
  03e66	39 4d 14	 cmp	 DWORD PTR _x$[ebp], ecx
  03e69	7d 07		 jge	 SHORT $L22734

; 650  : 	{
; 651  : 		return HTSCROLL_THUMB;

  03e6b	b8 05 00 00 00	 mov	 eax, 5
  03e70	eb 3f		 jmp	 SHORT $L22721
$L22734:

; 652  : 	}	
; 653  : 	//check for left margin
; 654  : 	else if(x >= rect->left+butwidth && x < thumbpos)

  03e72	8b 55 10	 mov	 edx, DWORD PTR _rect$[ebp]
  03e75	8b 02		 mov	 eax, DWORD PTR [edx]
  03e77	03 45 e4	 add	 eax, DWORD PTR _butwidth$[ebp]
  03e7a	39 45 14	 cmp	 DWORD PTR _x$[ebp], eax
  03e7d	7c 0f		 jl	 SHORT $L22736
  03e7f	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  03e82	3b 4d ec	 cmp	 ecx, DWORD PTR _thumbpos$[ebp]
  03e85	7d 07		 jge	 SHORT $L22736

; 655  : 	{
; 656  : 		return HTSCROLL_PAGELEFT;

  03e87	b8 02 00 00 00	 mov	 eax, 2
  03e8c	eb 23		 jmp	 SHORT $L22721
$L22736:

; 657  : 	}
; 658  : 	else if(x >= thumbpos+thumbwidth && x < rect->right-butwidth)

  03e8e	8b 55 ec	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  03e91	03 55 f8	 add	 edx, DWORD PTR _thumbwidth$[ebp]
  03e94	39 55 14	 cmp	 DWORD PTR _x$[ebp], edx
  03e97	7c 15		 jl	 SHORT $L22735
  03e99	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03e9c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  03e9f	2b 4d e4	 sub	 ecx, DWORD PTR _butwidth$[ebp]
  03ea2	39 4d 14	 cmp	 DWORD PTR _x$[ebp], ecx
  03ea5	7d 07		 jge	 SHORT $L22735

; 659  : 	{
; 660  : 		return HTSCROLL_PAGERIGHT;

  03ea7	b8 03 00 00 00	 mov	 eax, 3
  03eac	eb 03		 jmp	 SHORT $L22721
$L22735:

; 661  : 	}
; 662  : 	
; 663  : 	return HTSCROLL_NONE;

  03eae	83 c8 ff	 or	 eax, -1
$L22721:

; 664  : }

  03eb1	52		 push	 edx
  03eb2	8b cd		 mov	 ecx, ebp
  03eb4	50		 push	 eax
  03eb5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23992
  03ebb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  03ec0	58		 pop	 eax
  03ec1	5a		 pop	 edx
  03ec2	83 c4 24	 add	 esp, 36			; 00000024H
  03ec5	3b ec		 cmp	 ebp, esp
  03ec7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03ecc	8b e5		 mov	 esp, ebp
  03ece	5d		 pop	 ebp
  03ecf	c3		 ret	 0
$L23992:
  03ed0	02 00 00 00	 DD	 2
  03ed4	00 00 00 00	 DD	 $L23991
$L23991:
  03ed8	f8 ff ff ff	 DD	 -8			; fffffff8H
  03edc	04 00 00 00	 DD	 4
  03ee0	00 00 00 00	 DD	 $L23989
  03ee4	ec ff ff ff	 DD	 -20			; ffffffecH
  03ee8	04 00 00 00	 DD	 4
  03eec	00 00 00 00	 DD	 $L23990
$L23990:
  03ef0	74		 DB	 116			; 00000074H
  03ef1	68		 DB	 104			; 00000068H
  03ef2	75		 DB	 117			; 00000075H
  03ef3	6d		 DB	 109			; 0000006dH
  03ef4	62		 DB	 98			; 00000062H
  03ef5	70		 DB	 112			; 00000070H
  03ef6	6f		 DB	 111			; 0000006fH
  03ef7	73		 DB	 115			; 00000073H
  03ef8	00		 DB	 0
$L23989:
  03ef9	74		 DB	 116			; 00000074H
  03efa	68		 DB	 104			; 00000068H
  03efb	75		 DB	 117			; 00000075H
  03efc	6d		 DB	 109			; 0000006dH
  03efd	62		 DB	 98			; 00000062H
  03efe	77		 DB	 119			; 00000077H
  03eff	69		 DB	 105			; 00000069H
  03f00	64		 DB	 100			; 00000064H
  03f01	74		 DB	 116			; 00000074H
  03f02	68		 DB	 104			; 00000068H
  03f03	00		 DB	 0
_GetHorzScrollPortion ENDP
; Function compile flags: /Odt /RTCsu
_r$ = -4						; size = 4
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetVertScrollPortion PROC NEAR

; 671  : {

  03f10	55		 push	 ebp
  03f11	8b ec		 mov	 ebp, esp
  03f13	51		 push	 ecx
  03f14	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 672  : 	UINT r;
; 673  : 	
; 674  : 	RotateRect(rect);

  03f1b	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03f1e	50		 push	 eax
  03f1f	e8 00 00 00 00	 call	 _RotateRect@4

; 675  : 	r = GetHorzScrollPortion(sb, hwnd, rect, y, x);

  03f24	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  03f27	51		 push	 ecx
  03f28	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  03f2b	52		 push	 edx
  03f2c	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03f2f	50		 push	 eax
  03f30	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03f33	51		 push	 ecx
  03f34	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  03f37	52		 push	 edx
  03f38	e8 00 00 00 00	 call	 _GetHorzScrollPortion
  03f3d	83 c4 14	 add	 esp, 20			; 00000014H
  03f40	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 676  : 	RotateRect(rect);

  03f43	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  03f46	50		 push	 eax
  03f47	e8 00 00 00 00	 call	 _RotateRect@4

; 677  : 	return r;

  03f4c	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]

; 678  : }

  03f4f	83 c4 04	 add	 esp, 4
  03f52	3b ec		 cmp	 ebp, esp
  03f54	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03f59	8b e5		 mov	 esp, ebp
  03f5b	5d		 pop	 ebp
  03f5c	c3		 ret	 0
_GetVertScrollPortion ENDP
; Function compile flags: /Odt /RTCsu
_nmcb$ = -52						; size = 48
_hwnd$ = 8						; size = 4
_msg$ = 12						; size = 4
_nBar$ = 16						; size = 4
_prect$ = 20						; size = 4
_nCmdId$ = 24						; size = 4
_pt$ = 28						; size = 8
_PostMouseNotify0 PROC NEAR

; 751  : {

  03f60	55		 push	 ebp
  03f61	8b ec		 mov	 ebp, esp
  03f63	83 ec 38	 sub	 esp, 56			; 00000038H
  03f66	56		 push	 esi
  03f67	57		 push	 edi
  03f68	8d 7d c8	 lea	 edi, DWORD PTR [ebp-56]
  03f6b	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  03f70	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  03f75	f3 ab		 rep stosd

; 752  : #ifdef NOTIFY_MOUSE
; 753  : 	NMCOOLBUTMSG	nmcb;
; 754  : 
; 755  : 	//fill in the standard header
; 756  : 	nmcb.hdr.hwndFrom	= hwnd;

  03f77	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03f7a	89 45 cc	 mov	 DWORD PTR _nmcb$[ebp], eax

; 757  : 	nmcb.hdr.idFrom		= GetWindowLong(hwnd, GWL_ID);

  03f7d	8b f4		 mov	 esi, esp
  03f7f	6a f4		 push	 -12			; fffffff4H
  03f81	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  03f84	51		 push	 ecx
  03f85	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  03f8b	3b f4		 cmp	 esi, esp
  03f8d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03f92	89 45 d0	 mov	 DWORD PTR _nmcb$[ebp+4], eax

; 758  : 	nmcb.hdr.code		= NM_CLICK;

  03f95	c7 45 d4 fe ff
	ff ff		 mov	 DWORD PTR _nmcb$[ebp+8], -2 ; fffffffeH

; 759  : 
; 760  : 	nmcb.nBar			= nBar;

  03f9c	8b 55 10	 mov	 edx, DWORD PTR _nBar$[ebp]
  03f9f	89 55 f8	 mov	 DWORD PTR _nmcb$[ebp+44], edx

; 761  : 	nmcb.uCmdId			= nCmdId;

  03fa2	8b 45 18	 mov	 eax, DWORD PTR _nCmdId$[ebp]
  03fa5	89 45 f0	 mov	 DWORD PTR _nmcb$[ebp+36], eax

; 762  : 	nmcb.uState			= 0;

  03fa8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nmcb$[ebp+40], 0

; 763  : 	nmcb.rect			= *prect;

  03faf	8b 4d 14	 mov	 ecx, DWORD PTR _prect$[ebp]
  03fb2	8b 11		 mov	 edx, DWORD PTR [ecx]
  03fb4	89 55 d8	 mov	 DWORD PTR _nmcb$[ebp+12], edx
  03fb7	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  03fba	89 45 dc	 mov	 DWORD PTR _nmcb$[ebp+16], eax
  03fbd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  03fc0	89 55 e0	 mov	 DWORD PTR _nmcb$[ebp+20], edx
  03fc3	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  03fc6	89 45 e4	 mov	 DWORD PTR _nmcb$[ebp+24], eax

; 764  : 	nmcb.pt				= pt;

  03fc9	8b 4d 1c	 mov	 ecx, DWORD PTR _pt$[ebp]
  03fcc	89 4d e8	 mov	 DWORD PTR _nmcb$[ebp+28], ecx
  03fcf	8b 55 20	 mov	 edx, DWORD PTR _pt$[ebp+4]
  03fd2	89 55 ec	 mov	 DWORD PTR _nmcb$[ebp+32], edx

; 765  : 
; 766  : 	hwnd = GetParent(hwnd);

  03fd5	8b f4		 mov	 esi, esp
  03fd7	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03fda	50		 push	 eax
  03fdb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  03fe1	3b f4		 cmp	 esi, esp
  03fe3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  03fe8	89 45 08	 mov	 DWORD PTR _hwnd$[ebp], eax

; 767  : 	return SendMessage(hwnd, WM_NOTIFY, nmcb.hdr.idFrom, (LPARAM)&nmcb);

  03feb	8b f4		 mov	 esi, esp
  03fed	8d 4d cc	 lea	 ecx, DWORD PTR _nmcb$[ebp]
  03ff0	51		 push	 ecx
  03ff1	8b 55 d0	 mov	 edx, DWORD PTR _nmcb$[ebp+4]
  03ff4	52		 push	 edx
  03ff5	6a 4e		 push	 78			; 0000004eH
  03ff7	8b 45 08	 mov	 eax, DWORD PTR _hwnd$[ebp]
  03ffa	50		 push	 eax
  03ffb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  04001	3b f4		 cmp	 esi, esp
  04003	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 768  : #else
; 769  : 	return 0;
; 770  : #endif
; 771  : }

  04008	52		 push	 edx
  04009	8b cd		 mov	 ecx, ebp
  0400b	50		 push	 eax
  0400c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L23997
  04012	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  04017	58		 pop	 eax
  04018	5a		 pop	 edx
  04019	5f		 pop	 edi
  0401a	5e		 pop	 esi
  0401b	83 c4 38	 add	 esp, 56			; 00000038H
  0401e	3b ec		 cmp	 ebp, esp
  04020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04025	8b e5		 mov	 esp, ebp
  04027	5d		 pop	 ebp
  04028	c3		 ret	 0
$L23997:
  04029	01 00 00 00	 DD	 1
  0402d	00 00 00 00	 DD	 $L23996
$L23996:
  04031	cc ff ff ff	 DD	 -52			; ffffffccH
  04035	30 00 00 00	 DD	 48			; 00000030H
  04039	00 00 00 00	 DD	 $L23995
$L23995:
  0403d	6e		 DB	 110			; 0000006eH
  0403e	6d		 DB	 109			; 0000006dH
  0403f	63		 DB	 99			; 00000063H
  04040	62		 DB	 98			; 00000062H
  04041	00		 DB	 0
_PostMouseNotify0 ENDP
; Function compile flags: /Odt /RTCsu
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_hdc$ = 16						; size = 4
_rect$ = 20						; size = 4
_uDrawFlags$ = 24					; size = 4
_NCDrawScrollbar PROC NEAR

; 1090 : {

  04050	55		 push	 ebp
  04051	8b ec		 mov	 ebp, esp

; 1091 : 	if(sb->nBarType == SB_HORZ)

  04053	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04056	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0405d	75 1e		 jne	 SHORT $L22917

; 1092 : 		return NCDrawHScrollbar(sb, hwnd, hdc, rect, uDrawFlags);

  0405f	8b 4d 18	 mov	 ecx, DWORD PTR _uDrawFlags$[ebp]
  04062	51		 push	 ecx
  04063	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp]
  04066	52		 push	 edx
  04067	8b 45 10	 mov	 eax, DWORD PTR _hdc$[ebp]
  0406a	50		 push	 eax
  0406b	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0406e	51		 push	 ecx
  0406f	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04072	52		 push	 edx
  04073	e8 00 00 00 00	 call	 _NCDrawHScrollbar
  04078	83 c4 14	 add	 esp, 20			; 00000014H
  0407b	eb 1c		 jmp	 SHORT $L22916
$L22917:

; 1093 : 	else
; 1094 : 		return NCDrawVScrollbar(sb, hwnd, hdc, rect, uDrawFlags);

  0407d	8b 45 18	 mov	 eax, DWORD PTR _uDrawFlags$[ebp]
  04080	50		 push	 eax
  04081	8b 4d 14	 mov	 ecx, DWORD PTR _rect$[ebp]
  04084	51		 push	 ecx
  04085	8b 55 10	 mov	 edx, DWORD PTR _hdc$[ebp]
  04088	52		 push	 edx
  04089	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0408c	50		 push	 eax
  0408d	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  04090	51		 push	 ecx
  04091	e8 00 00 00 00	 call	 _NCDrawVScrollbar
  04096	83 c4 14	 add	 esp, 20			; 00000014H
$L22916:

; 1095 : }

  04099	3b ec		 cmp	 ebp, esp
  0409b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  040a0	5d		 pop	 ebp
  040a1	c3		 ret	 0
_NCDrawScrollbar ENDP
; Function compile flags: /Odt /RTCsu
_rc$ = -20						; size = 16
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetHorzPortion PROC NEAR

; 1661 : {

  040b0	55		 push	 ebp
  040b1	8b ec		 mov	 ebp, esp
  040b3	83 ec 18	 sub	 esp, 24			; 00000018H
  040b6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  040bb	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  040be	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  040c1	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  040c4	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  040c7	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  040ca	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1662 : 	RECT rc = *rect;

  040cd	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  040d0	8b 08		 mov	 ecx, DWORD PTR [eax]
  040d2	89 4d ec	 mov	 DWORD PTR _rc$[ebp], ecx
  040d5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  040d8	89 55 f0	 mov	 DWORD PTR _rc$[ebp+4], edx
  040db	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  040de	89 4d f4	 mov	 DWORD PTR _rc$[ebp+8], ecx
  040e1	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  040e4	89 55 f8	 mov	 DWORD PTR _rc$[ebp+12], edx

; 1663 : 
; 1664 : 	if(y < rc.top || y >= rc.bottom) return HTSCROLL_NONE;

  040e7	8b 45 18	 mov	 eax, DWORD PTR _y$[ebp]
  040ea	3b 45 f0	 cmp	 eax, DWORD PTR _rc$[ebp+4]
  040ed	7c 08		 jl	 SHORT $L23135
  040ef	8b 4d 18	 mov	 ecx, DWORD PTR _y$[ebp]
  040f2	3b 4d f8	 cmp	 ecx, DWORD PTR _rc$[ebp+12]
  040f5	7c 08		 jl	 SHORT $L23134
$L23135:
  040f7	83 c8 ff	 or	 eax, -1
  040fa	e9 92 00 00 00	 jmp	 $L23132
$L23134:

; 1665 : 
; 1666 : #ifdef INCLUDE_BUTTONS
; 1667 : 
; 1668 : 	if(sb->fButVisibleBefore) 

  040ff	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04102	83 ba 38 03 00
	00 00		 cmp	 DWORD PTR [edx+824], 0
  04109	74 2f		 je	 SHORT $L23136

; 1669 : 	{
; 1670 : 		//clicked on the buttons to the left of the scrollbar
; 1671 : 		if(x >= rc.left && x < rc.left + sb->nButSizeBefore)

  0410b	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  0410e	3b 45 ec	 cmp	 eax, DWORD PTR _rc$[ebp]
  04111	7c 18		 jl	 SHORT $L23137
  04113	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  04116	8b 55 ec	 mov	 edx, DWORD PTR _rc$[ebp]
  04119	03 91 30 03 00
	00		 add	 edx, DWORD PTR [ecx+816]
  0411f	39 55 14	 cmp	 DWORD PTR _x$[ebp], edx
  04122	7d 07		 jge	 SHORT $L23137

; 1672 : 			return HTSCROLL_INSERTED;

  04124	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  04129	eb 66		 jmp	 SHORT $L23132
$L23137:

; 1673 : 
; 1674 : 		//adjust the rectangle to exclude the left-side buttons, now that we
; 1675 : 		//know we havn't clicked on them
; 1676 : 		rc.left  += sb->nButSizeBefore;

  0412b	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0412e	8b 4d ec	 mov	 ecx, DWORD PTR _rc$[ebp]
  04131	03 88 30 03 00
	00		 add	 ecx, DWORD PTR [eax+816]
  04137	89 4d ec	 mov	 DWORD PTR _rc$[ebp], ecx
$L23136:

; 1677 : 	}
; 1678 : 
; 1679 : 	if(sb->fButVisibleAfter)

  0413a	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0413d	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  04144	74 2f		 je	 SHORT $L23138

; 1680 : 	{
; 1681 : 		//clicked on the buttons to the right of the scrollbar
; 1682 : 		if(x >= rc.right - sb->nButSizeAfter && x < rc.right)

  04146	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04149	8b 4d f4	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  0414c	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  04152	39 4d 14	 cmp	 DWORD PTR _x$[ebp], ecx
  04155	7c 0f		 jl	 SHORT $L23139
  04157	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  0415a	3b 55 f4	 cmp	 edx, DWORD PTR _rc$[ebp+8]
  0415d	7d 07		 jge	 SHORT $L23139

; 1683 : 			return HTSCROLL_INSERTED;

  0415f	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  04164	eb 2b		 jmp	 SHORT $L23132
$L23139:

; 1684 : 
; 1685 : 		//adjust the rectangle to exclude the right-side buttons, now that we
; 1686 : 		//know we havn't clicked on them
; 1687 : 		rc.right -= sb->nButSizeAfter;

  04166	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04169	8b 4d f4	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  0416c	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  04172	89 4d f4	 mov	 DWORD PTR _rc$[ebp+8], ecx
$L23138:

; 1688 : 	}
; 1689 : 
; 1690 : #endif INCLUDE_BUTTONS
; 1691 : 
; 1692 : 	//Now we have the rectangle for the scrollbar itself, so work out
; 1693 : 	//what part we clicked on.
; 1694 : 	return GetHorzScrollPortion(sb, hwnd, &rc, x, y);

  04175	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  04178	52		 push	 edx
  04179	8b 45 14	 mov	 eax, DWORD PTR _x$[ebp]
  0417c	50		 push	 eax
  0417d	8d 4d ec	 lea	 ecx, DWORD PTR _rc$[ebp]
  04180	51		 push	 ecx
  04181	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04184	52		 push	 edx
  04185	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04188	50		 push	 eax
  04189	e8 00 00 00 00	 call	 _GetHorzScrollPortion
  0418e	83 c4 14	 add	 esp, 20			; 00000014H
$L23132:

; 1695 : }

  04191	52		 push	 edx
  04192	8b cd		 mov	 ecx, ebp
  04194	50		 push	 eax
  04195	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L24002
  0419b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  041a0	58		 pop	 eax
  041a1	5a		 pop	 edx
  041a2	83 c4 18	 add	 esp, 24			; 00000018H
  041a5	3b ec		 cmp	 ebp, esp
  041a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  041ac	8b e5		 mov	 esp, ebp
  041ae	5d		 pop	 ebp
  041af	c3		 ret	 0
$L24002:
  041b0	01 00 00 00	 DD	 1
  041b4	00 00 00 00	 DD	 $L24001
$L24001:
  041b8	ec ff ff ff	 DD	 -20			; ffffffecH
  041bc	10 00 00 00	 DD	 16			; 00000010H
  041c0	00 00 00 00	 DD	 $L24000
$L24000:
  041c4	72		 DB	 114			; 00000072H
  041c5	63		 DB	 99			; 00000063H
  041c6	00		 DB	 0
_GetHorzPortion ENDP
; Function compile flags: /Odt /RTCsu
_ret$ = -4						; size = 4
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetVertPortion PROC NEAR

; 1701 : {

  041d0	55		 push	 ebp
  041d1	8b ec		 mov	 ebp, esp
  041d3	51		 push	 ecx
  041d4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1702 : 	UINT ret;
; 1703 : 	RotateRect(rect);

  041db	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  041de	50		 push	 eax
  041df	e8 00 00 00 00	 call	 _RotateRect@4

; 1704 : 	ret = GetHorzPortion(sb, hwnd, rect, y, x);

  041e4	8b 4d 14	 mov	 ecx, DWORD PTR _x$[ebp]
  041e7	51		 push	 ecx
  041e8	8b 55 18	 mov	 edx, DWORD PTR _y$[ebp]
  041eb	52		 push	 edx
  041ec	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  041ef	50		 push	 eax
  041f0	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  041f3	51		 push	 ecx
  041f4	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  041f7	52		 push	 edx
  041f8	e8 00 00 00 00	 call	 _GetHorzPortion
  041fd	83 c4 14	 add	 esp, 20			; 00000014H
  04200	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 1705 : 	RotateRect(rect);

  04203	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  04206	50		 push	 eax
  04207	e8 00 00 00 00	 call	 _RotateRect@4

; 1706 : 	return ret;

  0420c	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 1707 : }

  0420f	83 c4 04	 add	 esp, 4
  04212	3b ec		 cmp	 ebp, esp
  04214	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04219	8b e5		 mov	 esp, ebp
  0421b	5d		 pop	 ebp
  0421c	c3		 ret	 0
_GetVertPortion ENDP
; Function compile flags: /Odt /RTCsu
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_GetRealScrollRect PROC NEAR

; 1747 : {

  04220	55		 push	 ebp
  04221	8b ec		 mov	 ebp, esp

; 1748 : 	if(sb->nBarType == SB_HORZ)

  04223	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04226	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0422d	75 12		 jne	 SHORT $L23191

; 1749 : 	{
; 1750 : 		GetRealHorzScrollRect(sb, rect);

  0422f	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  04232	51		 push	 ecx
  04233	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04236	52		 push	 edx
  04237	e8 00 00 00 00	 call	 _GetRealHorzScrollRect
  0423c	83 c4 08	 add	 esp, 8

; 1751 : 	}
; 1752 : 	else if(sb->nBarType == SB_VERT)

  0423f	eb 1c		 jmp	 SHORT $L23190
$L23191:
  04241	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04244	83 b8 40 03 00
	00 01		 cmp	 DWORD PTR [eax+832], 1
  0424b	75 10		 jne	 SHORT $L23190

; 1753 : 	{
; 1754 : 		GetRealVertScrollRect(sb, rect);

  0424d	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  04250	51		 push	 ecx
  04251	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04254	52		 push	 edx
  04255	e8 00 00 00 00	 call	 _GetRealVertScrollRect
  0425a	83 c4 08	 add	 esp, 8
$L23190:

; 1755 : 	}
; 1756 : }

  0425d	3b ec		 cmp	 ebp, esp
  0425f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04264	5d		 pop	 ebp
  04265	c3		 ret	 0
_GetRealScrollRect ENDP
; Function compile flags: /Odt /RTCsu
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_GetRealHorzScrollRect PROC NEAR

; 1727 : {

  04270	55		 push	 ebp
  04271	8b ec		 mov	 ebp, esp

; 1728 : 	if(sb->fButVisibleBefore) rect->left += sb->nButSizeBefore;

  04273	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04276	83 b8 38 03 00
	00 00		 cmp	 DWORD PTR [eax+824], 0
  0427d	74 13		 je	 SHORT $L23175
  0427f	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  04282	8b 11		 mov	 edx, DWORD PTR [ecx]
  04284	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04287	03 90 30 03 00
	00		 add	 edx, DWORD PTR [eax+816]
  0428d	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  04290	89 11		 mov	 DWORD PTR [ecx], edx
$L23175:

; 1729 : 	if(sb->fButVisibleAfter)  rect->right -= sb->nButSizeAfter;

  04292	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04295	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  0429c	74 15		 je	 SHORT $L23174
  0429e	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  042a1	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  042a4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  042a7	2b 91 34 03 00
	00		 sub	 edx, DWORD PTR [ecx+820]
  042ad	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  042b0	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L23174:

; 1730 : }

  042b3	5d		 pop	 ebp
  042b4	c3		 ret	 0
_GetRealHorzScrollRect ENDP
; Function compile flags: /Odt /RTCsu
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_GetRealVertScrollRect PROC NEAR

; 1737 : {

  042c0	55		 push	 ebp
  042c1	8b ec		 mov	 ebp, esp

; 1738 : 	if(sb->fButVisibleBefore) rect->top += sb->nButSizeBefore;

  042c3	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  042c6	83 b8 38 03 00
	00 00		 cmp	 DWORD PTR [eax+824], 0
  042cd	74 15		 je	 SHORT $L23183
  042cf	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  042d2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  042d5	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  042d8	03 90 30 03 00
	00		 add	 edx, DWORD PTR [eax+816]
  042de	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  042e1	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$L23183:

; 1739 : 	if(sb->fButVisibleAfter)  rect->bottom -= sb->nButSizeAfter;

  042e4	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  042e7	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  042ee	74 15		 je	 SHORT $L23182
  042f0	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  042f3	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  042f6	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  042f9	2b 91 34 03 00
	00		 sub	 edx, DWORD PTR [ecx+820]
  042ff	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  04302	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L23182:

; 1740 : }

  04305	5d		 pop	 ebp
  04306	c3		 ret	 0
_GetRealVertScrollRect ENDP
; Function compile flags: /Odt /RTCsu
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_pt$ = 16						; size = 8
_fReturnRect$ = 24					; size = 4
_GetButtonFromPt PROC NEAR

; 1851 : {

  04310	55		 push	 ebp
  04311	8b ec		 mov	 ebp, esp

; 1852 : 	if(sb->nBarType == SB_HORZ)

  04313	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04316	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0431d	75 1e		 jne	 SHORT $L23243

; 1853 : 	{
; 1854 : 		return GetHorzButtonFromPt(sb, rect, pt, fReturnRect);

  0431f	8b 4d 18	 mov	 ecx, DWORD PTR _fReturnRect$[ebp]
  04322	51		 push	 ecx
  04323	8b 55 14	 mov	 edx, DWORD PTR _pt$[ebp+4]
  04326	52		 push	 edx
  04327	8b 45 10	 mov	 eax, DWORD PTR _pt$[ebp]
  0432a	50		 push	 eax
  0432b	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  0432e	51		 push	 ecx
  0432f	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04332	52		 push	 edx
  04333	e8 00 00 00 00	 call	 _GetHorzButtonFromPt
  04338	83 c4 14	 add	 esp, 20			; 00000014H
  0433b	eb 1c		 jmp	 SHORT $L23242
$L23243:

; 1855 : 	}
; 1856 : 	else
; 1857 : 	{
; 1858 : 		return GetVertButtonFromPt(sb, rect, pt, fReturnRect);

  0433d	8b 45 18	 mov	 eax, DWORD PTR _fReturnRect$[ebp]
  04340	50		 push	 eax
  04341	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  04344	51		 push	 ecx
  04345	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp]
  04348	52		 push	 edx
  04349	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0434c	50		 push	 eax
  0434d	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  04350	51		 push	 ecx
  04351	e8 00 00 00 00	 call	 _GetVertButtonFromPt
  04356	83 c4 14	 add	 esp, 20			; 00000014H
$L23242:

; 1859 : 	}
; 1860 : }

  04359	3b ec		 cmp	 ebp, esp
  0435b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04360	5d		 pop	 ebp
  04361	c3		 ret	 0
_GetButtonFromPt ENDP
; Function compile flags: /Odt /RTCsu
_sbut$ = -20						; size = 4
_butwidth$ = -16					; size = 4
_i$ = -12						; size = 4
_rightpos$ = -8						; size = 4
_leftpos$ = -4						; size = 4
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_pt$ = 16						; size = 8
_fReturnRect$ = 24					; size = 4
_GetHorzButtonFromPt PROC NEAR

; 1771 : {

  04370	55		 push	 ebp
  04371	8b ec		 mov	 ebp, esp
  04373	83 ec 14	 sub	 esp, 20			; 00000014H
  04376	56		 push	 esi
  04377	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0437c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0437f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  04382	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  04385	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  04388	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1772 : 	int leftpos = rect->left, rightpos = rect->right;

  0438b	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0438e	8b 08		 mov	 ecx, DWORD PTR [eax]
  04390	89 4d fc	 mov	 DWORD PTR _leftpos$[ebp], ecx
  04393	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  04396	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  04399	89 45 f8	 mov	 DWORD PTR _rightpos$[ebp], eax

; 1773 : 	int i;
; 1774 : 	int butwidth;
; 1775 : 	SCROLLBUT *sbut = sb->sbButtons;

  0439c	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  0439f	83 c1 2c	 add	 ecx, 44			; 0000002cH
  043a2	89 4d ec	 mov	 DWORD PTR _sbut$[ebp], ecx

; 1776 : 
; 1777 : 	if(!PtInRect(rect, pt))

  043a5	8b f4		 mov	 esi, esp
  043a7	8b 55 14	 mov	 edx, DWORD PTR _pt$[ebp+4]
  043aa	52		 push	 edx
  043ab	8b 45 10	 mov	 eax, DWORD PTR _pt$[ebp]
  043ae	50		 push	 eax
  043af	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  043b2	51		 push	 ecx
  043b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  043b9	3b f4		 cmp	 esi, esp
  043bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  043c0	85 c0		 test	 eax, eax
  043c2	75 08		 jne	 SHORT $L23209

; 1778 : 		return -1;

  043c4	83 c8 ff	 or	 eax, -1
  043c7	e9 2c 01 00 00	 jmp	 $L23203
$L23209:

; 1779 : 
; 1780 : 	if(sb->fButVisibleAfter)

  043cc	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  043cf	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  043d6	74 0f		 je	 SHORT $L23210

; 1781 : 		rightpos -= sb->nButSizeAfter;

  043d8	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  043db	8b 4d f8	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  043de	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  043e4	89 4d f8	 mov	 DWORD PTR _rightpos$[ebp], ecx
$L23210:

; 1782 : 
; 1783 : 	for(i = 0; i < sb->nButtons; i++)

  043e7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  043ee	eb 09		 jmp	 SHORT $L23211
$L23212:
  043f0	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  043f3	83 c2 01	 add	 edx, 1
  043f6	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$L23211:
  043f9	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  043fc	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  043ff	3b 88 2c 03 00
	00		 cmp	 ecx, DWORD PTR [eax+812]
  04405	0f 8d ea 00 00
	00		 jge	 $L23213

; 1784 : 	{
; 1785 : 		if(sb->fButVisibleBefore && sbut[i].uPlacement == SBBP_LEFT)

  0440b	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  0440e	83 ba 38 03 00
	00 00		 cmp	 DWORD PTR [edx+824], 0
  04415	74 69		 je	 SHORT $L23214
  04417	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0441a	6b c0 30	 imul	 eax, 48			; 00000030H
  0441d	8b 4d ec	 mov	 ecx, DWORD PTR _sbut$[ebp]
  04420	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  04425	75 59		 jne	 SHORT $L23214

; 1786 : 		{
; 1787 : 			butwidth = GetSingleButSize(sb, &sbut[i]);

  04427	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0442a	6b d2 30	 imul	 edx, 48			; 00000030H
  0442d	03 55 ec	 add	 edx, DWORD PTR _sbut$[ebp]
  04430	52		 push	 edx
  04431	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04434	50		 push	 eax
  04435	e8 00 00 00 00	 call	 _GetSingleButSize
  0443a	83 c4 08	 add	 esp, 8
  0443d	89 45 f0	 mov	 DWORD PTR _butwidth$[ebp], eax

; 1788 : 			
; 1789 : 			//if the current button is under the specified point
; 1790 : 			if(pt.x >= leftpos && pt.x < leftpos + butwidth)

  04440	8b 4d 10	 mov	 ecx, DWORD PTR _pt$[ebp]
  04443	3b 4d fc	 cmp	 ecx, DWORD PTR _leftpos$[ebp]
  04446	7c 2d		 jl	 SHORT $L23215
  04448	8b 55 fc	 mov	 edx, DWORD PTR _leftpos$[ebp]
  0444b	03 55 f0	 add	 edx, DWORD PTR _butwidth$[ebp]
  0444e	39 55 10	 cmp	 DWORD PTR _pt$[ebp], edx
  04451	7d 22		 jge	 SHORT $L23215

; 1791 : 			{
; 1792 : 				//if the caller wants us to return the rectangle of the button
; 1793 : 				if(fReturnRect)

  04453	83 7d 18 00	 cmp	 DWORD PTR _fReturnRect$[ebp], 0
  04457	74 14		 je	 SHORT $L23216

; 1794 : 				{
; 1795 : 					rect->left  = leftpos;

  04459	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0445c	8b 4d fc	 mov	 ecx, DWORD PTR _leftpos$[ebp]
  0445f	89 08		 mov	 DWORD PTR [eax], ecx

; 1796 : 					rect->right = leftpos + butwidth;

  04461	8b 55 fc	 mov	 edx, DWORD PTR _leftpos$[ebp]
  04464	03 55 f0	 add	 edx, DWORD PTR _butwidth$[ebp]
  04467	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  0446a	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L23216:

; 1797 : 				}
; 1798 : 
; 1799 : 				return i;

  0446d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  04470	e9 83 00 00 00	 jmp	 $L23203
$L23215:

; 1800 : 			}
; 1801 : 
; 1802 : 			leftpos += butwidth;

  04475	8b 4d fc	 mov	 ecx, DWORD PTR _leftpos$[ebp]
  04478	03 4d f0	 add	 ecx, DWORD PTR _butwidth$[ebp]
  0447b	89 4d fc	 mov	 DWORD PTR _leftpos$[ebp], ecx

; 1803 : 		}
; 1804 : 		else if(sb->fButVisibleAfter && sbut[i].uPlacement == SBBP_RIGHT)

  0447e	eb 70		 jmp	 SHORT $L23217
$L23214:
  04480	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04483	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  0448a	74 64		 je	 SHORT $L23217
  0448c	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0448f	6b c0 30	 imul	 eax, 48			; 00000030H
  04492	8b 4d ec	 mov	 ecx, DWORD PTR _sbut$[ebp]
  04495	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0449a	75 54		 jne	 SHORT $L23217

; 1805 : 		{
; 1806 : 			butwidth = GetSingleButSize(sb, &sbut[i]);

  0449c	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0449f	6b d2 30	 imul	 edx, 48			; 00000030H
  044a2	03 55 ec	 add	 edx, DWORD PTR _sbut$[ebp]
  044a5	52		 push	 edx
  044a6	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  044a9	50		 push	 eax
  044aa	e8 00 00 00 00	 call	 _GetSingleButSize
  044af	83 c4 08	 add	 esp, 8
  044b2	89 45 f0	 mov	 DWORD PTR _butwidth$[ebp], eax

; 1807 : 
; 1808 : 			//if the current button is under the specified point
; 1809 : 			if(pt.x >= rightpos && pt.x < rightpos + butwidth)

  044b5	8b 4d 10	 mov	 ecx, DWORD PTR _pt$[ebp]
  044b8	3b 4d f8	 cmp	 ecx, DWORD PTR _rightpos$[ebp]
  044bb	7c 2a		 jl	 SHORT $L23219
  044bd	8b 55 f8	 mov	 edx, DWORD PTR _rightpos$[ebp]
  044c0	03 55 f0	 add	 edx, DWORD PTR _butwidth$[ebp]
  044c3	39 55 10	 cmp	 DWORD PTR _pt$[ebp], edx
  044c6	7d 1f		 jge	 SHORT $L23219

; 1810 : 			{
; 1811 : 				//if the caller wants us to return the rectangle of the button
; 1812 : 				if(fReturnRect)

  044c8	83 7d 18 00	 cmp	 DWORD PTR _fReturnRect$[ebp], 0
  044cc	74 14		 je	 SHORT $L23220

; 1813 : 				{
; 1814 : 					rect->left  = rightpos;

  044ce	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  044d1	8b 4d f8	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  044d4	89 08		 mov	 DWORD PTR [eax], ecx

; 1815 : 					rect->right = rightpos + butwidth;

  044d6	8b 55 f8	 mov	 edx, DWORD PTR _rightpos$[ebp]
  044d9	03 55 f0	 add	 edx, DWORD PTR _butwidth$[ebp]
  044dc	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  044df	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L23220:

; 1816 : 				}
; 1817 : 				return i;

  044e2	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  044e5	eb 11		 jmp	 SHORT $L23203
$L23219:

; 1818 : 			}
; 1819 : 
; 1820 : 			rightpos += butwidth;

  044e7	8b 4d f8	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  044ea	03 4d f0	 add	 ecx, DWORD PTR _butwidth$[ebp]
  044ed	89 4d f8	 mov	 DWORD PTR _rightpos$[ebp], ecx
$L23217:

; 1821 : 		}
; 1822 : 	}

  044f0	e9 fb fe ff ff	 jmp	 $L23212
$L23213:

; 1823 : 
; 1824 : 	return -1;

  044f5	83 c8 ff	 or	 eax, -1
$L23203:

; 1825 : }

  044f8	5e		 pop	 esi
  044f9	83 c4 14	 add	 esp, 20			; 00000014H
  044fc	3b ec		 cmp	 ebp, esp
  044fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04503	8b e5		 mov	 esp, ebp
  04505	5d		 pop	 ebp
  04506	c3		 ret	 0
_GetHorzButtonFromPt ENDP
; Function compile flags: /Odt /RTCsu
_temp$ = -8						; size = 4
_ret$ = -4						; size = 4
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_pt$ = 16						; size = 8
_fReturnRect$ = 24					; size = 4
_GetVertButtonFromPt PROC NEAR

; 1829 : {

  04510	55		 push	 ebp
  04511	8b ec		 mov	 ebp, esp
  04513	83 ec 08	 sub	 esp, 8
  04516	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0451d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1830 : 	UINT ret;
; 1831 : 	int temp;
; 1832 : 	
; 1833 : 	//swap the X/Y coords
; 1834 : 	temp = pt.x;

  04524	8b 45 10	 mov	 eax, DWORD PTR _pt$[ebp]
  04527	89 45 f8	 mov	 DWORD PTR _temp$[ebp], eax

; 1835 : 	pt.x = pt.y;

  0452a	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  0452d	89 4d 10	 mov	 DWORD PTR _pt$[ebp], ecx

; 1836 : 	pt.y = temp;

  04530	8b 55 f8	 mov	 edx, DWORD PTR _temp$[ebp]
  04533	89 55 14	 mov	 DWORD PTR _pt$[ebp+4], edx

; 1837 : 
; 1838 : 	//swap the rectangle
; 1839 : 	RotateRect(rect);

  04536	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  04539	50		 push	 eax
  0453a	e8 00 00 00 00	 call	 _RotateRect@4

; 1840 : 	
; 1841 : 	ret = GetHorzButtonFromPt(sb, rect, pt, fReturnRect);

  0453f	8b 4d 18	 mov	 ecx, DWORD PTR _fReturnRect$[ebp]
  04542	51		 push	 ecx
  04543	8b 55 14	 mov	 edx, DWORD PTR _pt$[ebp+4]
  04546	52		 push	 edx
  04547	8b 45 10	 mov	 eax, DWORD PTR _pt$[ebp]
  0454a	50		 push	 eax
  0454b	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  0454e	51		 push	 ecx
  0454f	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04552	52		 push	 edx
  04553	e8 00 00 00 00	 call	 _GetHorzButtonFromPt
  04558	83 c4 14	 add	 esp, 20			; 00000014H
  0455b	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 1842 : 
; 1843 : 	RotateRect(rect);

  0455e	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  04561	50		 push	 eax
  04562	e8 00 00 00 00	 call	 _RotateRect@4

; 1844 : 	return ret;

  04567	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 1845 : }

  0456a	83 c4 08	 add	 esp, 8
  0456d	3b ec		 cmp	 ebp, esp
  0456f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04574	8b e5		 mov	 esp, ebp
  04576	5d		 pop	 ebp
  04577	c3		 ret	 0
_GetVertButtonFromPt ENDP
_TEXT	ENDS
EXTRN	__imp__GetMessagePos@0:NEAR
EXTRN	__imp__ReleaseCapture@0:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv82 = -88						; size = 4
_cmdid$23369 = -84					; size = 4
_sbut$23368 = -80					; size = 4
_sb$23354 = -76						; size = 4
_buttonIdx$ = -72					; size = 4
_winrect$ = -64						; size = 16
_pt$ = -40						; size = 8
_hdc$ = -28						; size = 4
_rect$ = -20						; size = 16
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_LButtonUp PROC NEAR

; 2116 : {

  04580	55		 push	 ebp
  04581	8b ec		 mov	 ebp, esp
  04583	83 ec 58	 sub	 esp, 88			; 00000058H
  04586	56		 push	 esi
  04587	57		 push	 edi
  04588	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0458b	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  04590	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  04595	f3 ab		 rep stosd

; 2117 : 	RECT rect;
; 2118 : 	//UINT thisportion;
; 2119 : 	HDC hdc;
; 2120 : 	POINT pt;
; 2121 : 	RECT winrect;
; 2122 : 	UINT buttonIdx = 0;

  04597	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _buttonIdx$[ebp], 0

; 2123 : 	
; 2124 : 	//current scrollportion is the button that we clicked down on
; 2125 : 	if(uCurrentScrollPortion != HTSCROLL_NONE)

  0459e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _uCurrentScrollPortion, -1
  045a5	0f 84 43 03 00
	00		 je	 $L23384

; 2126 : 	{
; 2127 : 		SCROLLBAR *sb = &sw->sbarHorz;

  045ab	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  045ae	83 c0 08	 add	 eax, 8
  045b1	89 45 b4	 mov	 DWORD PTR _sb$23354[ebp], eax

; 2128 : 		lParam = GetMessagePos();

  045b4	8b f4		 mov	 esi, esp
  045b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  045bc	3b f4		 cmp	 esi, esp
  045be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  045c3	89 45 14	 mov	 DWORD PTR _lParam$[ebp], eax

; 2129 : 		ReleaseCapture();

  045c6	8b f4		 mov	 esi, esp
  045c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseCapture@0
  045ce	3b f4		 cmp	 esi, esp
  045d0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2130 : 
; 2131 : 		GetWindowRect(hwnd, &winrect);

  045d5	8b f4		 mov	 esi, esp
  045d7	8d 4d c0	 lea	 ecx, DWORD PTR _winrect$[ebp]
  045da	51		 push	 ecx
  045db	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  045de	52		 push	 edx
  045df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  045e5	3b f4		 cmp	 esi, esp
  045e7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2132 : 		pt.x = LOWORD(lParam);

  045ec	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  045ef	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  045f4	0f b7 c8	 movzx	 ecx, ax
  045f7	89 4d d8	 mov	 DWORD PTR _pt$[ebp], ecx

; 2133 : 		pt.y = HIWORD(lParam);

  045fa	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  045fd	c1 ea 10	 shr	 edx, 16			; 00000010H
  04600	0f b7 c2	 movzx	 eax, dx
  04603	89 45 dc	 mov	 DWORD PTR _pt$[ebp+4], eax

; 2134 : 
; 2135 : 		//emulate the mouse input on a scrollbar here...
; 2136 : 		if(uCurrentScrollbar == SB_HORZ)

  04606	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  0460d	75 1f		 jne	 SHORT $L23359

; 2137 : 		{
; 2138 : 			//get the total area of the normal Horz scrollbar area
; 2139 : 			sb = &sw->sbarHorz;

  0460f	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04612	83 c1 08	 add	 ecx, 8
  04615	89 4d b4	 mov	 DWORD PTR _sb$23354[ebp], ecx

; 2140 : 			GetHScrollRect(sw, hwnd, &rect);

  04618	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  0461b	52		 push	 edx
  0461c	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0461f	50		 push	 eax
  04620	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04623	51		 push	 ecx
  04624	e8 00 00 00 00	 call	 _GetHScrollRect
  04629	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2141 : 		}
; 2142 : 		else if(uCurrentScrollbar == SB_VERT)

  0462c	eb 29		 jmp	 SHORT $L23360
$L23359:
  0462e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uCurrentScrollbar, 1
  04635	75 20		 jne	 SHORT $L23360

; 2143 : 		{
; 2144 : 			//get the total area of the normal Horz scrollbar area
; 2145 : 			sb = &sw->sbarVert;

  04637	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0463a	81 c2 54 03 00
	00		 add	 edx, 852		; 00000354H
  04640	89 55 b4	 mov	 DWORD PTR _sb$23354[ebp], edx

; 2146 : 			GetVScrollRect(sw, hwnd, &rect);

  04643	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  04646	50		 push	 eax
  04647	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0464a	51		 push	 ecx
  0464b	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0464e	52		 push	 edx
  0464f	e8 00 00 00 00	 call	 _GetVScrollRect
  04654	83 c4 0c	 add	 esp, 12			; 0000000cH
$L23360:

; 2147 : 		}
; 2148 : 
; 2149 : 		//we need to do different things depending on if the
; 2150 : 		//user is activating the scrollbar itself, or one of
; 2151 : 		//the inserted buttons
; 2152 : 		switch(uCurrentScrollPortion)

  04657	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentScrollPortion
  0465c	89 45 a8	 mov	 DWORD PTR tv82[ebp], eax
  0465f	81 7d a8 80 00
	00 00		 cmp	 DWORD PTR tv82[ebp], 128 ; 00000080H
  04666	77 2c		 ja	 SHORT $L24011
  04668	81 7d a8 80 00
	00 00		 cmp	 DWORD PTR tv82[ebp], 128 ; 00000080H
  0466f	74 32		 je	 SHORT $L23366
  04671	83 7d a8 00	 cmp	 DWORD PTR tv82[ebp], 0
  04675	0f 82 3d 02 00
	00		 jb	 $L23363
  0467b	83 7d a8 03	 cmp	 DWORD PTR tv82[ebp], 3
  0467f	0f 86 59 01 00
	00		 jbe	 $L23381
  04685	83 7d a8 05	 cmp	 DWORD PTR tv82[ebp], 5
  04689	0f 84 69 01 00
	00		 je	 $L23382
  0468f	e9 24 02 00 00	 jmp	 $L23363
$L24011:
  04694	83 7d a8 ff	 cmp	 DWORD PTR tv82[ebp], -1
  04698	0f 84 40 01 00
	00		 je	 $L23381
  0469e	e9 15 02 00 00	 jmp	 $L23363
$L23366:

; 2153 : 		{
; 2154 : #ifdef INCLUDE_BUTTONS
; 2155 : 		//inserted buttons are being clicked
; 2156 : 		case HTSCROLL_INSERTED:
; 2157 : 			
; 2158 : 			//get the rectangle of the ACTIVE button 
; 2159 : 			buttonIdx = GetButtonFromPt(sb, &rect, pt, FALSE);

  046a3	6a 00		 push	 0
  046a5	8b 4d dc	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  046a8	51		 push	 ecx
  046a9	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp]
  046ac	52		 push	 edx
  046ad	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  046b0	50		 push	 eax
  046b1	8b 4d b4	 mov	 ecx, DWORD PTR _sb$23354[ebp]
  046b4	51		 push	 ecx
  046b5	e8 00 00 00 00	 call	 _GetButtonFromPt
  046ba	83 c4 14	 add	 esp, 20			; 00000014H
  046bd	89 45 b8	 mov	 DWORD PTR _buttonIdx$[ebp], eax

; 2160 : 			GetButtonRectFromId(sb, &rect, uCurrentButton);

  046c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  046c6	52		 push	 edx
  046c7	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  046ca	50		 push	 eax
  046cb	8b 4d b4	 mov	 ecx, DWORD PTR _sb$23354[ebp]
  046ce	51		 push	 ecx
  046cf	e8 00 00 00 00	 call	 _GetButtonRectFromId
  046d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2161 : 	
; 2162 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  046d7	8b 55 c4	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  046da	f7 da		 neg	 edx
  046dc	8b f4		 mov	 esi, esp
  046de	52		 push	 edx
  046df	8b 45 c0	 mov	 eax, DWORD PTR _winrect$[ebp]
  046e2	f7 d8		 neg	 eax
  046e4	50		 push	 eax
  046e5	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  046e8	51		 push	 ecx
  046e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  046ef	3b f4		 cmp	 esi, esp
  046f1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2163 : 
; 2164 : 			//Send the notification BEFORE we redraw, so the
; 2165 : 			//bitmap can be changed smoothly by the user if they require
; 2166 : 			if(uCurrentButton == buttonIdx)

  046f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  046fc	3b 55 b8	 cmp	 edx, DWORD PTR _buttonIdx$[ebp]
  046ff	0f 85 85 00 00
	00		 jne	 $L23367

; 2167 : 			{
; 2168 : 				SCROLLBUT *sbut = &sb->sbButtons[buttonIdx];

  04705	8b 45 b8	 mov	 eax, DWORD PTR _buttonIdx$[ebp]
  04708	6b c0 30	 imul	 eax, 48			; 00000030H
  0470b	8b 4d b4	 mov	 ecx, DWORD PTR _sb$23354[ebp]
  0470e	8d 54 01 2c	 lea	 edx, DWORD PTR [ecx+eax+44]
  04712	89 55 b0	 mov	 DWORD PTR _sbut$23368[ebp], edx

; 2169 : 				UINT cmdid = sbut->uCmdId;

  04715	8b 45 b0	 mov	 eax, DWORD PTR _sbut$23368[ebp]
  04718	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0471b	89 4d ac	 mov	 DWORD PTR _cmdid$23369[ebp], ecx

; 2170 : 				
; 2171 : 				if((sbut->uButType & SBBT_MASK) == SBBT_TOGGLEBUTTON)

  0471e	8b 55 b0	 mov	 edx, DWORD PTR _sbut$23368[ebp]
  04721	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  04724	83 e0 1f	 and	 eax, 31			; 0000001fH
  04727	83 f8 02	 cmp	 eax, 2
  0472a	75 0f		 jne	 SHORT $L23370

; 2172 : 					sbut->uState ^= 1;

  0472c	8b 4d b0	 mov	 ecx, DWORD PTR _sbut$23368[ebp]
  0472f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  04732	83 f2 01	 xor	 edx, 1
  04735	8b 45 b0	 mov	 eax, DWORD PTR _sbut$23368[ebp]
  04738	89 50 10	 mov	 DWORD PTR [eax+16], edx
$L23370:

; 2173 : 
; 2174 : 				//send a notify??				
; 2175 : 				//only post a message if the command id is valid
; 2176 : 				if(cmdid != -1 && cmdid > 0)

  0473b	83 7d ac ff	 cmp	 DWORD PTR _cmdid$23369[ebp], -1
  0473f	74 33		 je	 SHORT $L23371
  04741	83 7d ac 00	 cmp	 DWORD PTR _cmdid$23369[ebp], 0
  04745	76 2d		 jbe	 SHORT $L23371

; 2177 : 					SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(cmdid, CSBN_CLICKED), 0);

  04747	8b f4		 mov	 esi, esp
  04749	6a 00		 push	 0
  0474b	8b 4d ac	 mov	 ecx, DWORD PTR _cmdid$23369[ebp]
  0474e	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  04754	0f b7 d1	 movzx	 edx, cx
  04757	81 ca 00 00 01
	00		 or	 edx, 65536		; 00010000H
  0475d	52		 push	 edx
  0475e	68 11 01 00 00	 push	 273			; 00000111H
  04763	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04766	50		 push	 eax
  04767	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0476d	3b f4		 cmp	 esi, esp
  0476f	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23371:

; 2178 : 			
; 2179 : 				//user might have deleted this button, so redraw whole area
; 2180 : 				NCPaint(sw, hwnd, 1, 0);

  04774	6a 00		 push	 0
  04776	6a 01		 push	 1
  04778	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0477b	51		 push	 ecx
  0477c	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0477f	52		 push	 edx
  04780	e8 00 00 00 00	 call	 _NCPaint
  04785	83 c4 10	 add	 esp, 16			; 00000010H

; 2181 : 			}
; 2182 : 			else

  04788	eb 4f		 jmp	 SHORT $L23380
$L23367:

; 2183 : 			{
; 2184 : 				//otherwise, just redraw the button in its new state
; 2185 : 				hdc = GetWindowDC(hwnd);

  0478a	8b f4		 mov	 esi, esp
  0478c	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0478f	50		 push	 eax
  04790	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  04796	3b f4		 cmp	 esi, esp
  04798	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0479d	89 45 e4	 mov	 DWORD PTR _hdc$[ebp], eax

; 2186 : 				DrawScrollButton(&sb->sbButtons[uCurrentButton], hdc, &rect, SBBS_NORMAL);

  047a0	6a 00		 push	 0
  047a2	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  047a5	51		 push	 ecx
  047a6	8b 55 e4	 mov	 edx, DWORD PTR _hdc$[ebp]
  047a9	52		 push	 edx
  047aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentButton
  047af	6b c0 30	 imul	 eax, 48			; 00000030H
  047b2	8b 4d b4	 mov	 ecx, DWORD PTR _sb$23354[ebp]
  047b5	8d 54 01 2c	 lea	 edx, DWORD PTR [ecx+eax+44]
  047b9	52		 push	 edx
  047ba	e8 00 00 00 00	 call	 _DrawScrollButton
  047bf	83 c4 10	 add	 esp, 16			; 00000010H

; 2187 : 				ReleaseDC(hwnd, hdc);

  047c2	8b f4		 mov	 esi, esp
  047c4	8b 45 e4	 mov	 eax, DWORD PTR _hdc$[ebp]
  047c7	50		 push	 eax
  047c8	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  047cb	51		 push	 ecx
  047cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  047d2	3b f4		 cmp	 esi, esp
  047d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23380:

; 2188 : 			}
; 2189 : 	
; 2190 : 			break;

  047d9	e9 da 00 00 00	 jmp	 $L23363
$L23381:

; 2191 : #endif	// INCLUDE_BUTTONS
; 2192 : 
; 2193 : 		//The scrollbar is active
; 2194 : 		case HTSCROLL_LEFT:  case HTSCROLL_RIGHT: 
; 2195 : 		case HTSCROLL_PAGELEFT:  case HTSCROLL_PAGERIGHT: 
; 2196 : 		case HTSCROLL_NONE:
; 2197 : 			
; 2198 : 			KillTimer(hwnd, uScrollTimerId);

  047de	8b f4		 mov	 esi, esp
  047e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uScrollTimerId
  047e6	52		 push	 edx
  047e7	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  047ea	50		 push	 eax
  047eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8
  047f1	3b f4		 cmp	 esi, esp
  047f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23382:

; 2199 : 
; 2200 : 		case HTSCROLL_THUMB: 
; 2201 : 	
; 2202 : 			//In case we were thumb tracking, make sure we stop NOW
; 2203 : 			if(sw->fThumbTracking == TRUE)

  047f8	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  047fb	83 b9 a0 06 00
	00 01		 cmp	 DWORD PTR [ecx+1696], 1
  04802	75 28		 jne	 SHORT $L23383

; 2204 : 			{
; 2205 : 				SendScrollMessage(hwnd, uScrollTimerMsg, SB_THUMBPOSITION, nLastPos);

  04804	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nLastPos
  0480a	52		 push	 edx
  0480b	6a 04		 push	 4
  0480d	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerMsg
  04812	50		 push	 eax
  04813	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04816	51		 push	 ecx
  04817	e8 00 00 00 00	 call	 _SendScrollMessage
  0481c	83 c4 10	 add	 esp, 16			; 00000010H

; 2206 : 				sw->fThumbTracking = FALSE;

  0481f	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  04822	c7 82 a0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+1696], 0
$L23383:

; 2207 : 			}
; 2208 : 
; 2209 : 			//send the SB_ENDSCROLL message now that scrolling has finished
; 2210 : 			SendScrollMessage(hwnd, uScrollTimerMsg, SB_ENDSCROLL, 0);

  0482c	6a 00		 push	 0
  0482e	6a 08		 push	 8
  04830	a1 00 00 00 00	 mov	 eax, DWORD PTR _uScrollTimerMsg
  04835	50		 push	 eax
  04836	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04839	51		 push	 ecx
  0483a	e8 00 00 00 00	 call	 _SendScrollMessage
  0483f	83 c4 10	 add	 esp, 16			; 00000010H

; 2211 : 
; 2212 : 			//adjust the total scroll area to become where the scrollbar
; 2213 : 			//really is (take into account the inserted buttons)
; 2214 : 			GetRealScrollRect(sb, &rect);

  04842	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  04845	52		 push	 edx
  04846	8b 45 b4	 mov	 eax, DWORD PTR _sb$23354[ebp]
  04849	50		 push	 eax
  0484a	e8 00 00 00 00	 call	 _GetRealScrollRect
  0484f	83 c4 08	 add	 esp, 8

; 2215 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  04852	8b 4d c4	 mov	 ecx, DWORD PTR _winrect$[ebp+4]
  04855	f7 d9		 neg	 ecx
  04857	8b f4		 mov	 esi, esp
  04859	51		 push	 ecx
  0485a	8b 55 c0	 mov	 edx, DWORD PTR _winrect$[ebp]
  0485d	f7 da		 neg	 edx
  0485f	52		 push	 edx
  04860	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  04863	50		 push	 eax
  04864	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  0486a	3b f4		 cmp	 esi, esp
  0486c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2216 : 			hdc = GetWindowDC(hwnd);

  04871	8b f4		 mov	 esi, esp
  04873	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04876	51		 push	 ecx
  04877	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  0487d	3b f4		 cmp	 esi, esp
  0487f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04884	89 45 e4	 mov	 DWORD PTR _hdc$[ebp], eax

; 2217 : 			
; 2218 : 			//draw whichever scrollbar sb is
; 2219 : 			NCDrawScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_NORMAL);

  04887	6a ff		 push	 -1
  04889	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  0488c	52		 push	 edx
  0488d	8b 45 e4	 mov	 eax, DWORD PTR _hdc$[ebp]
  04890	50		 push	 eax
  04891	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04894	51		 push	 ecx
  04895	8b 55 b4	 mov	 edx, DWORD PTR _sb$23354[ebp]
  04898	52		 push	 edx
  04899	e8 00 00 00 00	 call	 _NCDrawScrollbar
  0489e	83 c4 14	 add	 esp, 20			; 00000014H

; 2220 : 
; 2221 : 			ReleaseDC(hwnd, hdc);

  048a1	8b f4		 mov	 esi, esp
  048a3	8b 45 e4	 mov	 eax, DWORD PTR _hdc$[ebp]
  048a6	50		 push	 eax
  048a7	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  048aa	51		 push	 ecx
  048ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  048b1	3b f4		 cmp	 esi, esp
  048b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23363:

; 2222 : 			break;
; 2223 : 		}
; 2224 : 
; 2225 : 		//reset our state to default
; 2226 : 		uCurrentScrollPortion = HTSCROLL_NONE;

  048b8	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uCurrentScrollPortion, -1

; 2227 : 		uScrollTimerPortion	  = HTSCROLL_NONE;

  048c2	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uScrollTimerPortion, -1

; 2228 : 		uScrollTimerId		  = 0;

  048cc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uScrollTimerId, 0

; 2229 : 
; 2230 : 		uScrollTimerMsg       = 0;

  048d6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uScrollTimerMsg, 0

; 2231 : 		uCurrentScrollbar     = COOLSB_NONE;

  048e0	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uCurrentScrollbar, -1

; 2232 : 
; 2233 : 		return 0;

  048ea	33 c0		 xor	 eax, eax
  048ec	eb 27		 jmp	 SHORT $L23347
$L23384:

; 2234 : 	}
; 2235 : 	else
; 2236 : 	{
; 2237 : 		/*
; 2238 : 		// Can't remember why I did this!
; 2239 : 		if(GetCapture() == hwnd)
; 2240 : 		{
; 2241 : 			ReleaseCapture();
; 2242 : 		}*/
; 2243 : 	}
; 2244 : 
; 2245 : 	return CallWindowProc(sw->oldproc, hwnd, WM_LBUTTONUP, wParam, lParam);

  048ee	8b f4		 mov	 esi, esp
  048f0	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  048f3	52		 push	 edx
  048f4	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  048f7	50		 push	 eax
  048f8	68 02 02 00 00	 push	 514			; 00000202H
  048fd	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04900	51		 push	 ecx
  04901	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  04904	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  04907	50		 push	 eax
  04908	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  0490e	3b f4		 cmp	 esi, esp
  04910	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23347:

; 2246 : }

  04915	52		 push	 edx
  04916	8b cd		 mov	 ecx, ebp
  04918	50		 push	 eax
  04919	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L24016
  0491f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  04924	58		 pop	 eax
  04925	5a		 pop	 edx
  04926	5f		 pop	 edi
  04927	5e		 pop	 esi
  04928	83 c4 58	 add	 esp, 88			; 00000058H
  0492b	3b ec		 cmp	 ebp, esp
  0492d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04932	8b e5		 mov	 esp, ebp
  04934	5d		 pop	 ebp
  04935	c3		 ret	 0
$L24016:
  04936	03 00 00 00	 DD	 3
  0493a	00 00 00 00	 DD	 $L24015
$L24015:
  0493e	ec ff ff ff	 DD	 -20			; ffffffecH
  04942	10 00 00 00	 DD	 16			; 00000010H
  04946	00 00 00 00	 DD	 $L24012
  0494a	d8 ff ff ff	 DD	 -40			; ffffffd8H
  0494e	08 00 00 00	 DD	 8
  04952	00 00 00 00	 DD	 $L24013
  04956	c0 ff ff ff	 DD	 -64			; ffffffc0H
  0495a	10 00 00 00	 DD	 16			; 00000010H
  0495e	00 00 00 00	 DD	 $L24014
$L24014:
  04962	77		 DB	 119			; 00000077H
  04963	69		 DB	 105			; 00000069H
  04964	6e		 DB	 110			; 0000006eH
  04965	72		 DB	 114			; 00000072H
  04966	65		 DB	 101			; 00000065H
  04967	63		 DB	 99			; 00000063H
  04968	74		 DB	 116			; 00000074H
  04969	00		 DB	 0
$L24013:
  0496a	70		 DB	 112			; 00000070H
  0496b	74		 DB	 116			; 00000074H
  0496c	00		 DB	 0
$L24012:
  0496d	72		 DB	 114			; 00000072H
  0496e	65		 DB	 101			; 00000065H
  0496f	63		 DB	 99			; 00000063H
  04970	74		 DB	 116			; 00000074H
  04971	00		 DB	 0
_LButtonUp ENDP
; Function compile flags: /Odt /RTCsu
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_index$ = 16						; size = 4
_GetButtonRectFromId PROC NEAR

; 1912 : {

  04980	55		 push	 ebp
  04981	8b ec		 mov	 ebp, esp

; 1913 : 	if(sb->nBarType == SB_HORZ)

  04983	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04986	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0498d	75 16		 jne	 SHORT $L23283

; 1914 : 	{
; 1915 : 		return GetHorzButtonRectFromId(sb, rect, index);

  0498f	8b 4d 10	 mov	 ecx, DWORD PTR _index$[ebp]
  04992	51		 push	 ecx
  04993	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  04996	52		 push	 edx
  04997	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  0499a	50		 push	 eax
  0499b	e8 00 00 00 00	 call	 _GetHorzButtonRectFromId
  049a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  049a3	eb 14		 jmp	 SHORT $L23282
$L23283:

; 1916 : 	}
; 1917 : 	else
; 1918 : 	{
; 1919 : 		return GetVertButtonRectFromId(sb, rect, index);

  049a5	8b 4d 10	 mov	 ecx, DWORD PTR _index$[ebp]
  049a8	51		 push	 ecx
  049a9	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  049ac	52		 push	 edx
  049ad	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  049b0	50		 push	 eax
  049b1	e8 00 00 00 00	 call	 _GetVertButtonRectFromId
  049b6	83 c4 0c	 add	 esp, 12			; 0000000cH
$L23282:

; 1920 : 	}
; 1921 : }

  049b9	3b ec		 cmp	 ebp, esp
  049bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  049c0	5d		 pop	 ebp
  049c1	c3		 ret	 0
_GetButtonRectFromId ENDP
; Function compile flags: /Odt /RTCsu
_rightpos$ = -16					; size = 4
_leftpos$ = -12						; size = 4
_sbut$ = -8						; size = 4
_i$ = -4						; size = 4
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_index$ = 16						; size = 4
_GetHorzButtonRectFromId PROC NEAR

; 1866 : {

  049d0	55		 push	 ebp
  049d1	8b ec		 mov	 ebp, esp
  049d3	83 ec 10	 sub	 esp, 16			; 00000010H
  049d6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  049db	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  049de	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  049e1	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  049e4	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 1867 : 	UINT i;
; 1868 : 	SCROLLBUT *sbut = sb->sbButtons;

  049e7	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  049ea	83 c0 2c	 add	 eax, 44			; 0000002cH
  049ed	89 45 f8	 mov	 DWORD PTR _sbut$[ebp], eax

; 1869 : 	int leftpos = rect->left, rightpos = rect->right;

  049f0	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  049f3	8b 11		 mov	 edx, DWORD PTR [ecx]
  049f5	89 55 f4	 mov	 DWORD PTR _leftpos$[ebp], edx
  049f8	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  049fb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  049fe	89 4d f0	 mov	 DWORD PTR _rightpos$[ebp], ecx

; 1870 : 
; 1871 : 	if(sb->fButVisibleAfter)

  04a01	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04a04	83 ba 3c 03 00
	00 00		 cmp	 DWORD PTR [edx+828], 0
  04a0b	74 0f		 je	 SHORT $L23257

; 1872 : 		rightpos -= sb->nButSizeAfter;

  04a0d	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04a10	8b 4d f0	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  04a13	2b 88 34 03 00
	00		 sub	 ecx, DWORD PTR [eax+820]
  04a19	89 4d f0	 mov	 DWORD PTR _rightpos$[ebp], ecx
$L23257:

; 1873 : 
; 1874 : 	//find the particular button in question
; 1875 : 	for(i = 0; i < index; i++)

  04a1c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  04a23	eb 09		 jmp	 SHORT $L23258
$L23259:
  04a25	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  04a28	83 c2 01	 add	 edx, 1
  04a2b	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$L23258:
  04a2e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  04a31	3b 45 10	 cmp	 eax, DWORD PTR _index$[ebp]
  04a34	73 77		 jae	 SHORT $L23260

; 1876 : 	{
; 1877 : 		if(sb->fButVisibleBefore && sbut[i].uPlacement == SBBP_LEFT)

  04a36	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  04a39	83 b9 38 03 00
	00 00		 cmp	 DWORD PTR [ecx+824], 0
  04a40	74 2e		 je	 SHORT $L23261
  04a42	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  04a45	6b d2 30	 imul	 edx, 48			; 00000030H
  04a48	8b 45 f8	 mov	 eax, DWORD PTR _sbut$[ebp]
  04a4b	83 7c 10 04 01	 cmp	 DWORD PTR [eax+edx+4], 1
  04a50	75 1e		 jne	 SHORT $L23261

; 1878 : 		{
; 1879 : 			leftpos += GetSingleButSize(sb, &sbut[i]);

  04a52	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  04a55	6b c9 30	 imul	 ecx, 48			; 00000030H
  04a58	03 4d f8	 add	 ecx, DWORD PTR _sbut$[ebp]
  04a5b	51		 push	 ecx
  04a5c	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  04a5f	52		 push	 edx
  04a60	e8 00 00 00 00	 call	 _GetSingleButSize
  04a65	83 c4 08	 add	 esp, 8
  04a68	03 45 f4	 add	 eax, DWORD PTR _leftpos$[ebp]
  04a6b	89 45 f4	 mov	 DWORD PTR _leftpos$[ebp], eax

; 1880 : 		}
; 1881 : 		else if(sb->fButVisibleAfter && sbut[i].uPlacement == SBBP_RIGHT)

  04a6e	eb 38		 jmp	 SHORT $L23262
$L23261:
  04a70	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04a73	83 b8 3c 03 00
	00 00		 cmp	 DWORD PTR [eax+828], 0
  04a7a	74 2c		 je	 SHORT $L23262
  04a7c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  04a7f	6b c9 30	 imul	 ecx, 48			; 00000030H
  04a82	8b 55 f8	 mov	 edx, DWORD PTR _sbut$[ebp]
  04a85	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  04a8a	75 1c		 jne	 SHORT $L23262

; 1882 : 		{
; 1883 : 			rightpos += GetSingleButSize(sb, &sbut[i]);

  04a8c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  04a8f	6b c0 30	 imul	 eax, 48			; 00000030H
  04a92	03 45 f8	 add	 eax, DWORD PTR _sbut$[ebp]
  04a95	50		 push	 eax
  04a96	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  04a99	51		 push	 ecx
  04a9a	e8 00 00 00 00	 call	 _GetSingleButSize
  04a9f	83 c4 08	 add	 esp, 8
  04aa2	03 45 f0	 add	 eax, DWORD PTR _rightpos$[ebp]
  04aa5	89 45 f0	 mov	 DWORD PTR _rightpos$[ebp], eax
$L23262:

; 1884 : 		}
; 1885 : 	}

  04aa8	e9 78 ff ff ff	 jmp	 $L23259
$L23260:

; 1886 : 
; 1887 : 	//now return the rectangle
; 1888 : 	if(sbut[i].uPlacement == SBBP_LEFT)

  04aad	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  04ab0	6b d2 30	 imul	 edx, 48			; 00000030H
  04ab3	8b 45 f8	 mov	 eax, DWORD PTR _sbut$[ebp]
  04ab6	83 7c 10 04 01	 cmp	 DWORD PTR [eax+edx+4], 1
  04abb	75 29		 jne	 SHORT $L23264

; 1889 : 	{
; 1890 : 		rect->left  = leftpos;

  04abd	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  04ac0	8b 55 f4	 mov	 edx, DWORD PTR _leftpos$[ebp]
  04ac3	89 11		 mov	 DWORD PTR [ecx], edx

; 1891 : 		rect->right = leftpos + GetSingleButSize(sb, &sbut[i]);

  04ac5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  04ac8	6b c0 30	 imul	 eax, 48			; 00000030H
  04acb	03 45 f8	 add	 eax, DWORD PTR _sbut$[ebp]
  04ace	50		 push	 eax
  04acf	8b 4d 08	 mov	 ecx, DWORD PTR _sb$[ebp]
  04ad2	51		 push	 ecx
  04ad3	e8 00 00 00 00	 call	 _GetSingleButSize
  04ad8	83 c4 08	 add	 esp, 8
  04adb	03 45 f4	 add	 eax, DWORD PTR _leftpos$[ebp]
  04ade	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  04ae1	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1892 : 	}
; 1893 : 	else

  04ae4	eb 27		 jmp	 SHORT $L23265
$L23264:

; 1894 : 	{
; 1895 : 		rect->left  = rightpos;

  04ae6	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  04ae9	8b 4d f0	 mov	 ecx, DWORD PTR _rightpos$[ebp]
  04aec	89 08		 mov	 DWORD PTR [eax], ecx

; 1896 : 		rect->right = rightpos + GetSingleButSize(sb, &sbut[i]);

  04aee	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  04af1	6b d2 30	 imul	 edx, 48			; 00000030H
  04af4	03 55 f8	 add	 edx, DWORD PTR _sbut$[ebp]
  04af7	52		 push	 edx
  04af8	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04afb	50		 push	 eax
  04afc	e8 00 00 00 00	 call	 _GetSingleButSize
  04b01	83 c4 08	 add	 esp, 8
  04b04	03 45 f0	 add	 eax, DWORD PTR _rightpos$[ebp]
  04b07	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  04b0a	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$L23265:

; 1897 : 	}
; 1898 : 
; 1899 : 	return 0;

  04b0d	33 c0		 xor	 eax, eax

; 1900 : }

  04b0f	83 c4 10	 add	 esp, 16			; 00000010H
  04b12	3b ec		 cmp	 ebp, esp
  04b14	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04b19	8b e5		 mov	 esp, ebp
  04b1b	5d		 pop	 ebp
  04b1c	c3		 ret	 0
_GetHorzButtonRectFromId ENDP
; Function compile flags: /Odt /RTCsu
_ret$ = -4						; size = 4
_sb$ = 8						; size = 4
_rect$ = 12						; size = 4
_index$ = 16						; size = 4
_GetVertButtonRectFromId PROC NEAR

; 1903 : {

  04b20	55		 push	 ebp
  04b21	8b ec		 mov	 ebp, esp
  04b23	51		 push	 ecx
  04b24	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 1904 : 	UINT ret;
; 1905 : 	RotateRect(rect);

  04b2b	8b 45 0c	 mov	 eax, DWORD PTR _rect$[ebp]
  04b2e	50		 push	 eax
  04b2f	e8 00 00 00 00	 call	 _RotateRect@4

; 1906 : 	ret = GetHorzButtonRectFromId(sb, rect, index);

  04b34	8b 4d 10	 mov	 ecx, DWORD PTR _index$[ebp]
  04b37	51		 push	 ecx
  04b38	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp]
  04b3b	52		 push	 edx
  04b3c	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  04b3f	50		 push	 eax
  04b40	e8 00 00 00 00	 call	 _GetHorzButtonRectFromId
  04b45	83 c4 0c	 add	 esp, 12			; 0000000cH
  04b48	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 1907 : 	RotateRect(rect);

  04b4b	8b 4d 0c	 mov	 ecx, DWORD PTR _rect$[ebp]
  04b4e	51		 push	 ecx
  04b4f	e8 00 00 00 00	 call	 _RotateRect@4

; 1908 : 	return ret;

  04b54	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 1909 : }

  04b57	83 c4 04	 add	 esp, 4
  04b5a	3b ec		 cmp	 ebp, esp
  04b5c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04b61	8b e5		 mov	 esp, ebp
  04b63	5d		 pop	 ebp
  04b64	c3		 ret	 0
_GetVertButtonRectFromId ENDP
; Function compile flags: /Odt /RTCsu
tv152 = -140						; size = 4
_scrollsize$23487 = -136				; size = 4
_rect2$23486 = -128					; size = 16
_butsize2$23485 = -108					; size = 4
_butsize1$23484 = -104					; size = 4
_oldsize$23483 = -100					; size = 4
_sbut$23468 = -96					; size = 4
_sb$23467 = -92						; size = 4
_nlParam$23466 = -88					; size = 4
_y$23456 = -84						; size = 4
_x$23455 = -80						; size = 4
_buttonIdx$ = -76					; size = 4
_winrect$ = -68						; size = 16
_pt$ = -44						; size = 8
_hdc$ = -32						; size = 4
_thisportion$ = -28					; size = 4
_rect$ = -20						; size = 16
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MouseMove PROC NEAR

; 2398 : {

  04b70	55		 push	 ebp
  04b71	8b ec		 mov	 ebp, esp
  04b73	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  04b79	56		 push	 esi
  04b7a	57		 push	 edi
  04b7b	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  04b81	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  04b86	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  04b8b	f3 ab		 rep stosd

; 2399 : 	RECT rect;
; 2400 : 	UINT thisportion;
; 2401 : 	HDC hdc;
; 2402 : 	static UINT lastportion = 0;
; 2403 : 	static UINT lastbutton = 0;
; 2404 : 	POINT pt;
; 2405 : 	RECT winrect;
; 2406 : 	UINT buttonIdx = 0;

  04b8d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _buttonIdx$[ebp], 0

; 2407 : 
; 2408 : 	if(sw->fThumbTracking == TRUE)

  04b94	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  04b97	83 b8 a0 06 00
	00 01		 cmp	 DWORD PTR [eax+1696], 1
  04b9e	0f 85 81 00 00
	00		 jne	 $L23454

; 2409 : 	{
; 2410 : 		int x, y;
; 2411 : 		lParam = GetMessagePos();

  04ba4	8b f4		 mov	 esi, esp
  04ba6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  04bac	3b f4		 cmp	 esi, esp
  04bae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04bb3	89 45 14	 mov	 DWORD PTR _lParam$[ebp], eax

; 2412 : 		x = LOWORD(lParam);

  04bb6	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  04bb9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  04bbf	0f b7 d1	 movzx	 edx, cx
  04bc2	89 55 b0	 mov	 DWORD PTR _x$23455[ebp], edx

; 2413 : 		y = HIWORD(lParam);

  04bc5	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  04bc8	c1 e8 10	 shr	 eax, 16			; 00000010H
  04bcb	0f b7 c8	 movzx	 ecx, ax
  04bce	89 4d ac	 mov	 DWORD PTR _y$23456[ebp], ecx

; 2414 : 
; 2415 : 		if(uCurrentScrollbar == SB_HORZ)

  04bd1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  04bd8	75 20		 jne	 SHORT $L23461

; 2416 : 			return ThumbTrackHorz(&sw->sbarHorz, hwnd, x,y);

  04bda	8b 55 ac	 mov	 edx, DWORD PTR _y$23456[ebp]
  04bdd	52		 push	 edx
  04bde	8b 45 b0	 mov	 eax, DWORD PTR _x$23455[ebp]
  04be1	50		 push	 eax
  04be2	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04be5	51		 push	 ecx
  04be6	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  04be9	83 c2 08	 add	 edx, 8
  04bec	52		 push	 edx
  04bed	e8 00 00 00 00	 call	 _ThumbTrackHorz
  04bf2	83 c4 10	 add	 esp, 16			; 00000010H
  04bf5	e9 19 05 00 00	 jmp	 $L23443
$L23461:

; 2417 : 
; 2418 : 
; 2419 : 		else if(uCurrentScrollbar == SB_VERT)

  04bfa	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uCurrentScrollbar, 1
  04c01	75 22		 jne	 SHORT $L23454

; 2420 : 			return ThumbTrackVert(&sw->sbarVert, hwnd, x,y);

  04c03	8b 45 ac	 mov	 eax, DWORD PTR _y$23456[ebp]
  04c06	50		 push	 eax
  04c07	8b 4d b0	 mov	 ecx, DWORD PTR _x$23455[ebp]
  04c0a	51		 push	 ecx
  04c0b	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04c0e	52		 push	 edx
  04c0f	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  04c12	05 54 03 00 00	 add	 eax, 852		; 00000354H
  04c17	50		 push	 eax
  04c18	e8 00 00 00 00	 call	 _ThumbTrackVert
  04c1d	83 c4 10	 add	 esp, 16			; 00000010H
  04c20	e9 ee 04 00 00	 jmp	 $L23443
$L23454:

; 2421 : 	}
; 2422 : 
; 2423 : 	if(uCurrentScrollPortion == HTSCROLL_NONE)

  04c25	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _uCurrentScrollPortion, -1
  04c2c	75 2c		 jne	 SHORT $L23464

; 2424 : 	{
; 2425 : 		return CallWindowProc(sw->oldproc, hwnd, WM_MOUSEMOVE, wParam, lParam);

  04c2e	8b f4		 mov	 esi, esp
  04c30	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  04c33	51		 push	 ecx
  04c34	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  04c37	52		 push	 edx
  04c38	68 00 02 00 00	 push	 512			; 00000200H
  04c3d	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04c40	50		 push	 eax
  04c41	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04c44	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  04c47	52		 push	 edx
  04c48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  04c4e	3b f4		 cmp	 esi, esp
  04c50	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04c55	e9 b9 04 00 00	 jmp	 $L23443
$L23464:

; 2426 : 	}
; 2427 : 	else
; 2428 : 	{
; 2429 : 		LPARAM nlParam;
; 2430 : 		SCROLLBAR *sb = &sw->sbarHorz;

  04c5a	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  04c5d	83 c0 08	 add	 eax, 8
  04c60	89 45 a4	 mov	 DWORD PTR _sb$23467[ebp], eax

; 2431 : 		SCROLLBUT *sbut = 0;

  04c63	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _sbut$23468[ebp], 0

; 2432 : 
; 2433 : 		nlParam = GetMessagePos();

  04c6a	8b f4		 mov	 esi, esp
  04c6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  04c72	3b f4		 cmp	 esi, esp
  04c74	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04c79	89 45 a8	 mov	 DWORD PTR _nlParam$23466[ebp], eax

; 2434 : 
; 2435 : 		GetWindowRect(hwnd, &winrect);

  04c7c	8b f4		 mov	 esi, esp
  04c7e	8d 4d bc	 lea	 ecx, DWORD PTR _winrect$[ebp]
  04c81	51		 push	 ecx
  04c82	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04c85	52		 push	 edx
  04c86	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  04c8c	3b f4		 cmp	 esi, esp
  04c8e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2436 : 
; 2437 : 		pt.x = LOWORD(nlParam);

  04c93	8b 45 a8	 mov	 eax, DWORD PTR _nlParam$23466[ebp]
  04c96	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  04c9b	0f b7 c8	 movzx	 ecx, ax
  04c9e	89 4d d4	 mov	 DWORD PTR _pt$[ebp], ecx

; 2438 : 		pt.y = HIWORD(nlParam);

  04ca1	8b 55 a8	 mov	 edx, DWORD PTR _nlParam$23466[ebp]
  04ca4	c1 ea 10	 shr	 edx, 16			; 00000010H
  04ca7	0f b7 c2	 movzx	 eax, dx
  04caa	89 45 d8	 mov	 DWORD PTR _pt$[ebp+4], eax

; 2439 : 
; 2440 : 		//emulate the mouse input on a scrollbar here...
; 2441 : 		if(uCurrentScrollbar == SB_HORZ)

  04cad	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  04cb4	75 0b		 jne	 SHORT $L23473

; 2442 : 		{
; 2443 : 			sb = &sw->sbarHorz;

  04cb6	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04cb9	83 c1 08	 add	 ecx, 8
  04cbc	89 4d a4	 mov	 DWORD PTR _sb$23467[ebp], ecx

; 2444 : 		}
; 2445 : 		else if(uCurrentScrollbar == SB_VERT)

  04cbf	eb 15		 jmp	 SHORT $L23474
$L23473:
  04cc1	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uCurrentScrollbar, 1
  04cc8	75 0c		 jne	 SHORT $L23474

; 2446 : 		{
; 2447 : 			sb = &sw->sbarVert;

  04cca	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  04ccd	81 c2 54 03 00
	00		 add	 edx, 852		; 00000354H
  04cd3	89 55 a4	 mov	 DWORD PTR _sb$23467[ebp], edx
$L23474:

; 2448 : 		}
; 2449 : 
; 2450 : 		//get the total area of the normal scrollbar area
; 2451 : 		GetScrollRect(sw, sb->nBarType, hwnd, &rect);

  04cd6	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  04cd9	50		 push	 eax
  04cda	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04cdd	51		 push	 ecx
  04cde	8b 55 a4	 mov	 edx, DWORD PTR _sb$23467[ebp]
  04ce1	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  04ce7	50		 push	 eax
  04ce8	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04ceb	51		 push	 ecx
  04cec	e8 00 00 00 00	 call	 _GetScrollRect
  04cf1	83 c4 10	 add	 esp, 16			; 00000010H

; 2452 : 		
; 2453 : 		//see if we clicked in the inserted buttons / normal scrollbar
; 2454 : 		//thisportion = GetPortion(sb, hwnd, &rect, LOWORD(lParam), HIWORD(lParam));
; 2455 : 		thisportion = GetPortion(sb, hwnd, &rect, pt.x, pt.y);

  04cf4	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  04cf7	52		 push	 edx
  04cf8	8b 45 d4	 mov	 eax, DWORD PTR _pt$[ebp]
  04cfb	50		 push	 eax
  04cfc	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  04cff	51		 push	 ecx
  04d00	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04d03	52		 push	 edx
  04d04	8b 45 a4	 mov	 eax, DWORD PTR _sb$23467[ebp]
  04d07	50		 push	 eax
  04d08	e8 00 00 00 00	 call	 _GetPortion
  04d0d	83 c4 14	 add	 esp, 20			; 00000014H
  04d10	89 45 e4	 mov	 DWORD PTR _thisportion$[ebp], eax

; 2456 : 		
; 2457 : 		//we need to do different things depending on if the
; 2458 : 		//user is activating the scrollbar itself, or one of
; 2459 : 		//the inserted buttons
; 2460 : 		switch(uCurrentScrollPortion)

  04d13	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uCurrentScrollPortion
  04d19	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv152[ebp], ecx
  04d1f	81 bd 74 ff ff
	ff 80 00 00 00	 cmp	 DWORD PTR tv152[ebp], 128 ; 00000080H
  04d29	77 38		 ja	 SHORT $L24021
  04d2b	81 bd 74 ff ff
	ff 80 00 00 00	 cmp	 DWORD PTR tv152[ebp], 128 ; 00000080H
  04d35	74 3e		 je	 SHORT $L23480
  04d37	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR tv152[ebp], 0
  04d3e	0f 82 bc 03 00
	00		 jb	 $L23477
  04d44	83 bd 74 ff ff
	ff 03		 cmp	 DWORD PTR tv152[ebp], 3
  04d4b	0f 86 e6 02 00
	00		 jbe	 $L23504
  04d51	83 bd 74 ff ff
	ff 05		 cmp	 DWORD PTR tv152[ebp], 5
  04d58	0f 84 d9 02 00
	00		 je	 $L23504
  04d5e	e9 9d 03 00 00	 jmp	 $L23477
$L24021:
  04d63	83 bd 74 ff ff
	ff ff		 cmp	 DWORD PTR tv152[ebp], -1
  04d6a	0f 84 c7 02 00
	00		 je	 $L23504
  04d70	e9 8b 03 00 00	 jmp	 $L23477
$L23480:

; 2461 : 		{
; 2462 : #ifdef INCLUDE_BUTTONS
; 2463 : 		//inserted buttons are being clicked
; 2464 : 		case HTSCROLL_INSERTED:
; 2465 : 			
; 2466 : 			//find the index of the button that has been clicked
; 2467 : 			//Don't adjust the rectangle though
; 2468 : 			buttonIdx = GetButtonFromPt(sb, &rect, pt, FALSE);

  04d75	6a 00		 push	 0
  04d77	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  04d7a	52		 push	 edx
  04d7b	8b 45 d4	 mov	 eax, DWORD PTR _pt$[ebp]
  04d7e	50		 push	 eax
  04d7f	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  04d82	51		 push	 ecx
  04d83	8b 55 a4	 mov	 edx, DWORD PTR _sb$23467[ebp]
  04d86	52		 push	 edx
  04d87	e8 00 00 00 00	 call	 _GetButtonFromPt
  04d8c	83 c4 14	 add	 esp, 20			; 00000014H
  04d8f	89 45 b4	 mov	 DWORD PTR _buttonIdx$[ebp], eax

; 2469 : 						
; 2470 : 			//Get the rectangle of the active button
; 2471 : 			GetButtonRectFromId(sb, &rect, uCurrentButton);

  04d92	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentButton
  04d97	50		 push	 eax
  04d98	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  04d9b	51		 push	 ecx
  04d9c	8b 55 a4	 mov	 edx, DWORD PTR _sb$23467[ebp]
  04d9f	52		 push	 edx
  04da0	e8 00 00 00 00	 call	 _GetButtonRectFromId
  04da5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2472 : 
; 2473 : 			//if the button to the LEFT of the current 
; 2474 : 			//button is resizable, then resize it
; 2475 : #ifdef RESIZABLE_BUTTONS
; 2476 : 			if(uCurrentButton > 0)

  04da8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentButton, 0
  04daf	0f 86 89 01 00
	00		 jbe	 $L23481

; 2477 : 			{
; 2478 : 				sbut = &sb->sbButtons[uCurrentButton - 1];

  04db5	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentButton
  04dba	83 e8 01	 sub	 eax, 1
  04dbd	6b c0 30	 imul	 eax, 48			; 00000030H
  04dc0	8b 4d a4	 mov	 ecx, DWORD PTR _sb$23467[ebp]
  04dc3	8d 54 01 2c	 lea	 edx, DWORD PTR [ecx+eax+44]
  04dc7	89 55 a0	 mov	 DWORD PTR _sbut$23468[ebp], edx

; 2479 : 			
; 2480 : 				//only resize if BOTH buttons are on same side of scrollbar
; 2481 : 				if(sbut->uPlacement == (sbut+1)->uPlacement && (sbut->uButType & SBBM_RESIZABLE))

  04dca	8b 45 a0	 mov	 eax, DWORD PTR _sbut$23468[ebp]
  04dcd	8b 4d a0	 mov	 ecx, DWORD PTR _sbut$23468[ebp]
  04dd0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  04dd3	3b 51 34	 cmp	 edx, DWORD PTR [ecx+52]
  04dd6	0f 85 62 01 00
	00		 jne	 $L23481
  04ddc	8b 45 a0	 mov	 eax, DWORD PTR _sbut$23468[ebp]
  04ddf	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  04de2	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  04de8	0f 84 50 01 00
	00		 je	 $L23481

; 2482 : 				{
; 2483 : 					int oldsize = sbut->nSize;

  04dee	8b 55 a0	 mov	 edx, DWORD PTR _sbut$23468[ebp]
  04df1	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  04df4	89 45 9c	 mov	 DWORD PTR _oldsize$23483[ebp], eax

; 2484 : 					int butsize1, butsize2;
; 2485 : 					RECT rect2;
; 2486 : 					int scrollsize;
; 2487 : 
; 2488 : 					if(uCurrentScrollbar == SB_HORZ)

  04df7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  04dfe	75 26		 jne	 SHORT $L23488

; 2489 : 					{
; 2490 : 						rect.left -= GetSingleButSize(sb, sbut);

  04e00	8b 4d a0	 mov	 ecx, DWORD PTR _sbut$23468[ebp]
  04e03	51		 push	 ecx
  04e04	8b 55 a4	 mov	 edx, DWORD PTR _sb$23467[ebp]
  04e07	52		 push	 edx
  04e08	e8 00 00 00 00	 call	 _GetSingleButSize
  04e0d	83 c4 08	 add	 esp, 8
  04e10	8b 4d ec	 mov	 ecx, DWORD PTR _rect$[ebp]
  04e13	2b c8		 sub	 ecx, eax
  04e15	89 4d ec	 mov	 DWORD PTR _rect$[ebp], ecx

; 2491 : 						sbut->nSize = pt.x - rect.left;

  04e18	8b 55 d4	 mov	 edx, DWORD PTR _pt$[ebp]
  04e1b	2b 55 ec	 sub	 edx, DWORD PTR _rect$[ebp]
  04e1e	8b 45 a0	 mov	 eax, DWORD PTR _sbut$23468[ebp]
  04e21	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2492 : 					}
; 2493 : 					else

  04e24	eb 24		 jmp	 SHORT $L23489
$L23488:

; 2494 : 					{
; 2495 : 						rect.top -= GetSingleButSize(sb, sbut);

  04e26	8b 4d a0	 mov	 ecx, DWORD PTR _sbut$23468[ebp]
  04e29	51		 push	 ecx
  04e2a	8b 55 a4	 mov	 edx, DWORD PTR _sb$23467[ebp]
  04e2d	52		 push	 edx
  04e2e	e8 00 00 00 00	 call	 _GetSingleButSize
  04e33	83 c4 08	 add	 esp, 8
  04e36	8b 4d f0	 mov	 ecx, DWORD PTR _rect$[ebp+4]
  04e39	2b c8		 sub	 ecx, eax
  04e3b	89 4d f0	 mov	 DWORD PTR _rect$[ebp+4], ecx

; 2496 : 						sbut->nSize = pt.y - rect.top;

  04e3e	8b 55 d8	 mov	 edx, DWORD PTR _pt$[ebp+4]
  04e41	2b 55 f0	 sub	 edx, DWORD PTR _rect$[ebp+4]
  04e44	8b 45 a0	 mov	 eax, DWORD PTR _sbut$23468[ebp]
  04e47	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L23489:

; 2497 : 					}
; 2498 : 
; 2499 : 					//if(sbut->nSize < 0)	sbut->nSize = 0;
; 2500 : 					if(sbut->nSize < (int)sbut->nMinSize)

  04e4a	8b 4d a0	 mov	 ecx, DWORD PTR _sbut$23468[ebp]
  04e4d	8b 55 a0	 mov	 edx, DWORD PTR _sbut$23468[ebp]
  04e50	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  04e53	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  04e56	7d 0c		 jge	 SHORT $L23491

; 2501 : 						sbut->nSize = sbut->nMinSize;

  04e58	8b 4d a0	 mov	 ecx, DWORD PTR _sbut$23468[ebp]
  04e5b	8b 55 a0	 mov	 edx, DWORD PTR _sbut$23468[ebp]
  04e5e	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  04e61	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23491:

; 2502 : 
; 2503 : 					if((UINT)sbut->nSize > (UINT)sbut->nMaxSize)

  04e64	8b 4d a0	 mov	 ecx, DWORD PTR _sbut$23468[ebp]
  04e67	8b 55 a0	 mov	 edx, DWORD PTR _sbut$23468[ebp]
  04e6a	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  04e6d	3b 42 2c	 cmp	 eax, DWORD PTR [edx+44]
  04e70	76 0c		 jbe	 SHORT $L23494

; 2504 : 						sbut->nSize = sbut->nMaxSize;

  04e72	8b 4d a0	 mov	 ecx, DWORD PTR _sbut$23468[ebp]
  04e75	8b 55 a0	 mov	 edx, DWORD PTR _sbut$23468[ebp]
  04e78	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  04e7b	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23494:

; 2505 : 					
; 2506 : 					GetScrollRect(sw, uCurrentScrollbar, hwnd, &rect2);

  04e7e	8d 4d 80	 lea	 ecx, DWORD PTR _rect2$23486[ebp]
  04e81	51		 push	 ecx
  04e82	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  04e85	52		 push	 edx
  04e86	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentScrollbar
  04e8b	50		 push	 eax
  04e8c	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  04e8f	51		 push	 ecx
  04e90	e8 00 00 00 00	 call	 _GetScrollRect
  04e95	83 c4 10	 add	 esp, 16			; 00000010H

; 2507 : 					
; 2508 : 					if(uCurrentScrollbar == SB_HORZ)

  04e98	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uCurrentScrollbar, 0
  04e9f	75 0e		 jne	 SHORT $L23495

; 2509 : 						scrollsize = rect2.right-rect2.left;

  04ea1	8b 55 88	 mov	 edx, DWORD PTR _rect2$23486[ebp+8]
  04ea4	2b 55 80	 sub	 edx, DWORD PTR _rect2$23486[ebp]
  04ea7	89 95 78 ff ff
	ff		 mov	 DWORD PTR _scrollsize$23487[ebp], edx

; 2510 : 					else

  04ead	eb 0c		 jmp	 SHORT $L23496
$L23495:

; 2511 : 						scrollsize = rect2.bottom-rect2.top;

  04eaf	8b 45 8c	 mov	 eax, DWORD PTR _rect2$23486[ebp+12]
  04eb2	2b 45 84	 sub	 eax, DWORD PTR _rect2$23486[ebp+4]
  04eb5	89 85 78 ff ff
	ff		 mov	 DWORD PTR _scrollsize$23487[ebp], eax
$L23496:

; 2512 : 
; 2513 : 					butsize1 = GetButtonSize(sb, hwnd, SBBP_LEFT);

  04ebb	6a 01		 push	 1
  04ebd	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04ec0	51		 push	 ecx
  04ec1	8b 55 a4	 mov	 edx, DWORD PTR _sb$23467[ebp]
  04ec4	52		 push	 edx
  04ec5	e8 00 00 00 00	 call	 _GetButtonSize
  04eca	83 c4 0c	 add	 esp, 12			; 0000000cH
  04ecd	89 45 98	 mov	 DWORD PTR _butsize1$23484[ebp], eax

; 2514 : 					butsize2 = GetButtonSize(sb, hwnd, SBBP_RIGHT);

  04ed0	6a 02		 push	 2
  04ed2	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04ed5	50		 push	 eax
  04ed6	8b 4d a4	 mov	 ecx, DWORD PTR _sb$23467[ebp]
  04ed9	51		 push	 ecx
  04eda	e8 00 00 00 00	 call	 _GetButtonSize
  04edf	83 c4 0c	 add	 esp, 12			; 0000000cH
  04ee2	89 45 94	 mov	 DWORD PTR _butsize2$23485[ebp], eax

; 2515 : 
; 2516 : 					//adjust the button size if it gets too big
; 2517 : 					if(butsize1 + butsize2 > scrollsize  - MINSCROLLSIZE)

  04ee5	8b 55 98	 mov	 edx, DWORD PTR _butsize1$23484[ebp]
  04ee8	03 55 94	 add	 edx, DWORD PTR _butsize2$23485[ebp]
  04eeb	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _scrollsize$23487[ebp]
  04ef1	83 e8 32	 sub	 eax, 50			; 00000032H
  04ef4	3b d0		 cmp	 edx, eax
  04ef6	7e 1f		 jle	 SHORT $L23497

; 2518 : 					{
; 2519 : 						sbut->nSize -= (butsize1+butsize2) - (scrollsize - MINSCROLLSIZE);

  04ef8	8b 4d 98	 mov	 ecx, DWORD PTR _butsize1$23484[ebp]
  04efb	03 4d 94	 add	 ecx, DWORD PTR _butsize2$23485[ebp]
  04efe	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _scrollsize$23487[ebp]
  04f04	83 ea 32	 sub	 edx, 50			; 00000032H
  04f07	2b ca		 sub	 ecx, edx
  04f09	8b 45 a0	 mov	 eax, DWORD PTR _sbut$23468[ebp]
  04f0c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  04f0f	2b d1		 sub	 edx, ecx
  04f11	8b 45 a0	 mov	 eax, DWORD PTR _sbut$23468[ebp]
  04f14	89 50 14	 mov	 DWORD PTR [eax+20], edx
$L23497:

; 2520 : 					}
; 2521 : 					
; 2522 : 					//remember what size the USER set the button to
; 2523 : 					sbut->nSizeReserved = sbut->nSize;

  04f17	8b 4d a0	 mov	 ecx, DWORD PTR _sbut$23468[ebp]
  04f1a	8b 55 a0	 mov	 edx, DWORD PTR _sbut$23468[ebp]
  04f1d	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  04f20	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 2524 : 					NCPaint(sw, hwnd, (WPARAM)1, (LPARAM)0);

  04f23	6a 00		 push	 0
  04f25	6a 01		 push	 1
  04f27	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  04f2a	51		 push	 ecx
  04f2b	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  04f2e	52		 push	 edx
  04f2f	e8 00 00 00 00	 call	 _NCPaint
  04f34	83 c4 10	 add	 esp, 16			; 00000010H

; 2525 : 					return 0;

  04f37	33 c0		 xor	 eax, eax
  04f39	e9 d5 01 00 00	 jmp	 $L23443
$L23481:

; 2526 : 				}
; 2527 : 			}
; 2528 : #endif	//RESIZABLE_BUTTONS			
; 2529 : 			
; 2530 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  04f3e	8b 45 c0	 mov	 eax, DWORD PTR _winrect$[ebp+4]
  04f41	f7 d8		 neg	 eax
  04f43	8b f4		 mov	 esi, esp
  04f45	50		 push	 eax
  04f46	8b 4d bc	 mov	 ecx, DWORD PTR _winrect$[ebp]
  04f49	f7 d9		 neg	 ecx
  04f4b	51		 push	 ecx
  04f4c	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  04f4f	52		 push	 edx
  04f50	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  04f56	3b f4		 cmp	 esi, esp
  04f58	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2531 : 
; 2532 : 			hdc = GetWindowDC(hwnd);

  04f5d	8b f4		 mov	 esi, esp
  04f5f	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04f62	50		 push	 eax
  04f63	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  04f69	3b f4		 cmp	 esi, esp
  04f6b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  04f70	89 45 e0	 mov	 DWORD PTR _hdc$[ebp], eax

; 2533 : 			
; 2534 : 			//if the button under the mouse is not the active button,
; 2535 : 			//then display the active button in its normal state
; 2536 : 			if(buttonIdx != uCurrentButton 
; 2537 : 				//include this if toggle buttons always stay depressed
; 2538 : 				//if they are being activated
; 2539 : 				&& (sb->sbButtons[uCurrentButton].uButType & SBBT_MASK) != SBBT_TOGGLEBUTTON)

  04f73	8b 4d b4	 mov	 ecx, DWORD PTR _buttonIdx$[ebp]
  04f76	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _uCurrentButton
  04f7c	74 48		 je	 SHORT $L23500
  04f7e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  04f84	6b d2 30	 imul	 edx, 48			; 00000030H
  04f87	8b 45 a4	 mov	 eax, DWORD PTR _sb$23467[ebp]
  04f8a	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  04f8e	83 e1 1f	 and	 ecx, 31			; 0000001fH
  04f91	83 f9 02	 cmp	 ecx, 2
  04f94	74 30		 je	 SHORT $L23500

; 2540 : 			{
; 2541 : 				if(lastbutton != buttonIdx)

  04f96	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?lastbutton@?1??MouseMove@@9@9
  04f9c	3b 55 b4	 cmp	 edx, DWORD PTR _buttonIdx$[ebp]
  04f9f	74 23		 je	 SHORT $L23501

; 2542 : 					DrawScrollButton(&sb->sbButtons[uCurrentButton], hdc, &rect, SBBS_NORMAL);

  04fa1	6a 00		 push	 0
  04fa3	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  04fa6	50		 push	 eax
  04fa7	8b 4d e0	 mov	 ecx, DWORD PTR _hdc$[ebp]
  04faa	51		 push	 ecx
  04fab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  04fb1	6b d2 30	 imul	 edx, 48			; 00000030H
  04fb4	8b 45 a4	 mov	 eax, DWORD PTR _sb$23467[ebp]
  04fb7	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  04fbb	51		 push	 ecx
  04fbc	e8 00 00 00 00	 call	 _DrawScrollButton
  04fc1	83 c4 10	 add	 esp, 16			; 00000010H
$L23501:

; 2543 : 			}
; 2544 : 			//otherwise, depress the active button if the mouse is over
; 2545 : 			//it (just like a normal scroll button works)
; 2546 : 			else

  04fc4	eb 2e		 jmp	 SHORT $L23502
$L23500:

; 2547 : 			{
; 2548 : 				if(lastbutton != buttonIdx)

  04fc6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?lastbutton@?1??MouseMove@@9@9
  04fcc	3b 55 b4	 cmp	 edx, DWORD PTR _buttonIdx$[ebp]
  04fcf	74 23		 je	 SHORT $L23502

; 2549 : 					DrawScrollButton(&sb->sbButtons[uCurrentButton], hdc, &rect, SBBS_PUSHED);

  04fd1	6a 01		 push	 1
  04fd3	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  04fd6	50		 push	 eax
  04fd7	8b 4d e0	 mov	 ecx, DWORD PTR _hdc$[ebp]
  04fda	51		 push	 ecx
  04fdb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uCurrentButton
  04fe1	6b d2 30	 imul	 edx, 48			; 00000030H
  04fe4	8b 45 a4	 mov	 eax, DWORD PTR _sb$23467[ebp]
  04fe7	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  04feb	51		 push	 ecx
  04fec	e8 00 00 00 00	 call	 _DrawScrollButton
  04ff1	83 c4 10	 add	 esp, 16			; 00000010H
$L23502:

; 2550 : 			}
; 2551 : 
; 2552 : 			ReleaseDC(hwnd, hdc);

  04ff4	8b f4		 mov	 esi, esp
  04ff6	8b 55 e0	 mov	 edx, DWORD PTR _hdc$[ebp]
  04ff9	52		 push	 edx
  04ffa	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  04ffd	50		 push	 eax
  04ffe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  05004	3b f4		 cmp	 esi, esp
  05006	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2553 : 			return CallWindowProc(sw->oldproc, hwnd, WM_MOUSEMOVE, wParam, lParam);

  0500b	8b f4		 mov	 esi, esp
  0500d	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  05010	51		 push	 ecx
  05011	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  05014	52		 push	 edx
  05015	68 00 02 00 00	 push	 512			; 00000200H
  0501a	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0501d	50		 push	 eax
  0501e	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  05021	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  05024	52		 push	 edx
  05025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  0502b	3b f4		 cmp	 esi, esp
  0502d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05032	e9 dc 00 00 00	 jmp	 $L23443
$L23504:

; 2554 : 			//break;
; 2555 : 
; 2556 : #endif	//INCLUDE_BUTTONS
; 2557 : 
; 2558 : 		//The scrollbar is active
; 2559 : 		case HTSCROLL_LEFT:		 case HTSCROLL_RIGHT:case HTSCROLL_THUMB: 
; 2560 : 		case HTSCROLL_PAGELEFT:  case HTSCROLL_PAGERIGHT: 
; 2561 : 		case HTSCROLL_NONE:
; 2562 : 			
; 2563 : 			//adjust the total scroll area to become where the scrollbar
; 2564 : 			//really is (take into account the inserted buttons)
; 2565 : 			GetRealScrollRect(sb, &rect);

  05037	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  0503a	50		 push	 eax
  0503b	8b 4d a4	 mov	 ecx, DWORD PTR _sb$23467[ebp]
  0503e	51		 push	 ecx
  0503f	e8 00 00 00 00	 call	 _GetRealScrollRect
  05044	83 c4 08	 add	 esp, 8

; 2566 : 
; 2567 : 			OffsetRect(&rect, -winrect.left, -winrect.top);

  05047	8b 55 c0	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  0504a	f7 da		 neg	 edx
  0504c	8b f4		 mov	 esi, esp
  0504e	52		 push	 edx
  0504f	8b 45 bc	 mov	 eax, DWORD PTR _winrect$[ebp]
  05052	f7 d8		 neg	 eax
  05054	50		 push	 eax
  05055	8d 4d ec	 lea	 ecx, DWORD PTR _rect$[ebp]
  05058	51		 push	 ecx
  05059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  0505f	3b f4		 cmp	 esi, esp
  05061	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2568 : 			hdc = GetWindowDC(hwnd);

  05066	8b f4		 mov	 esi, esp
  05068	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0506b	52		 push	 edx
  0506c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  05072	3b f4		 cmp	 esi, esp
  05074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05079	89 45 e0	 mov	 DWORD PTR _hdc$[ebp], eax

; 2569 : 		
; 2570 : 			if(thisportion != uCurrentScrollPortion)

  0507c	8b 45 e4	 mov	 eax, DWORD PTR _thisportion$[ebp]
  0507f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _uCurrentScrollPortion
  05085	74 31		 je	 SHORT $L23505

; 2571 : 			{
; 2572 : 				uScrollTimerPortion = HTSCROLL_NONE;

  05087	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uScrollTimerPortion, -1

; 2573 : 
; 2574 : 				if(lastportion != thisportion)

  05091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lastportion@?1??MouseMove@@9@9
  05097	3b 4d e4	 cmp	 ecx, DWORD PTR _thisportion$[ebp]
  0509a	74 1a		 je	 SHORT $L23506

; 2575 : 					NCDrawScrollbar(sb, hwnd, hdc, &rect, HTSCROLL_NORMAL);

  0509c	6a ff		 push	 -1
  0509e	8d 55 ec	 lea	 edx, DWORD PTR _rect$[ebp]
  050a1	52		 push	 edx
  050a2	8b 45 e0	 mov	 eax, DWORD PTR _hdc$[ebp]
  050a5	50		 push	 eax
  050a6	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  050a9	51		 push	 ecx
  050aa	8b 55 a4	 mov	 edx, DWORD PTR _sb$23467[ebp]
  050ad	52		 push	 edx
  050ae	e8 00 00 00 00	 call	 _NCDrawScrollbar
  050b3	83 c4 14	 add	 esp, 20			; 00000014H
$L23506:

; 2576 : 			}
; 2577 : 			//otherwise, draw the button in its depressed / clicked state
; 2578 : 			else

  050b6	eb 31		 jmp	 SHORT $L23507
$L23505:

; 2579 : 			{
; 2580 : 				uScrollTimerPortion = uCurrentScrollPortion;

  050b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _uCurrentScrollPortion
  050bd	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerPortion, eax

; 2581 : 
; 2582 : 				if(lastportion != thisportion)

  050c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?lastportion@?1??MouseMove@@9@9
  050c8	3b 4d e4	 cmp	 ecx, DWORD PTR _thisportion$[ebp]
  050cb	74 1c		 je	 SHORT $L23507

; 2583 : 					NCDrawScrollbar(sb, hwnd, hdc, &rect, thisportion);

  050cd	8b 55 e4	 mov	 edx, DWORD PTR _thisportion$[ebp]
  050d0	52		 push	 edx
  050d1	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  050d4	50		 push	 eax
  050d5	8b 4d e0	 mov	 ecx, DWORD PTR _hdc$[ebp]
  050d8	51		 push	 ecx
  050d9	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  050dc	52		 push	 edx
  050dd	8b 45 a4	 mov	 eax, DWORD PTR _sb$23467[ebp]
  050e0	50		 push	 eax
  050e1	e8 00 00 00 00	 call	 _NCDrawScrollbar
  050e6	83 c4 14	 add	 esp, 20			; 00000014H
$L23507:

; 2584 : 			}
; 2585 : 
; 2586 : 			ReleaseDC(hwnd, hdc);

  050e9	8b f4		 mov	 esi, esp
  050eb	8b 4d e0	 mov	 ecx, DWORD PTR _hdc$[ebp]
  050ee	51		 push	 ecx
  050ef	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  050f2	52		 push	 edx
  050f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  050f9	3b f4		 cmp	 esi, esp
  050fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23477:

; 2587 : 
; 2588 : 			break;
; 2589 : 		}
; 2590 : 
; 2591 : 
; 2592 : 		lastportion = thisportion;

  05100	8b 45 e4	 mov	 eax, DWORD PTR _thisportion$[ebp]
  05103	a3 00 00 00 00	 mov	 DWORD PTR ?lastportion@?1??MouseMove@@9@9, eax

; 2593 : 		lastbutton  = buttonIdx;

  05108	8b 4d b4	 mov	 ecx, DWORD PTR _buttonIdx$[ebp]
  0510b	89 0d 00 00 00
	00		 mov	 DWORD PTR ?lastbutton@?1??MouseMove@@9@9, ecx

; 2594 : 
; 2595 : 		//must return zero here, because we might get cursor anomilies
; 2596 : 		//CallWindowProc(sw->oldproc, hwnd, WM_MOUSEMOVE, wParam, lParam);
; 2597 : 		return 0;

  05111	33 c0		 xor	 eax, eax
$L23443:

; 2598 : 		
; 2599 : 	}
; 2600 : }

  05113	52		 push	 edx
  05114	8b cd		 mov	 ecx, ebp
  05116	50		 push	 eax
  05117	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L24027
  0511d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  05122	58		 pop	 eax
  05123	5a		 pop	 edx
  05124	5f		 pop	 edi
  05125	5e		 pop	 esi
  05126	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  0512c	3b ec		 cmp	 ebp, esp
  0512e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05133	8b e5		 mov	 esp, ebp
  05135	5d		 pop	 ebp
  05136	c3		 ret	 0
$L24027:
  05137	04 00 00 00	 DD	 4
  0513b	00 00 00 00	 DD	 $L24026
$L24026:
  0513f	ec ff ff ff	 DD	 -20			; ffffffecH
  05143	10 00 00 00	 DD	 16			; 00000010H
  05147	00 00 00 00	 DD	 $L24022
  0514b	d4 ff ff ff	 DD	 -44			; ffffffd4H
  0514f	08 00 00 00	 DD	 8
  05153	00 00 00 00	 DD	 $L24023
  05157	bc ff ff ff	 DD	 -68			; ffffffbcH
  0515b	10 00 00 00	 DD	 16			; 00000010H
  0515f	00 00 00 00	 DD	 $L24024
  05163	80 ff ff ff	 DD	 -128			; ffffff80H
  05167	10 00 00 00	 DD	 16			; 00000010H
  0516b	00 00 00 00	 DD	 $L24025
$L24025:
  0516f	72		 DB	 114			; 00000072H
  05170	65		 DB	 101			; 00000065H
  05171	63		 DB	 99			; 00000063H
  05172	74		 DB	 116			; 00000074H
  05173	32		 DB	 50			; 00000032H
  05174	00		 DB	 0
$L24024:
  05175	77		 DB	 119			; 00000077H
  05176	69		 DB	 105			; 00000069H
  05177	6e		 DB	 110			; 0000006eH
  05178	72		 DB	 114			; 00000072H
  05179	65		 DB	 101			; 00000065H
  0517a	63		 DB	 99			; 00000063H
  0517b	74		 DB	 116			; 00000074H
  0517c	00		 DB	 0
$L24023:
  0517d	70		 DB	 112			; 00000070H
  0517e	74		 DB	 116			; 00000074H
  0517f	00		 DB	 0
$L24022:
  05180	72		 DB	 114			; 00000072H
  05181	65		 DB	 101			; 00000065H
  05182	63		 DB	 99			; 00000063H
  05183	74		 DB	 116			; 00000074H
  05184	00		 DB	 0
_MouseMove ENDP
; Function compile flags: /Odt /RTCsu
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_rect$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
_GetPortion PROC NEAR

; 1713 : {

  05190	55		 push	 ebp
  05191	8b ec		 mov	 ebp, esp

; 1714 : 	if(sb->nBarType == SB_HORZ)

  05193	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  05196	83 b8 40 03 00
	00 00		 cmp	 DWORD PTR [eax+832], 0
  0519d	75 1e		 jne	 SHORT $L23165

; 1715 : 		return GetHorzPortion(sb, hwnd, rect, x, y);

  0519f	8b 4d 18	 mov	 ecx, DWORD PTR _y$[ebp]
  051a2	51		 push	 ecx
  051a3	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  051a6	52		 push	 edx
  051a7	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  051aa	50		 push	 eax
  051ab	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  051ae	51		 push	 ecx
  051af	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  051b2	52		 push	 edx
  051b3	e8 00 00 00 00	 call	 _GetHorzPortion
  051b8	83 c4 14	 add	 esp, 20			; 00000014H
  051bb	eb 2d		 jmp	 SHORT $L23164
$L23165:

; 1716 : 	else if(sb->nBarType == SB_VERT)

  051bd	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  051c0	83 b8 40 03 00
	00 01		 cmp	 DWORD PTR [eax+832], 1
  051c7	75 1e		 jne	 SHORT $L23167

; 1717 : 		return GetVertPortion(sb, hwnd, rect, x, y);

  051c9	8b 4d 18	 mov	 ecx, DWORD PTR _y$[ebp]
  051cc	51		 push	 ecx
  051cd	8b 55 14	 mov	 edx, DWORD PTR _x$[ebp]
  051d0	52		 push	 edx
  051d1	8b 45 10	 mov	 eax, DWORD PTR _rect$[ebp]
  051d4	50		 push	 eax
  051d5	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  051d8	51		 push	 ecx
  051d9	8b 55 08	 mov	 edx, DWORD PTR _sb$[ebp]
  051dc	52		 push	 edx
  051dd	e8 00 00 00 00	 call	 _GetVertPortion
  051e2	83 c4 14	 add	 esp, 20			; 00000014H
  051e5	eb 03		 jmp	 SHORT $L23164
$L23167:

; 1718 : 	else
; 1719 : 		return HTSCROLL_NONE;

  051e7	83 c8 ff	 or	 eax, -1
$L23164:

; 1720 : }

  051ea	3b ec		 cmp	 ebp, esp
  051ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  051f1	5d		 pop	 ebp
  051f2	c3		 ret	 0
_GetPortion ENDP
; Function compile flags: /Odt /RTCsu
_si$ = -124						; size = 4
_fCustomDraw$ = -120					; size = 4
_flatflag$ = -116					; size = 4
_siMaxMin$ = -112					; size = 4
_pos$ = -108						; size = 4
_thumbpos$ = -104					; size = 4
_hdc$ = -100						; size = 4
_crCheck2$ = -96					; size = 4
_crCheck1$ = -92					; size = 4
_rc2$ = -84						; size = 16
_winrect$ = -60						; size = 16
_rc$ = -36						; size = 16
_pt$ = -12						; size = 8
_sbar$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_ThumbTrackHorz PROC NEAR

; 2253 : {

  05200	55		 push	 ebp
  05201	8b ec		 mov	 ebp, esp
  05203	83 ec 7c	 sub	 esp, 124		; 0000007cH
  05206	56		 push	 esi
  05207	57		 push	 edi
  05208	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  0520b	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  05210	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  05215	f3 ab		 rep stosd

; 2254 : 	POINT pt;
; 2255 : 	RECT rc, winrect, rc2;
; 2256 : 	COLORREF crCheck1 = GetSBForeColor();

  05217	e8 00 00 00 00	 call	 _GetSBForeColor
  0521c	89 45 a4	 mov	 DWORD PTR _crCheck1$[ebp], eax

; 2257 : 	COLORREF crCheck2 = GetSBBackColor();

  0521f	e8 00 00 00 00	 call	 _GetSBBackColor
  05224	89 45 a0	 mov	 DWORD PTR _crCheck2$[ebp], eax

; 2258 : 	HDC hdc;
; 2259 : 	int thumbpos = nThumbPos;

  05227	a1 00 00 00 00	 mov	 eax, DWORD PTR _nThumbPos
  0522c	89 45 98	 mov	 DWORD PTR _thumbpos$[ebp], eax

; 2260 : 	int pos;
; 2261 : 	int siMaxMin = 0;

  0522f	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _siMaxMin$[ebp], 0

; 2262 : 	UINT flatflag = sbar->fFlatScrollbar ? BF_FLAT : 0;

  05236	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  05239	8b 91 44 03 00
	00		 mov	 edx, DWORD PTR [ecx+836]
  0523f	f7 da		 neg	 edx
  05241	1b d2		 sbb	 edx, edx
  05243	81 e2 00 40 00
	00		 and	 edx, 16384		; 00004000H
  05249	89 55 8c	 mov	 DWORD PTR _flatflag$[ebp], edx

; 2263 : 	BOOL fCustomDraw = FALSE;

  0524c	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _fCustomDraw$[ebp], 0

; 2264 : 
; 2265 : 	SCROLLINFO *si;
; 2266 : 	si = &sbar->scrollInfo;

  05253	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  05256	83 c0 08	 add	 eax, 8
  05259	89 45 84	 mov	 DWORD PTR _si$[ebp], eax

; 2267 : 
; 2268 : 	pt.x = x;

  0525c	8b 4d 10	 mov	 ecx, DWORD PTR _x$[ebp]
  0525f	89 4d f4	 mov	 DWORD PTR _pt$[ebp], ecx

; 2269 : 	pt.y = y;

  05262	8b 55 14	 mov	 edx, DWORD PTR _y$[ebp]
  05265	89 55 f8	 mov	 DWORD PTR _pt$[ebp+4], edx

; 2270 : 
; 2271 : 	//draw the thumb at whatever position
; 2272 : 	rc = rcThumbBounds;

  05268	a1 00 00 00 00	 mov	 eax, DWORD PTR _rcThumbBounds
  0526d	89 45 dc	 mov	 DWORD PTR _rc$[ebp], eax
  05270	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _rcThumbBounds+4
  05276	89 4d e0	 mov	 DWORD PTR _rc$[ebp+4], ecx
  05279	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _rcThumbBounds+8
  0527f	89 55 e4	 mov	 DWORD PTR _rc$[ebp+8], edx
  05282	a1 0c 00 00 00	 mov	 eax, DWORD PTR _rcThumbBounds+12
  05287	89 45 e8	 mov	 DWORD PTR _rc$[ebp+12], eax

; 2273 : 
; 2274 : 	SetRect(&rc2, rc.left -  THUMBTRACK_SNAPDIST*2, rc.top -    THUMBTRACK_SNAPDIST, 
; 2275 : 				  rc.right + THUMBTRACK_SNAPDIST*2, rc.bottom + THUMBTRACK_SNAPDIST);

  0528a	8b 4d e8	 mov	 ecx, DWORD PTR _rc$[ebp+12]
  0528d	83 c1 18	 add	 ecx, 24			; 00000018H
  05290	8b f4		 mov	 esi, esp
  05292	51		 push	 ecx
  05293	8b 55 e4	 mov	 edx, DWORD PTR _rc$[ebp+8]
  05296	83 c2 30	 add	 edx, 48			; 00000030H
  05299	52		 push	 edx
  0529a	8b 45 e0	 mov	 eax, DWORD PTR _rc$[ebp+4]
  0529d	83 e8 18	 sub	 eax, 24			; 00000018H
  052a0	50		 push	 eax
  052a1	8b 4d dc	 mov	 ecx, DWORD PTR _rc$[ebp]
  052a4	83 e9 30	 sub	 ecx, 48			; 00000030H
  052a7	51		 push	 ecx
  052a8	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  052ab	52		 push	 edx
  052ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  052b2	3b f4		 cmp	 esi, esp
  052b4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2276 : 
; 2277 : 	rc.left +=  GetScrollMetric(sbar, SM_CXHORZSB);

  052b9	6a 00		 push	 0
  052bb	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  052be	50		 push	 eax
  052bf	e8 00 00 00 00	 call	 _GetScrollMetric
  052c4	83 c4 08	 add	 esp, 8
  052c7	03 45 dc	 add	 eax, DWORD PTR _rc$[ebp]
  052ca	89 45 dc	 mov	 DWORD PTR _rc$[ebp], eax

; 2278 : 	rc.right -= GetScrollMetric(sbar, SM_CXHORZSB);

  052cd	6a 00		 push	 0
  052cf	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  052d2	51		 push	 ecx
  052d3	e8 00 00 00 00	 call	 _GetScrollMetric
  052d8	83 c4 08	 add	 esp, 8
  052db	8b 55 e4	 mov	 edx, DWORD PTR _rc$[ebp+8]
  052de	2b d0		 sub	 edx, eax
  052e0	89 55 e4	 mov	 DWORD PTR _rc$[ebp+8], edx

; 2279 : 
; 2280 : 	//if the mouse is not in a suitable distance of the scrollbar,
; 2281 : 	//then "snap" the thumb back to its initial position
; 2282 : #ifdef SNAP_THUMB_BACK
; 2283 : 	if(!PtInRect(&rc2, pt))

  052e3	8b f4		 mov	 esi, esp
  052e5	8b 45 f8	 mov	 eax, DWORD PTR _pt$[ebp+4]
  052e8	50		 push	 eax
  052e9	8b 4d f4	 mov	 ecx, DWORD PTR _pt$[ebp]
  052ec	51		 push	 ecx
  052ed	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  052f0	52		 push	 edx
  052f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  052f7	3b f4		 cmp	 esi, esp
  052f9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  052fe	85 c0		 test	 eax, eax
  05300	75 0a		 jne	 SHORT $L23408

; 2284 : 	{
; 2285 : 		thumbpos = nThumbPos0;

  05302	a1 00 00 00 00	 mov	 eax, DWORD PTR _nThumbPos0
  05307	89 45 98	 mov	 DWORD PTR _thumbpos$[ebp], eax

; 2286 : 	}
; 2287 : 	//otherwise, move the thumb to where the mouse is
; 2288 : 	else

  0530a	eb 34		 jmp	 SHORT $L23409
$L23408:

; 2289 : #endif //SNAP_THUMB_BACK
; 2290 : 	{
; 2291 : 		//keep the thumb within the scrollbar limits
; 2292 : 		thumbpos = pt.x - nThumbMouseOffset;

  0530c	8b 4d f4	 mov	 ecx, DWORD PTR _pt$[ebp]
  0530f	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _nThumbMouseOffset
  05315	89 4d 98	 mov	 DWORD PTR _thumbpos$[ebp], ecx

; 2293 : 		if(thumbpos < rc.left) thumbpos = rc.left;

  05318	8b 55 98	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  0531b	3b 55 dc	 cmp	 edx, DWORD PTR _rc$[ebp]
  0531e	7d 06		 jge	 SHORT $L23410
  05320	8b 45 dc	 mov	 eax, DWORD PTR _rc$[ebp]
  05323	89 45 98	 mov	 DWORD PTR _thumbpos$[ebp], eax
$L23410:

; 2294 : 		if(thumbpos > rc.right - nThumbSize) thumbpos = rc.right - nThumbSize;

  05326	8b 4d e4	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  05329	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _nThumbSize
  0532f	39 4d 98	 cmp	 DWORD PTR _thumbpos$[ebp], ecx
  05332	7e 0c		 jle	 SHORT $L23409
  05334	8b 55 e4	 mov	 edx, DWORD PTR _rc$[ebp+8]
  05337	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _nThumbSize
  0533d	89 55 98	 mov	 DWORD PTR _thumbpos$[ebp], edx
$L23409:

; 2295 : 	}
; 2296 : 
; 2297 : 	GetWindowRect(hwnd, &winrect);

  05340	8b f4		 mov	 esi, esp
  05342	8d 45 c4	 lea	 eax, DWORD PTR _winrect$[ebp]
  05345	50		 push	 eax
  05346	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05349	51		 push	 ecx
  0534a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  05350	3b f4		 cmp	 esi, esp
  05352	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2298 : 
; 2299 : 	if(sbar->nBarType == SB_VERT)

  05357	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  0535a	83 ba 40 03 00
	00 01		 cmp	 DWORD PTR [edx+832], 1
  05361	75 09		 jne	 SHORT $L23412

; 2300 : 		RotateRect(&winrect);

  05363	8d 45 c4	 lea	 eax, DWORD PTR _winrect$[ebp]
  05366	50		 push	 eax
  05367	e8 00 00 00 00	 call	 _RotateRect@4
$L23412:

; 2301 : 	
; 2302 : 	hdc = GetWindowDC(hwnd);

  0536c	8b f4		 mov	 esi, esp
  0536e	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05371	51		 push	 ecx
  05372	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  05378	3b f4		 cmp	 esi, esp
  0537a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0537f	89 45 9c	 mov	 DWORD PTR _hdc$[ebp], eax

; 2303 : 		
; 2304 : #ifdef CUSTOM_DRAW
; 2305 : 	fCustomDraw = PostCustomPrePostPaint(hwnd, hdc, sbar, CDDS_PREPAINT) == CDRF_SKIPDEFAULT;

  05382	6a 01		 push	 1
  05384	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  05387	52		 push	 edx
  05388	8b 45 9c	 mov	 eax, DWORD PTR _hdc$[ebp]
  0538b	50		 push	 eax
  0538c	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0538f	51		 push	 ecx
  05390	e8 00 00 00 00	 call	 _PostCustomPrePostPaint0
  05395	83 c4 10	 add	 esp, 16			; 00000010H
  05398	83 e8 04	 sub	 eax, 4
  0539b	f7 d8		 neg	 eax
  0539d	1b c0		 sbb	 eax, eax
  0539f	40		 inc	 eax
  053a0	89 45 88	 mov	 DWORD PTR _fCustomDraw$[ebp], eax

; 2306 : #endif
; 2307 : 
; 2308 : 	OffsetRect(&rc, -winrect.left, -winrect.top);

  053a3	8b 55 c8	 mov	 edx, DWORD PTR _winrect$[ebp+4]
  053a6	f7 da		 neg	 edx
  053a8	8b f4		 mov	 esi, esp
  053aa	52		 push	 edx
  053ab	8b 45 c4	 mov	 eax, DWORD PTR _winrect$[ebp]
  053ae	f7 d8		 neg	 eax
  053b0	50		 push	 eax
  053b1	8d 4d dc	 lea	 ecx, DWORD PTR _rc$[ebp]
  053b4	51		 push	 ecx
  053b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  053bb	3b f4		 cmp	 esi, esp
  053bd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2309 : 	thumbpos -= winrect.left;

  053c2	8b 55 98	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  053c5	2b 55 c4	 sub	 edx, DWORD PTR _winrect$[ebp]
  053c8	89 55 98	 mov	 DWORD PTR _thumbpos$[ebp], edx

; 2310 : 
; 2311 : 	//draw the margin before the thumb
; 2312 : 	SetRect(&rc2, rc.left, rc.top, thumbpos, rc.bottom);

  053cb	8b f4		 mov	 esi, esp
  053cd	8b 45 e8	 mov	 eax, DWORD PTR _rc$[ebp+12]
  053d0	50		 push	 eax
  053d1	8b 4d 98	 mov	 ecx, DWORD PTR _thumbpos$[ebp]
  053d4	51		 push	 ecx
  053d5	8b 55 e0	 mov	 edx, DWORD PTR _rc$[ebp+4]
  053d8	52		 push	 edx
  053d9	8b 45 dc	 mov	 eax, DWORD PTR _rc$[ebp]
  053dc	50		 push	 eax
  053dd	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  053e0	51		 push	 ecx
  053e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  053e7	3b f4		 cmp	 esi, esp
  053e9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2313 : 	RotateRect0(sbar, &rc2);

  053ee	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  053f1	52		 push	 edx
  053f2	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  053f5	50		 push	 eax
  053f6	e8 00 00 00 00	 call	 _RotateRect0@8

; 2314 : 
; 2315 : 	if(fCustomDraw)

  053fb	83 7d 88 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  053ff	74 28		 je	 SHORT $L23413

; 2316 : 		PostCustomDrawNotify(hwnd, hdc, sbar->nBarType, &rc2, SB_PAGELEFT, 0, 0, 0);

  05401	6a 00		 push	 0
  05403	6a 00		 push	 0
  05405	6a 00		 push	 0
  05407	6a 02		 push	 2
  05409	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  0540c	51		 push	 ecx
  0540d	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  05410	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  05416	50		 push	 eax
  05417	8b 4d 9c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0541a	51		 push	 ecx
  0541b	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0541e	52		 push	 edx
  0541f	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  05424	83 c4 20	 add	 esp, 32			; 00000020H

; 2317 : 	else

  05427	eb 18		 jmp	 SHORT $L23414
$L23413:

; 2318 : 		DrawCheckedRect(hdc, &rc2, crCheck1, crCheck2);

  05429	8b 45 a0	 mov	 eax, DWORD PTR _crCheck2$[ebp]
  0542c	50		 push	 eax
  0542d	8b 4d a4	 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  05430	51		 push	 ecx
  05431	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  05434	52		 push	 edx
  05435	8b 45 9c	 mov	 eax, DWORD PTR _hdc$[ebp]
  05438	50		 push	 eax
  05439	e8 00 00 00 00	 call	 _DrawCheckedRect
  0543e	83 c4 10	 add	 esp, 16			; 00000010H
$L23414:

; 2319 : 	
; 2320 : 	RotateRect0(sbar, &rc2);

  05441	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  05444	51		 push	 ecx
  05445	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  05448	52		 push	 edx
  05449	e8 00 00 00 00	 call	 _RotateRect0@8

; 2321 : 
; 2322 : 	//draw the margin after the thumb 
; 2323 : 	SetRect(&rc2, thumbpos+nThumbSize, rc.top, rc.right, rc.bottom);

  0544e	8b f4		 mov	 esi, esp
  05450	8b 45 e8	 mov	 eax, DWORD PTR _rc$[ebp+12]
  05453	50		 push	 eax
  05454	8b 4d e4	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  05457	51		 push	 ecx
  05458	8b 55 e0	 mov	 edx, DWORD PTR _rc$[ebp+4]
  0545b	52		 push	 edx
  0545c	8b 45 98	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  0545f	03 05 00 00 00
	00		 add	 eax, DWORD PTR _nThumbSize
  05465	50		 push	 eax
  05466	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  05469	51		 push	 ecx
  0546a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  05470	3b f4		 cmp	 esi, esp
  05472	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2324 : 	
; 2325 : 	RotateRect0(sbar, &rc2);

  05477	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  0547a	52		 push	 edx
  0547b	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  0547e	50		 push	 eax
  0547f	e8 00 00 00 00	 call	 _RotateRect0@8

; 2326 : 	
; 2327 : 	if(fCustomDraw)

  05484	83 7d 88 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  05488	74 28		 je	 SHORT $L23415

; 2328 : 		PostCustomDrawNotify(hwnd, hdc, sbar->nBarType, &rc2, SB_PAGERIGHT, 0, 0, 0);

  0548a	6a 00		 push	 0
  0548c	6a 00		 push	 0
  0548e	6a 00		 push	 0
  05490	6a 03		 push	 3
  05492	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  05495	51		 push	 ecx
  05496	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  05499	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  0549f	50		 push	 eax
  054a0	8b 4d 9c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  054a3	51		 push	 ecx
  054a4	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  054a7	52		 push	 edx
  054a8	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  054ad	83 c4 20	 add	 esp, 32			; 00000020H

; 2329 : 	else

  054b0	eb 18		 jmp	 SHORT $L23416
$L23415:

; 2330 : 		DrawCheckedRect(hdc, &rc2, crCheck1, crCheck2);

  054b2	8b 45 a0	 mov	 eax, DWORD PTR _crCheck2$[ebp]
  054b5	50		 push	 eax
  054b6	8b 4d a4	 mov	 ecx, DWORD PTR _crCheck1$[ebp]
  054b9	51		 push	 ecx
  054ba	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  054bd	52		 push	 edx
  054be	8b 45 9c	 mov	 eax, DWORD PTR _hdc$[ebp]
  054c1	50		 push	 eax
  054c2	e8 00 00 00 00	 call	 _DrawCheckedRect
  054c7	83 c4 10	 add	 esp, 16			; 00000010H
$L23416:

; 2331 : 	
; 2332 : 	RotateRect0(sbar, &rc2);

  054ca	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  054cd	51		 push	 ecx
  054ce	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  054d1	52		 push	 edx
  054d2	e8 00 00 00 00	 call	 _RotateRect0@8

; 2333 : 	
; 2334 : 	//finally draw the thumb itelf. This is how it looks on win2000, anyway
; 2335 : 	SetRect(&rc2, thumbpos, rc.top, thumbpos+nThumbSize, rc.bottom);

  054d7	8b f4		 mov	 esi, esp
  054d9	8b 45 e8	 mov	 eax, DWORD PTR _rc$[ebp+12]
  054dc	50		 push	 eax
  054dd	8b 4d 98	 mov	 ecx, DWORD PTR _thumbpos$[ebp]
  054e0	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _nThumbSize
  054e6	51		 push	 ecx
  054e7	8b 55 e0	 mov	 edx, DWORD PTR _rc$[ebp+4]
  054ea	52		 push	 edx
  054eb	8b 45 98	 mov	 eax, DWORD PTR _thumbpos$[ebp]
  054ee	50		 push	 eax
  054ef	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  054f2	51		 push	 ecx
  054f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetRect@20
  054f9	3b f4		 cmp	 esi, esp
  054fb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2336 : 	
; 2337 : 	RotateRect0(sbar, &rc2);

  05500	8d 55 ac	 lea	 edx, DWORD PTR _rc2$[ebp]
  05503	52		 push	 edx
  05504	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  05507	50		 push	 eax
  05508	e8 00 00 00 00	 call	 _RotateRect0@8

; 2338 : 
; 2339 : 	if(fCustomDraw)

  0550d	83 7d 88 00	 cmp	 DWORD PTR _fCustomDraw$[ebp], 0
  05511	74 28		 je	 SHORT $L23417

; 2340 : 		PostCustomDrawNotify(hwnd, hdc, sbar->nBarType, &rc2, SB_THUMBTRACK, TRUE, TRUE, FALSE);

  05513	6a 00		 push	 0
  05515	6a 01		 push	 1
  05517	6a 01		 push	 1
  05519	6a 05		 push	 5
  0551b	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  0551e	51		 push	 ecx
  0551f	8b 55 08	 mov	 edx, DWORD PTR _sbar$[ebp]
  05522	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  05528	50		 push	 eax
  05529	8b 4d 9c	 mov	 ecx, DWORD PTR _hdc$[ebp]
  0552c	51		 push	 ecx
  0552d	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05530	52		 push	 edx
  05531	e8 00 00 00 00	 call	 _PostCustomDrawNotify0
  05536	83 c4 20	 add	 esp, 32			; 00000020H

; 2341 : 	else

  05539	eb 44		 jmp	 SHORT $L23418
$L23417:

; 2342 : 	{
; 2343 : 
; 2344 : #ifdef FLAT_SCROLLBARS	
; 2345 : 		if(sbar->fFlatScrollbar)

  0553b	8b 45 08	 mov	 eax, DWORD PTR _sbar$[ebp]
  0553e	83 b8 44 03 00
	00 00		 cmp	 DWORD PTR [eax+836], 0
  05545	74 24		 je	 SHORT $L23419

; 2346 : 			PaintRect(hdc, &rc2, GetSysColor(COLOR_3DSHADOW));

  05547	8b f4		 mov	 esi, esp
  05549	6a 10		 push	 16			; 00000010H
  0554b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSysColor@4
  05551	3b f4		 cmp	 esi, esp
  05553	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05558	50		 push	 eax
  05559	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  0555c	51		 push	 ecx
  0555d	8b 55 9c	 mov	 edx, DWORD PTR _hdc$[ebp]
  05560	52		 push	 edx
  05561	e8 00 00 00 00	 call	 _PaintRect
  05566	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2347 : 		else

  05569	eb 14		 jmp	 SHORT $L23418
$L23419:

; 2348 : #endif
; 2349 : 		{
; 2350 : 				DrawBlankButton(hdc, &rc2, flatflag);

  0556b	8b 45 8c	 mov	 eax, DWORD PTR _flatflag$[ebp]
  0556e	50		 push	 eax
  0556f	8d 4d ac	 lea	 ecx, DWORD PTR _rc2$[ebp]
  05572	51		 push	 ecx
  05573	8b 55 9c	 mov	 edx, DWORD PTR _hdc$[ebp]
  05576	52		 push	 edx
  05577	e8 00 00 00 00	 call	 _DrawBlankButton
  0557c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L23418:

; 2351 : 		}
; 2352 : 	}
; 2353 : 
; 2354 : 	RotateRect0(sbar, &rc2);

  0557f	8d 45 ac	 lea	 eax, DWORD PTR _rc2$[ebp]
  05582	50		 push	 eax
  05583	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  05586	51		 push	 ecx
  05587	e8 00 00 00 00	 call	 _RotateRect0@8

; 2355 : 	ReleaseDC(hwnd, hdc);

  0558c	8b f4		 mov	 esi, esp
  0558e	8b 55 9c	 mov	 edx, DWORD PTR _hdc$[ebp]
  05591	52		 push	 edx
  05592	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05595	50		 push	 eax
  05596	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  0559c	3b f4		 cmp	 esi, esp
  0559e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2356 : 
; 2357 : 	//post a SB_TRACKPOS message!!!
; 2358 : 	siMaxMin = si->nMax - si->nMin;

  055a3	8b 4d 84	 mov	 ecx, DWORD PTR _si$[ebp]
  055a6	8b 55 84	 mov	 edx, DWORD PTR _si$[ebp]
  055a9	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  055ac	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  055af	89 45 90	 mov	 DWORD PTR _siMaxMin$[ebp], eax

; 2359 : 
; 2360 : 	if(siMaxMin > 0)

  055b2	83 7d 90 00	 cmp	 DWORD PTR _siMaxMin$[ebp], 0
  055b6	7e 35		 jle	 SHORT $L23421

; 2361 : 		pos = MulDiv(thumbpos-rc.left, siMaxMin-si->nPage + 1, rc.right-rc.left-nThumbSize);

  055b8	8b 4d e4	 mov	 ecx, DWORD PTR _rc$[ebp+8]
  055bb	2b 4d dc	 sub	 ecx, DWORD PTR _rc$[ebp]
  055be	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _nThumbSize
  055c4	8b f4		 mov	 esi, esp
  055c6	51		 push	 ecx
  055c7	8b 55 84	 mov	 edx, DWORD PTR _si$[ebp]
  055ca	8b 45 90	 mov	 eax, DWORD PTR _siMaxMin$[ebp]
  055cd	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  055d0	83 c0 01	 add	 eax, 1
  055d3	50		 push	 eax
  055d4	8b 4d 98	 mov	 ecx, DWORD PTR _thumbpos$[ebp]
  055d7	2b 4d dc	 sub	 ecx, DWORD PTR _rc$[ebp]
  055da	51		 push	 ecx
  055db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MulDiv@12
  055e1	3b f4		 cmp	 esi, esp
  055e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  055e8	89 45 94	 mov	 DWORD PTR _pos$[ebp], eax

; 2362 : 	else

  055eb	eb 09		 jmp	 SHORT $L23422
$L23421:

; 2363 : 		pos = thumbpos - rc.left;

  055ed	8b 55 98	 mov	 edx, DWORD PTR _thumbpos$[ebp]
  055f0	2b 55 dc	 sub	 edx, DWORD PTR _rc$[ebp]
  055f3	89 55 94	 mov	 DWORD PTR _pos$[ebp], edx
$L23422:

; 2364 : 
; 2365 : 	if(pos != nLastPos)

  055f6	8b 45 94	 mov	 eax, DWORD PTR _pos$[ebp]
  055f9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nLastPos
  055ff	74 22		 je	 SHORT $L23423

; 2366 : 	{
; 2367 : 		si->nTrackPos = pos;	

  05601	8b 4d 84	 mov	 ecx, DWORD PTR _si$[ebp]
  05604	8b 55 94	 mov	 edx, DWORD PTR _pos$[ebp]
  05607	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 2368 : 		SendScrollMessage(hwnd, uScrollTimerMsg, SB_THUMBTRACK, pos);

  0560a	8b 45 94	 mov	 eax, DWORD PTR _pos$[ebp]
  0560d	50		 push	 eax
  0560e	6a 05		 push	 5
  05610	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uScrollTimerMsg
  05616	51		 push	 ecx
  05617	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  0561a	52		 push	 edx
  0561b	e8 00 00 00 00	 call	 _SendScrollMessage
  05620	83 c4 10	 add	 esp, 16			; 00000010H
$L23423:

; 2369 : 	}
; 2370 : 
; 2371 : 	nLastPos = pos;

  05623	8b 45 94	 mov	 eax, DWORD PTR _pos$[ebp]
  05626	a3 00 00 00 00	 mov	 DWORD PTR _nLastPos, eax

; 2372 : 
; 2373 : #ifdef CUSTOM_DRAW
; 2374 : 	PostCustomPrePostPaint(hwnd, hdc, sbar, CDDS_POSTPAINT);

  0562b	6a 02		 push	 2
  0562d	8b 4d 08	 mov	 ecx, DWORD PTR _sbar$[ebp]
  05630	51		 push	 ecx
  05631	8b 55 9c	 mov	 edx, DWORD PTR _hdc$[ebp]
  05634	52		 push	 edx
  05635	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05638	50		 push	 eax
  05639	e8 00 00 00 00	 call	 _PostCustomPrePostPaint0
  0563e	83 c4 10	 add	 esp, 16			; 00000010H

; 2375 : #endif
; 2376 : 	
; 2377 : 	return 0;

  05641	33 c0		 xor	 eax, eax

; 2378 : }

  05643	52		 push	 edx
  05644	8b cd		 mov	 ecx, ebp
  05646	50		 push	 eax
  05647	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L24035
  0564d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  05652	58		 pop	 eax
  05653	5a		 pop	 edx
  05654	5f		 pop	 edi
  05655	5e		 pop	 esi
  05656	83 c4 7c	 add	 esp, 124		; 0000007cH
  05659	3b ec		 cmp	 ebp, esp
  0565b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05660	8b e5		 mov	 esp, ebp
  05662	5d		 pop	 ebp
  05663	c3		 ret	 0
$L24035:
  05664	04 00 00 00	 DD	 4
  05668	00 00 00 00	 DD	 $L24034
$L24034:
  0566c	f4 ff ff ff	 DD	 -12			; fffffff4H
  05670	08 00 00 00	 DD	 8
  05674	00 00 00 00	 DD	 $L24030
  05678	dc ff ff ff	 DD	 -36			; ffffffdcH
  0567c	10 00 00 00	 DD	 16			; 00000010H
  05680	00 00 00 00	 DD	 $L24031
  05684	c4 ff ff ff	 DD	 -60			; ffffffc4H
  05688	10 00 00 00	 DD	 16			; 00000010H
  0568c	00 00 00 00	 DD	 $L24032
  05690	ac ff ff ff	 DD	 -84			; ffffffacH
  05694	10 00 00 00	 DD	 16			; 00000010H
  05698	00 00 00 00	 DD	 $L24033
$L24033:
  0569c	72		 DB	 114			; 00000072H
  0569d	63		 DB	 99			; 00000063H
  0569e	32		 DB	 50			; 00000032H
  0569f	00		 DB	 0
$L24032:
  056a0	77		 DB	 119			; 00000077H
  056a1	69		 DB	 105			; 00000069H
  056a2	6e		 DB	 110			; 0000006eH
  056a3	72		 DB	 114			; 00000072H
  056a4	65		 DB	 101			; 00000065H
  056a5	63		 DB	 99			; 00000063H
  056a6	74		 DB	 116			; 00000074H
  056a7	00		 DB	 0
$L24031:
  056a8	72		 DB	 114			; 00000072H
  056a9	63		 DB	 99			; 00000063H
  056aa	00		 DB	 0
$L24030:
  056ab	70		 DB	 112			; 00000070H
  056ac	74		 DB	 116			; 00000074H
  056ad	00		 DB	 0
_ThumbTrackHorz ENDP
; Function compile flags: /Odt /RTCsu
_sb$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_ThumbTrackVert PROC NEAR

; 2384 : {

  056b0	55		 push	 ebp
  056b1	8b ec		 mov	 ebp, esp

; 2385 : 	//sw->swapcoords = TRUE;
; 2386 : 	RotateRect(&rcThumbBounds);

  056b3	68 00 00 00 00	 push	 OFFSET FLAT:_rcThumbBounds
  056b8	e8 00 00 00 00	 call	 _RotateRect@4

; 2387 : 	ThumbTrackHorz(sb, hwnd, y, x);

  056bd	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  056c0	50		 push	 eax
  056c1	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  056c4	51		 push	 ecx
  056c5	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  056c8	52		 push	 edx
  056c9	8b 45 08	 mov	 eax, DWORD PTR _sb$[ebp]
  056cc	50		 push	 eax
  056cd	e8 00 00 00 00	 call	 _ThumbTrackHorz
  056d2	83 c4 10	 add	 esp, 16			; 00000010H

; 2388 : 	RotateRect(&rcThumbBounds);

  056d5	68 00 00 00 00	 push	 OFFSET FLAT:_rcThumbBounds
  056da	e8 00 00 00 00	 call	 _RotateRect@4

; 2389 : 	//sw->swapcoords = FALSE;
; 2390 : 
; 2391 : 	return 0;

  056df	33 c0		 xor	 eax, eax

; 2392 : }

  056e1	3b ec		 cmp	 ebp, esp
  056e3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  056e8	5d		 pop	 ebp
  056e9	c3		 ret	 0
_ThumbTrackVert ENDP
; Function compile flags: /Odt /RTCsu
_dwStyle$ = -48					; size = 4
_ret$ = -44						; size = 4
_sb$ = -40						; size = 4
_fCalcValidRects$ = -36					; size = 4
_oldrect$ = -28						; size = 16
_rect$ = -8						; size = 4
_nccsp$ = -4						; size = 4
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCCalcSize PROC NEAR

; 2674 : {

  056f0	55		 push	 ebp
  056f1	8b ec		 mov	 ebp, esp
  056f3	83 ec 30	 sub	 esp, 48			; 00000030H
  056f6	56		 push	 esi
  056f7	57		 push	 edi
  056f8	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  056fb	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  05700	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  05705	f3 ab		 rep stosd

; 2675 : 	NCCALCSIZE_PARAMS *nccsp;
; 2676 : 	RECT *rect;
; 2677 : 	RECT oldrect;
; 2678 : 	BOOL fCalcValidRects = (wParam == TRUE);

  05707	33 c0		 xor	 eax, eax
  05709	83 7d 10 01	 cmp	 DWORD PTR _wParam$[ebp], 1
  0570d	0f 94 c0	 sete	 al
  05710	89 45 dc	 mov	 DWORD PTR _fCalcValidRects$[ebp], eax

; 2679 : 	SCROLLBAR *sb;
; 2680 : 	LRESULT ret;
; 2681 : 	DWORD dwStyle;
; 2682 : 
; 2683 : 	//Regardless of the value of fCalcValidRects, the first rectangle 
; 2684 : 	//in the array specified by the rgrc structure member of the 
; 2685 : 	//NCCALCSIZE_PARAMS structure contains the coordinates of the window,
; 2686 : 	//so we can use the exact same code to modify this rectangle, when
; 2687 : 	//wParam is TRUE and when it is FALSE.
; 2688 : 	nccsp = (NCCALCSIZE_PARAMS *)lParam;

  05713	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  05716	89 4d fc	 mov	 DWORD PTR _nccsp$[ebp], ecx

; 2689 : 	rect = &nccsp->rgrc[0];

  05719	8b 55 fc	 mov	 edx, DWORD PTR _nccsp$[ebp]
  0571c	89 55 f8	 mov	 DWORD PTR _rect$[ebp], edx

; 2690 : 	oldrect = *rect;

  0571f	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp]
  05722	8b 08		 mov	 ecx, DWORD PTR [eax]
  05724	89 4d e4	 mov	 DWORD PTR _oldrect$[ebp], ecx
  05727	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0572a	89 55 e8	 mov	 DWORD PTR _oldrect$[ebp+4], edx
  0572d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  05730	89 4d ec	 mov	 DWORD PTR _oldrect$[ebp+8], ecx
  05733	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  05736	89 55 f0	 mov	 DWORD PTR _oldrect$[ebp+12], edx

; 2691 : 
; 2692 : 	dwStyle = GetWindowLong(hwnd, GWL_STYLE);

  05739	8b f4		 mov	 esi, esp
  0573b	6a f0		 push	 -16			; fffffff0H
  0573d	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05740	50		 push	 eax
  05741	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowLongA@8
  05747	3b f4		 cmp	 esi, esp
  05749	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0574e	89 45 d0	 mov	 DWORD PTR _dwStyle$[ebp], eax

; 2693 : 
; 2694 : 	// TURN OFF SCROLL-STYLES.
; 2695 :     if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )

  05751	8b 4d d0	 mov	 ecx, DWORD PTR _dwStyle$[ebp]
  05754	81 e1 00 00 30
	00		 and	 ecx, 3145728		; 00300000H
  0575a	74 2b		 je	 SHORT $L23558

; 2696 :     {
; 2697 :         sw->bPreventStyleChange = TRUE;

  0575c	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0575f	c7 82 bc 06 00
	00 01 00 00 00	 mov	 DWORD PTR [edx+1724], 1

; 2698 :         SetWindowLong(hwnd, GWL_STYLE, dwStyle & ~(WS_VSCROLL|WS_HSCROLL));

  05769	8b 45 d0	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  0576c	25 ff ff cf ff	 and	 eax, -3145729		; ffcfffffH
  05771	8b f4		 mov	 esi, esp
  05773	50		 push	 eax
  05774	6a f0		 push	 -16			; fffffff0H
  05776	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05779	51		 push	 ecx
  0577a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12
  05780	3b f4		 cmp	 esi, esp
  05782	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23558:

; 2699 :     }
; 2700 : 	
; 2701 : 	//call the default procedure to get the borders allocated
; 2702 : 	ret = CallWindowProc(sw->oldproc, hwnd, WM_NCCALCSIZE, wParam, lParam);

  05787	8b f4		 mov	 esi, esp
  05789	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  0578c	52		 push	 edx
  0578d	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  05790	50		 push	 eax
  05791	68 83 00 00 00	 push	 131			; 00000083H
  05796	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05799	51		 push	 ecx
  0579a	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0579d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  057a0	50		 push	 eax
  057a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  057a7	3b f4		 cmp	 esi, esp
  057a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  057ae	89 45 d4	 mov	 DWORD PTR _ret$[ebp], eax

; 2703 : 
; 2704 : 	// RESTORE PREVIOUS STYLES (if present at all)
; 2705 :     if ( dwStyle & (WS_VSCROLL|WS_HSCROLL) )

  057b1	8b 4d d0	 mov	 ecx, DWORD PTR _dwStyle$[ebp]
  057b4	81 e1 00 00 30
	00		 and	 ecx, 3145728		; 00300000H
  057ba	74 26		 je	 SHORT $L23559

; 2706 :     {
; 2707 :         SetWindowLong(hwnd, GWL_STYLE, dwStyle);

  057bc	8b f4		 mov	 esi, esp
  057be	8b 55 d0	 mov	 edx, DWORD PTR _dwStyle$[ebp]
  057c1	52		 push	 edx
  057c2	6a f0		 push	 -16			; fffffff0H
  057c4	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  057c7	50		 push	 eax
  057c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12
  057ce	3b f4		 cmp	 esi, esp
  057d0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2708 :         sw->bPreventStyleChange = FALSE;

  057d5	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  057d8	c7 81 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1724], 0
$L23559:

; 2709 :     }
; 2710 : 
; 2711 : 	// calculate what the size of each window border is,
; 2712 : 	sw->cxLeftEdge   = rect->left     - oldrect.left;

  057e2	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp]
  057e5	8b 02		 mov	 eax, DWORD PTR [edx]
  057e7	2b 45 e4	 sub	 eax, DWORD PTR _oldrect$[ebp]
  057ea	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  057ed	89 81 ac 06 00
	00		 mov	 DWORD PTR [ecx+1708], eax

; 2713 : 	sw->cxRightEdge  = oldrect.right  - rect->right;

  057f3	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp]
  057f6	8b 45 ec	 mov	 eax, DWORD PTR _oldrect$[ebp+8]
  057f9	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  057fc	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  057ff	89 81 b0 06 00
	00		 mov	 DWORD PTR [ecx+1712], eax

; 2714 : 	sw->cyTopEdge    = rect->top      - oldrect.top;

  05805	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp]
  05808	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0580b	2b 45 e8	 sub	 eax, DWORD PTR _oldrect$[ebp+4]
  0580e	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  05811	89 81 b4 06 00
	00		 mov	 DWORD PTR [ecx+1716], eax

; 2715 : 	sw->cyBottomEdge = oldrect.bottom - rect->bottom;

  05817	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp]
  0581a	8b 45 f0	 mov	 eax, DWORD PTR _oldrect$[ebp+12]
  0581d	2b 42 0c	 sub	 eax, DWORD PTR [edx+12]
  05820	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  05823	89 81 b8 06 00
	00		 mov	 DWORD PTR [ecx+1720], eax

; 2716 : 
; 2717 : 	sb = &sw->sbarHorz;

  05829	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0582c	83 c2 08	 add	 edx, 8
  0582f	89 55 d8	 mov	 DWORD PTR _sb$[ebp], edx

; 2718 : 
; 2719 : 	//if there is room, allocate some space for the horizontal scrollbar
; 2720 : 	//NOTE: Change the ">" to a ">=" to make the horz bar totally fill the
; 2721 : 	//window before disappearing
; 2722 : 	if((sb->fScrollFlags & CSBS_VISIBLE) && 
; 2723 : #ifdef COOLSB_FILLWINDOW
; 2724 : 		rect->bottom - rect->top >= GetScrollMetric(sb, SM_CYHORZSB))
; 2725 : #else
; 2726 : 		rect->bottom - rect->top > GetScrollMetric(sb, SM_CYHORZSB))

  05832	8b 45 d8	 mov	 eax, DWORD PTR _sb$[ebp]
  05835	8b 08		 mov	 ecx, DWORD PTR [eax]
  05837	83 e1 08	 and	 ecx, 8
  0583a	74 46		 je	 SHORT $L23560
  0583c	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp]
  0583f	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp]
  05842	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  05845	2b 70 04	 sub	 esi, DWORD PTR [eax+4]
  05848	6a 01		 push	 1
  0584a	8b 4d d8	 mov	 ecx, DWORD PTR _sb$[ebp]
  0584d	51		 push	 ecx
  0584e	e8 00 00 00 00	 call	 _GetScrollMetric
  05853	83 c4 08	 add	 esp, 8
  05856	3b f0		 cmp	 esi, eax
  05858	7e 28		 jle	 SHORT $L23560

; 2727 : #endif
; 2728 : 	{
; 2729 : 		rect->bottom -= GetScrollMetric(sb, SM_CYHORZSB);

  0585a	6a 01		 push	 1
  0585c	8b 55 d8	 mov	 edx, DWORD PTR _sb$[ebp]
  0585f	52		 push	 edx
  05860	e8 00 00 00 00	 call	 _GetScrollMetric
  05865	83 c4 08	 add	 esp, 8
  05868	8b 4d f8	 mov	 ecx, DWORD PTR _rect$[ebp]
  0586b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0586e	2b d0		 sub	 edx, eax
  05870	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp]
  05873	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 2730 : 		sb->fScrollVisible = TRUE;

  05876	8b 4d d8	 mov	 ecx, DWORD PTR _sb$[ebp]
  05879	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 2731 : 	}
; 2732 : 	else

  05880	eb 0a		 jmp	 SHORT $L23561
$L23560:

; 2733 : 		sb->fScrollVisible = FALSE;

  05882	8b 55 d8	 mov	 edx, DWORD PTR _sb$[ebp]
  05885	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L23561:

; 2734 : 
; 2735 : 	sb = &sw->sbarVert;

  0588c	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  0588f	05 54 03 00 00	 add	 eax, 852		; 00000354H
  05894	89 45 d8	 mov	 DWORD PTR _sb$[ebp], eax

; 2736 : 
; 2737 : 	//if there is room, allocate some space for the vertical scrollbar
; 2738 : 	if((sb->fScrollFlags & CSBS_VISIBLE) && 
; 2739 : 		rect->right - rect->left >= GetScrollMetric(sb, SM_CXVERTSB))

  05897	8b 4d d8	 mov	 ecx, DWORD PTR _sb$[ebp]
  0589a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0589c	83 e2 08	 and	 edx, 8
  0589f	74 6b		 je	 SHORT $L23562
  058a1	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp]
  058a4	8b 4d f8	 mov	 ecx, DWORD PTR _rect$[ebp]
  058a7	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  058aa	2b 31		 sub	 esi, DWORD PTR [ecx]
  058ac	6a 01		 push	 1
  058ae	8b 55 d8	 mov	 edx, DWORD PTR _sb$[ebp]
  058b1	52		 push	 edx
  058b2	e8 00 00 00 00	 call	 _GetScrollMetric
  058b7	83 c4 08	 add	 esp, 8
  058ba	3b f0		 cmp	 esi, eax
  058bc	7c 4e		 jl	 SHORT $L23562

; 2740 : 	{
; 2741 : 		if(sw->fLeftScrollbar)

  058be	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  058c1	83 b8 a4 06 00
	00 00		 cmp	 DWORD PTR [eax+1700], 0
  058c8	74 1a		 je	 SHORT $L23563

; 2742 : 			rect->left  += GetScrollMetric(sb, SM_CXVERTSB);

  058ca	6a 01		 push	 1
  058cc	8b 4d d8	 mov	 ecx, DWORD PTR _sb$[ebp]
  058cf	51		 push	 ecx
  058d0	e8 00 00 00 00	 call	 _GetScrollMetric
  058d5	83 c4 08	 add	 esp, 8
  058d8	8b 55 f8	 mov	 edx, DWORD PTR _rect$[ebp]
  058db	03 02		 add	 eax, DWORD PTR [edx]
  058dd	8b 4d f8	 mov	 ecx, DWORD PTR _rect$[ebp]
  058e0	89 01		 mov	 DWORD PTR [ecx], eax

; 2743 : 		else

  058e2	eb 1c		 jmp	 SHORT $L23564
$L23563:

; 2744 : 			rect->right -= GetScrollMetric(sb, SM_CXVERTSB);

  058e4	6a 01		 push	 1
  058e6	8b 55 d8	 mov	 edx, DWORD PTR _sb$[ebp]
  058e9	52		 push	 edx
  058ea	e8 00 00 00 00	 call	 _GetScrollMetric
  058ef	83 c4 08	 add	 esp, 8
  058f2	8b 4d f8	 mov	 ecx, DWORD PTR _rect$[ebp]
  058f5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  058f8	2b d0		 sub	 edx, eax
  058fa	8b 45 f8	 mov	 eax, DWORD PTR _rect$[ebp]
  058fd	89 50 08	 mov	 DWORD PTR [eax+8], edx
$L23564:

; 2745 : 
; 2746 : 		sb->fScrollVisible = TRUE;

  05900	8b 4d d8	 mov	 ecx, DWORD PTR _sb$[ebp]
  05903	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 2747 : 	}
; 2748 : 	else

  0590a	eb 0a		 jmp	 SHORT $L23565
$L23562:

; 2749 : 		sb->fScrollVisible = FALSE;

  0590c	8b 55 d8	 mov	 edx, DWORD PTR _sb$[ebp]
  0590f	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$L23565:

; 2750 : 
; 2751 : #ifdef INCLUDE_BUTTONS
; 2752 : #ifdef RESIZABLE_BUTTONS
; 2753 : 	ResizeButtonsToFit(sw, &sw->sbarHorz, hwnd);

  05916	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05919	50		 push	 eax
  0591a	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  0591d	83 c1 08	 add	 ecx, 8
  05920	51		 push	 ecx
  05921	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  05924	52		 push	 edx
  05925	e8 00 00 00 00	 call	 _ResizeButtonsToFit
  0592a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2754 : 	ResizeButtonsToFit(sw, &sw->sbarVert, hwnd);

  0592d	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05930	50		 push	 eax
  05931	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  05934	81 c1 54 03 00
	00		 add	 ecx, 852		; 00000354H
  0593a	51		 push	 ecx
  0593b	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  0593e	52		 push	 edx
  0593f	e8 00 00 00 00	 call	 _ResizeButtonsToFit
  05944	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2755 : #endif
; 2756 : #endif
; 2757 : 
; 2758 : 	//don't return a value unless we actually modify the other rectangles
; 2759 : 	//in the NCCALCSIZE_PARAMS structure. In this case, we return 0
; 2760 : 	//no matter what the value of fCalcValidRects is
; 2761 : 	return ret;//FALSE;

  05947	8b 45 d4	 mov	 eax, DWORD PTR _ret$[ebp]

; 2762 : }

  0594a	52		 push	 edx
  0594b	8b cd		 mov	 ecx, ebp
  0594d	50		 push	 eax
  0594e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L24040
  05954	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  05959	58		 pop	 eax
  0595a	5a		 pop	 edx
  0595b	5f		 pop	 edi
  0595c	5e		 pop	 esi
  0595d	83 c4 30	 add	 esp, 48			; 00000030H
  05960	3b ec		 cmp	 ebp, esp
  05962	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05967	8b e5		 mov	 esp, ebp
  05969	5d		 pop	 ebp
  0596a	c3		 ret	 0
$L24040:
  0596b	01 00 00 00	 DD	 1
  0596f	00 00 00 00	 DD	 $L24039
$L24039:
  05973	e4 ff ff ff	 DD	 -28			; ffffffe4H
  05977	10 00 00 00	 DD	 16			; 00000010H
  0597b	00 00 00 00	 DD	 $L24038
$L24038:
  0597f	6f		 DB	 111			; 0000006fH
  05980	6c		 DB	 108			; 0000006cH
  05981	64		 DB	 100			; 00000064H
  05982	72		 DB	 114			; 00000072H
  05983	65		 DB	 101			; 00000065H
  05984	63		 DB	 99			; 00000063H
  05985	74		 DB	 116			; 00000074H
  05986	00		 DB	 0
_NCCalcSize ENDP
; Function compile flags: /Odt /RTCsu
_oldsize$23534 = -48					; size = 4
_sbut$ = -44						; size = 4
_i$ = -40						; size = 4
_scrollsize$ = -36					; size = 4
_rc$ = -28						; size = 16
_butsize2$ = -8						; size = 4
_butsize1$ = -4						; size = 4
_sw$ = 8						; size = 4
_sbar$ = 12						; size = 4
_hwnd$ = 16						; size = 4
_ResizeButtonsToFit PROC NEAR

; 2608 : {

  05990	55		 push	 ebp
  05991	8b ec		 mov	 ebp, esp
  05993	83 ec 30	 sub	 esp, 48			; 00000030H
  05996	57		 push	 edi
  05997	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0599a	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0599f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  059a4	f3 ab		 rep stosd

; 2609 : 	int butsize1, butsize2;
; 2610 : 	RECT rc;
; 2611 : 	int scrollsize;
; 2612 : 	int i;
; 2613 : 	SCROLLBUT *sbut;
; 2614 : 
; 2615 : 	//make sure that the scrollbar can fit into space, by
; 2616 : 	//shrinking any resizable buttons
; 2617 : 	GetScrollRect(sw, sbar->nBarType, hwnd, &rc);

  059a6	8d 45 e4	 lea	 eax, DWORD PTR _rc$[ebp]
  059a9	50		 push	 eax
  059aa	8b 4d 10	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  059ad	51		 push	 ecx
  059ae	8b 55 0c	 mov	 edx, DWORD PTR _sbar$[ebp]
  059b1	8b 82 40 03 00
	00		 mov	 eax, DWORD PTR [edx+832]
  059b7	50		 push	 eax
  059b8	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  059bb	51		 push	 ecx
  059bc	e8 00 00 00 00	 call	 _GetScrollRect
  059c1	83 c4 10	 add	 esp, 16			; 00000010H

; 2618 : 
; 2619 : 	if(sbar->nBarType == SB_HORZ)

  059c4	8b 55 0c	 mov	 edx, DWORD PTR _sbar$[ebp]
  059c7	83 ba 40 03 00
	00 00		 cmp	 DWORD PTR [edx+832], 0
  059ce	75 0b		 jne	 SHORT $L23523

; 2620 : 		scrollsize = rc.right-rc.left;

  059d0	8b 45 ec	 mov	 eax, DWORD PTR _rc$[ebp+8]
  059d3	2b 45 e4	 sub	 eax, DWORD PTR _rc$[ebp]
  059d6	89 45 dc	 mov	 DWORD PTR _scrollsize$[ebp], eax

; 2621 : 	else

  059d9	eb 09		 jmp	 SHORT $L23524
$L23523:

; 2622 : 		scrollsize = rc.bottom-rc.top;

  059db	8b 4d f0	 mov	 ecx, DWORD PTR _rc$[ebp+12]
  059de	2b 4d e8	 sub	 ecx, DWORD PTR _rc$[ebp+4]
  059e1	89 4d dc	 mov	 DWORD PTR _scrollsize$[ebp], ecx
$L23524:

; 2623 : 
; 2624 : 	//restore any resizable buttons to their user-defined sizes,
; 2625 : 	//before shrinking them to fit. This means when we make the window
; 2626 : 	//bigger, the buttons will restore to their initial sizes
; 2627 : 	for(i = 0; i < sbar->nButtons; i++)

  059e4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  059eb	eb 09		 jmp	 SHORT $L23525
$L23526:
  059ed	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  059f0	83 c2 01	 add	 edx, 1
  059f3	89 55 d8	 mov	 DWORD PTR _i$[ebp], edx
$L23525:
  059f6	8b 45 0c	 mov	 eax, DWORD PTR _sbar$[ebp]
  059f9	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  059fc	3b 88 2c 03 00
	00		 cmp	 ecx, DWORD PTR [eax+812]
  05a02	7d 2b		 jge	 SHORT $L23527

; 2628 : 	{
; 2629 : 		sbut = &sbar->sbButtons[i];

  05a04	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  05a07	6b d2 30	 imul	 edx, 48			; 00000030H
  05a0a	8b 45 0c	 mov	 eax, DWORD PTR _sbar$[ebp]
  05a0d	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  05a11	89 4d d4	 mov	 DWORD PTR _sbut$[ebp], ecx

; 2630 : 		if(sbut->uButType & SBBM_RESIZABLE)

  05a14	8b 55 d4	 mov	 edx, DWORD PTR _sbut$[ebp]
  05a17	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  05a1a	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  05a1f	74 0c		 je	 SHORT $L23528

; 2631 : 		{
; 2632 : 			sbut->nSize = sbut->nSizeReserved;

  05a21	8b 4d d4	 mov	 ecx, DWORD PTR _sbut$[ebp]
  05a24	8b 55 d4	 mov	 edx, DWORD PTR _sbut$[ebp]
  05a27	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  05a2a	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23528:

; 2633 : 		}
; 2634 : 	}

  05a2d	eb be		 jmp	 SHORT $L23526
$L23527:

; 2635 : 	
; 2636 : 	butsize1 = GetButtonSize(sbar, hwnd, SBBP_LEFT);

  05a2f	6a 01		 push	 1
  05a31	8b 4d 10	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05a34	51		 push	 ecx
  05a35	8b 55 0c	 mov	 edx, DWORD PTR _sbar$[ebp]
  05a38	52		 push	 edx
  05a39	e8 00 00 00 00	 call	 _GetButtonSize
  05a3e	83 c4 0c	 add	 esp, 12			; 0000000cH
  05a41	89 45 fc	 mov	 DWORD PTR _butsize1$[ebp], eax

; 2637 : 	butsize2 = GetButtonSize(sbar, hwnd, SBBP_RIGHT);

  05a44	6a 02		 push	 2
  05a46	8b 45 10	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05a49	50		 push	 eax
  05a4a	8b 4d 0c	 mov	 ecx, DWORD PTR _sbar$[ebp]
  05a4d	51		 push	 ecx
  05a4e	e8 00 00 00 00	 call	 _GetButtonSize
  05a53	83 c4 0c	 add	 esp, 12			; 0000000cH
  05a56	89 45 f8	 mov	 DWORD PTR _butsize2$[ebp], eax

; 2638 : 
; 2639 : 	if(butsize1 + butsize2 > scrollsize - MINSCROLLSIZE)

  05a59	8b 55 fc	 mov	 edx, DWORD PTR _butsize1$[ebp]
  05a5c	03 55 f8	 add	 edx, DWORD PTR _butsize2$[ebp]
  05a5f	8b 45 dc	 mov	 eax, DWORD PTR _scrollsize$[ebp]
  05a62	83 e8 32	 sub	 eax, 50			; 00000032H
  05a65	3b d0		 cmp	 edx, eax
  05a67	0f 8e c3 00 00
	00		 jle	 $L23516

; 2640 : 	{
; 2641 : 		i = 0;

  05a6d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$L23531:

; 2642 : 		while(i < sbar->nButtons && 
; 2643 : 			butsize1 + butsize2 > scrollsize - MINSCROLLSIZE)

  05a74	8b 4d 0c	 mov	 ecx, DWORD PTR _sbar$[ebp]
  05a77	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  05a7a	3b 91 2c 03 00
	00		 cmp	 edx, DWORD PTR [ecx+812]
  05a80	0f 8d aa 00 00
	00		 jge	 $L23516
  05a86	8b 45 fc	 mov	 eax, DWORD PTR _butsize1$[ebp]
  05a89	03 45 f8	 add	 eax, DWORD PTR _butsize2$[ebp]
  05a8c	8b 4d dc	 mov	 ecx, DWORD PTR _scrollsize$[ebp]
  05a8f	83 e9 32	 sub	 ecx, 50			; 00000032H
  05a92	3b c1		 cmp	 eax, ecx
  05a94	0f 8e 96 00 00
	00		 jle	 $L23516

; 2644 : 		{
; 2645 : 			sbut = &sbar->sbButtons[i++];

  05a9a	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  05a9d	6b d2 30	 imul	 edx, 48			; 00000030H
  05aa0	8b 45 0c	 mov	 eax, DWORD PTR _sbar$[ebp]
  05aa3	8d 4c 10 2c	 lea	 ecx, DWORD PTR [eax+edx+44]
  05aa7	89 4d d4	 mov	 DWORD PTR _sbut$[ebp], ecx
  05aaa	8b 55 d8	 mov	 edx, DWORD PTR _i$[ebp]
  05aad	83 c2 01	 add	 edx, 1
  05ab0	89 55 d8	 mov	 DWORD PTR _i$[ebp], edx

; 2646 : 			if(sbut->uButType & SBBM_RESIZABLE)

  05ab3	8b 45 d4	 mov	 eax, DWORD PTR _sbut$[ebp]
  05ab6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  05ab9	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  05abf	74 6a		 je	 SHORT $L23533

; 2647 : 			{
; 2648 : 				int oldsize = sbut->nSize;

  05ac1	8b 55 d4	 mov	 edx, DWORD PTR _sbut$[ebp]
  05ac4	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  05ac7	89 45 d0	 mov	 DWORD PTR _oldsize$23534[ebp], eax

; 2649 : 				sbut->nSize -= (butsize1+butsize2) - (scrollsize-MINSCROLLSIZE);

  05aca	8b 4d fc	 mov	 ecx, DWORD PTR _butsize1$[ebp]
  05acd	03 4d f8	 add	 ecx, DWORD PTR _butsize2$[ebp]
  05ad0	8b 55 dc	 mov	 edx, DWORD PTR _scrollsize$[ebp]
  05ad3	83 ea 32	 sub	 edx, 50			; 00000032H
  05ad6	2b ca		 sub	 ecx, edx
  05ad8	8b 45 d4	 mov	 eax, DWORD PTR _sbut$[ebp]
  05adb	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  05ade	2b d1		 sub	 edx, ecx
  05ae0	8b 45 d4	 mov	 eax, DWORD PTR _sbut$[ebp]
  05ae3	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2650 : 
; 2651 : 				if(sbut->nSize < (int)sbut->nMinSize)

  05ae6	8b 4d d4	 mov	 ecx, DWORD PTR _sbut$[ebp]
  05ae9	8b 55 d4	 mov	 edx, DWORD PTR _sbut$[ebp]
  05aec	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  05aef	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  05af2	7d 0c		 jge	 SHORT $L23536

; 2652 : 					sbut->nSize = sbut->nMinSize;

  05af4	8b 4d d4	 mov	 ecx, DWORD PTR _sbut$[ebp]
  05af7	8b 55 d4	 mov	 edx, DWORD PTR _sbut$[ebp]
  05afa	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  05afd	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23536:

; 2653 : 
; 2654 : 				if((UINT)sbut->nSize > (UINT)sbut->nMaxSize)

  05b00	8b 4d d4	 mov	 ecx, DWORD PTR _sbut$[ebp]
  05b03	8b 55 d4	 mov	 edx, DWORD PTR _sbut$[ebp]
  05b06	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  05b09	3b 42 2c	 cmp	 eax, DWORD PTR [edx+44]
  05b0c	76 0c		 jbe	 SHORT $L23539

; 2655 : 					sbut->nSize = sbut->nMaxSize;

  05b0e	8b 4d d4	 mov	 ecx, DWORD PTR _sbut$[ebp]
  05b11	8b 55 d4	 mov	 edx, DWORD PTR _sbut$[ebp]
  05b14	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  05b17	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$L23539:

; 2656 : 
; 2657 : 				
; 2658 : 				butsize1 -= (oldsize - sbut->nSize);

  05b1a	8b 4d d4	 mov	 ecx, DWORD PTR _sbut$[ebp]
  05b1d	8b 55 d0	 mov	 edx, DWORD PTR _oldsize$23534[ebp]
  05b20	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  05b23	8b 45 fc	 mov	 eax, DWORD PTR _butsize1$[ebp]
  05b26	2b c2		 sub	 eax, edx
  05b28	89 45 fc	 mov	 DWORD PTR _butsize1$[ebp], eax
$L23533:

; 2659 : 			}
; 2660 : 		}

  05b2b	e9 44 ff ff ff	 jmp	 $L23531
$L23516:

; 2661 : 	}
; 2662 : 
; 2663 : }

  05b30	52		 push	 edx
  05b31	8b cd		 mov	 ecx, ebp
  05b33	50		 push	 eax
  05b34	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L24044
  05b3a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  05b3f	58		 pop	 eax
  05b40	5a		 pop	 edx
  05b41	5f		 pop	 edi
  05b42	83 c4 30	 add	 esp, 48			; 00000030H
  05b45	3b ec		 cmp	 ebp, esp
  05b47	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05b4c	8b e5		 mov	 esp, ebp
  05b4e	5d		 pop	 ebp
  05b4f	c3		 ret	 0
$L24044:
  05b50	01 00 00 00	 DD	 1
  05b54	00 00 00 00	 DD	 $L24043
$L24043:
  05b58	e4 ff ff ff	 DD	 -28			; ffffffe4H
  05b5c	10 00 00 00	 DD	 16			; 00000010H
  05b60	00 00 00 00	 DD	 $L24042
$L24042:
  05b64	72		 DB	 114			; 00000072H
  05b65	63		 DB	 99			; 00000063H
  05b66	00		 DB	 0
_ResizeButtonsToFit ENDP
_TEXT	ENDS
_BSS	SEGMENT
_MouseOverRect DB 010H DUP (?)
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
_TEXT	SEGMENT
_sw$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wHitTest$ = 16						; size = 4
_lParam$ = 20						; size = 4
_NCMouseMove PROC NEAR

; 2768 : {

  05b70	55		 push	 ebp
  05b71	8b ec		 mov	 ebp, esp
  05b73	56		 push	 esi

; 2769 : 	//install a timer for the mouse-over events, if the mouse moves
; 2770 : 	//over one of the scrollbars
; 2771 : #ifdef HOT_TRACKING
; 2772 : 	hwndCurCoolSB = hwnd;

  05b74	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05b77	a3 00 00 00 00	 mov	 DWORD PTR _hwndCurCoolSB, eax

; 2773 : 	if(wHitTest == HTHSCROLL)

  05b7c	83 7d 10 06	 cmp	 DWORD PTR _wHitTest$[ebp], 6
  05b80	0f 85 a1 00 00
	00		 jne	 $L23576

; 2774 : 	{
; 2775 : 		if(uMouseOverScrollbar == SB_HORZ)

  05b86	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uMouseOverScrollbar, 0
  05b8d	75 2c		 jne	 SHORT $L23577

; 2776 : 			return CallWindowProc(sw->oldproc, hwnd, WM_NCMOUSEMOVE, wHitTest, lParam);

  05b8f	8b f4		 mov	 esi, esp
  05b91	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  05b94	51		 push	 ecx
  05b95	8b 55 10	 mov	 edx, DWORD PTR _wHitTest$[ebp]
  05b98	52		 push	 edx
  05b99	68 a0 00 00 00	 push	 160			; 000000a0H
  05b9e	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05ba1	50		 push	 eax
  05ba2	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  05ba5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  05ba8	52		 push	 edx
  05ba9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  05baf	3b f4		 cmp	 esi, esp
  05bb1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05bb6	e9 39 01 00 00	 jmp	 $L23575
$L23577:

; 2777 : 
; 2778 : 		uLastHitTestPortion = HTSCROLL_NONE;

  05bbb	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uLastHitTestPortion, -1

; 2779 : 		uHitTestPortion     = HTSCROLL_NONE;

  05bc5	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uHitTestPortion, -1

; 2780 : 		GetScrollRect(sw, SB_HORZ, hwnd, &MouseOverRect);

  05bcf	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  05bd4	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05bd7	50		 push	 eax
  05bd8	6a 00		 push	 0
  05bda	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  05bdd	51		 push	 ecx
  05bde	e8 00 00 00 00	 call	 _GetScrollRect
  05be3	83 c4 10	 add	 esp, 16			; 00000010H

; 2781 : 		uMouseOverScrollbar = SB_HORZ;

  05be6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uMouseOverScrollbar, 0

; 2782 : #pragma warning( disable: 4244)		
; 2783 : 		uMouseOverId = SetTimer(hwnd, COOLSB_TIMERID3, COOLSB_TIMERINTERVAL3, 0);

  05bf0	8b f4		 mov	 esi, esp
  05bf2	6a 00		 push	 0
  05bf4	6a 14		 push	 20			; 00000014H
  05bf6	6a f2		 push	 -14			; fffffff2H
  05bf8	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05bfb	52		 push	 edx
  05bfc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  05c02	3b f4		 cmp	 esi, esp
  05c04	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05c09	a3 00 00 00 00	 mov	 DWORD PTR _uMouseOverId, eax

; 2784 : 	
; 2785 : 		NCPaint(sw, hwnd, 1, 0);

  05c0e	6a 00		 push	 0
  05c10	6a 01		 push	 1
  05c12	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05c15	50		 push	 eax
  05c16	8b 4d 08	 mov	 ecx, DWORD PTR _sw$[ebp]
  05c19	51		 push	 ecx
  05c1a	e8 00 00 00 00	 call	 _NCPaint
  05c1f	83 c4 10	 add	 esp, 16			; 00000010H

; 2786 : 	}
; 2787 : 	else if(wHitTest == HTVSCROLL)

  05c22	e9 a6 00 00 00	 jmp	 $L23578
$L23576:
  05c27	83 7d 10 07	 cmp	 DWORD PTR _wHitTest$[ebp], 7
  05c2b	0f 85 9c 00 00
	00		 jne	 $L23578

; 2788 : 	{
; 2789 : 		if(uMouseOverScrollbar == SB_VERT)

  05c31	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _uMouseOverScrollbar, 1
  05c38	75 2c		 jne	 SHORT $L23580

; 2790 : 			return CallWindowProc(sw->oldproc, hwnd, WM_NCMOUSEMOVE, wHitTest, lParam);

  05c3a	8b f4		 mov	 esi, esp
  05c3c	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  05c3f	52		 push	 edx
  05c40	8b 45 10	 mov	 eax, DWORD PTR _wHitTest$[ebp]
  05c43	50		 push	 eax
  05c44	68 a0 00 00 00	 push	 160			; 000000a0H
  05c49	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05c4c	51		 push	 ecx
  05c4d	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  05c50	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  05c53	50		 push	 eax
  05c54	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  05c5a	3b f4		 cmp	 esi, esp
  05c5c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05c61	e9 8e 00 00 00	 jmp	 $L23575
$L23580:

; 2791 : 
; 2792 : 		uLastHitTestPortion = HTSCROLL_NONE;

  05c66	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uLastHitTestPortion, -1

; 2793 : 		uHitTestPortion     = HTSCROLL_NONE;

  05c70	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uHitTestPortion, -1

; 2794 : 		GetScrollRect(sw, SB_VERT, hwnd, &MouseOverRect);

  05c7a	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  05c7f	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05c82	51		 push	 ecx
  05c83	6a 01		 push	 1
  05c85	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  05c88	52		 push	 edx
  05c89	e8 00 00 00 00	 call	 _GetScrollRect
  05c8e	83 c4 10	 add	 esp, 16			; 00000010H

; 2795 : 		uMouseOverScrollbar = SB_VERT;

  05c91	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _uMouseOverScrollbar, 1

; 2796 : 		uMouseOverId = SetTimer(hwnd, COOLSB_TIMERID3, COOLSB_TIMERINTERVAL3, 0);

  05c9b	8b f4		 mov	 esi, esp
  05c9d	6a 00		 push	 0
  05c9f	6a 14		 push	 20			; 00000014H
  05ca1	6a f2		 push	 -14			; fffffff2H
  05ca3	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05ca6	50		 push	 eax
  05ca7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  05cad	3b f4		 cmp	 esi, esp
  05caf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05cb4	a3 00 00 00 00	 mov	 DWORD PTR _uMouseOverId, eax

; 2797 : #pragma warning( default: 4244)	
; 2798 : 		NCPaint(sw, hwnd, 1, 0);

  05cb9	6a 00		 push	 0
  05cbb	6a 01		 push	 1
  05cbd	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05cc0	51		 push	 ecx
  05cc1	8b 55 08	 mov	 edx, DWORD PTR _sw$[ebp]
  05cc4	52		 push	 edx
  05cc5	e8 00 00 00 00	 call	 _NCPaint
  05cca	83 c4 10	 add	 esp, 16			; 00000010H
$L23578:

; 2799 : 	}
; 2800 : 
; 2801 : #endif //HOT_TRACKING
; 2802 : 	return CallWindowProc(sw->oldproc, hwnd, WM_NCMOUSEMOVE, wHitTest, lParam);

  05ccd	8b f4		 mov	 esi, esp
  05ccf	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  05cd2	50		 push	 eax
  05cd3	8b 4d 10	 mov	 ecx, DWORD PTR _wHitTest$[ebp]
  05cd6	51		 push	 ecx
  05cd7	68 a0 00 00 00	 push	 160			; 000000a0H
  05cdc	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05cdf	52		 push	 edx
  05ce0	8b 45 08	 mov	 eax, DWORD PTR _sw$[ebp]
  05ce3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  05ce6	51		 push	 ecx
  05ce7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  05ced	3b f4		 cmp	 esi, esp
  05cef	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23575:

; 2803 : }

  05cf4	5e		 pop	 esi
  05cf5	3b ec		 cmp	 ebp, esp
  05cf7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05cfc	5d		 pop	 ebp
  05cfd	c3		 ret	 0
_NCMouseMove ENDP
_TEXT	ENDS
EXTRN	__imp__GetCursorPos@4:NEAR
EXTRN	__imp__ScreenToClient@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_pt$23607 = -84						; size = 8
_sbar$23597 = -72					; size = 4
_hdc$23596 = -68					; size = 4
_winrect$23595 = -60					; size = 16
_rect$23594 = -36					; size = 16
_pt$23593 = -12						; size = 8
_swnd$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wTimerId$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CoolSB_Timer PROC NEAR

; 2809 : {

  05d00	55		 push	 ebp
  05d01	8b ec		 mov	 ebp, esp
  05d03	83 ec 58	 sub	 esp, 88			; 00000058H
  05d06	56		 push	 esi
  05d07	57		 push	 edi
  05d08	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  05d0b	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  05d10	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  05d15	f3 ab		 rep stosd

; 2810 : 	//let all timer messages go past if we don't have a timer installed ourselves
; 2811 : 	if(uScrollTimerId == 0 && uMouseOverId == 0)

  05d17	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uScrollTimerId, 0
  05d1e	75 35		 jne	 SHORT $L23591
  05d20	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uMouseOverId, 0
  05d27	75 2c		 jne	 SHORT $L23591

; 2812 : 	{
; 2813 : 		return CallWindowProc(swnd->oldproc, hwnd, WM_TIMER, wTimerId, lParam);

  05d29	8b f4		 mov	 esi, esp
  05d2b	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  05d2e	50		 push	 eax
  05d2f	8b 4d 10	 mov	 ecx, DWORD PTR _wTimerId$[ebp]
  05d32	51		 push	 ecx
  05d33	68 13 01 00 00	 push	 275			; 00000113H
  05d38	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05d3b	52		 push	 edx
  05d3c	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  05d3f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  05d42	51		 push	 ecx
  05d43	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  05d49	3b f4		 cmp	 esi, esp
  05d4b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05d50	e9 e0 02 00 00	 jmp	 $L23590
$L23591:

; 2814 : 	}
; 2815 : 
; 2816 : #ifdef HOT_TRACKING
; 2817 : 	//mouse-over timer
; 2818 : 	if(wTimerId == COOLSB_TIMERID3)

  05d55	83 7d 10 f2	 cmp	 DWORD PTR _wTimerId$[ebp], -14 ; fffffff2H
  05d59	0f 85 d5 01 00
	00		 jne	 $L23592

; 2819 : 	{
; 2820 : 		POINT pt;
; 2821 : 		RECT rect, winrect;
; 2822 : 		HDC hdc;
; 2823 : 		SCROLLBAR *sbar;
; 2824 : 
; 2825 : 		if(swnd->fThumbTracking)

  05d5f	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  05d62	83 ba a0 06 00
	00 00		 cmp	 DWORD PTR [edx+1696], 0
  05d69	74 07		 je	 SHORT $L23598

; 2826 : 			return 0;

  05d6b	33 c0		 xor	 eax, eax
  05d6d	e9 c3 02 00 00	 jmp	 $L23590
$L23598:

; 2827 : 
; 2828 : 		//if the mouse moves outside the current scrollbar,
; 2829 : 		//then kill the timer..
; 2830 : 		GetCursorPos(&pt);

  05d72	8b f4		 mov	 esi, esp
  05d74	8d 45 f4	 lea	 eax, DWORD PTR _pt$23593[ebp]
  05d77	50		 push	 eax
  05d78	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4
  05d7e	3b f4		 cmp	 esi, esp
  05d80	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2831 : 
; 2832 : 		if(!PtInRect(&MouseOverRect, pt))

  05d85	8b f4		 mov	 esi, esp
  05d87	8b 4d f8	 mov	 ecx, DWORD PTR _pt$23593[ebp+4]
  05d8a	51		 push	 ecx
  05d8b	8b 55 f4	 mov	 edx, DWORD PTR _pt$23593[ebp]
  05d8e	52		 push	 edx
  05d8f	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  05d94	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  05d9a	3b f4		 cmp	 esi, esp
  05d9c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05da1	85 c0		 test	 eax, eax
  05da3	75 5a		 jne	 SHORT $L23599

; 2833 : 		{
; 2834 : 			KillTimer(hwnd, uMouseOverId);

  05da5	8b f4		 mov	 esi, esp
  05da7	a1 00 00 00 00	 mov	 eax, DWORD PTR _uMouseOverId
  05dac	50		 push	 eax
  05dad	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05db0	51		 push	 ecx
  05db1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8
  05db7	3b f4		 cmp	 esi, esp
  05db9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2835 : 			uMouseOverId = 0;

  05dbe	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _uMouseOverId, 0

; 2836 : 			uMouseOverScrollbar = COOLSB_NONE;

  05dc8	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uMouseOverScrollbar, -1

; 2837 : 			uLastHitTestPortion = HTSCROLL_NONE;

  05dd2	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uLastHitTestPortion, -1

; 2838 : 
; 2839 : 			uHitTestPortion = HTSCROLL_NONE;

  05ddc	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _uHitTestPortion, -1

; 2840 : 			NCPaint(swnd, hwnd, 1, 0);

  05de6	6a 00		 push	 0
  05de8	6a 01		 push	 1
  05dea	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05ded	52		 push	 edx
  05dee	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  05df1	50		 push	 eax
  05df2	e8 00 00 00 00	 call	 _NCPaint
  05df7	83 c4 10	 add	 esp, 16			; 00000010H

; 2841 : 		}
; 2842 : 		else

  05dfa	e9 2e 01 00 00	 jmp	 $L23600
$L23599:

; 2843 : 		{
; 2844 : 			if(uMouseOverScrollbar == SB_HORZ)

  05dff	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _uMouseOverScrollbar, 0
  05e06	75 2d		 jne	 SHORT $L23601

; 2845 : 			{
; 2846 : 				sbar = &swnd->sbarHorz;

  05e08	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  05e0b	83 c1 08	 add	 ecx, 8
  05e0e	89 4d b8	 mov	 DWORD PTR _sbar$23597[ebp], ecx

; 2847 : 				uHitTestPortion = GetHorzPortion(sbar, hwnd, &MouseOverRect, pt.x, pt.y);

  05e11	8b 55 f8	 mov	 edx, DWORD PTR _pt$23593[ebp+4]
  05e14	52		 push	 edx
  05e15	8b 45 f4	 mov	 eax, DWORD PTR _pt$23593[ebp]
  05e18	50		 push	 eax
  05e19	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  05e1e	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05e21	51		 push	 ecx
  05e22	8b 55 b8	 mov	 edx, DWORD PTR _sbar$23597[ebp]
  05e25	52		 push	 edx
  05e26	e8 00 00 00 00	 call	 _GetHorzPortion
  05e2b	83 c4 14	 add	 esp, 20			; 00000014H
  05e2e	a3 00 00 00 00	 mov	 DWORD PTR _uHitTestPortion, eax

; 2848 : 			}
; 2849 : 			else

  05e33	eb 2d		 jmp	 SHORT $L23602
$L23601:

; 2850 : 			{
; 2851 : 				sbar = &swnd->sbarVert;

  05e35	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  05e38	05 54 03 00 00	 add	 eax, 852		; 00000354H
  05e3d	89 45 b8	 mov	 DWORD PTR _sbar$23597[ebp], eax

; 2852 : 				uHitTestPortion = GetVertPortion(sbar, hwnd, &MouseOverRect, pt.x, pt.y);

  05e40	8b 4d f8	 mov	 ecx, DWORD PTR _pt$23593[ebp+4]
  05e43	51		 push	 ecx
  05e44	8b 55 f4	 mov	 edx, DWORD PTR _pt$23593[ebp]
  05e47	52		 push	 edx
  05e48	68 00 00 00 00	 push	 OFFSET FLAT:_MouseOverRect
  05e4d	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05e50	50		 push	 eax
  05e51	8b 4d b8	 mov	 ecx, DWORD PTR _sbar$23597[ebp]
  05e54	51		 push	 ecx
  05e55	e8 00 00 00 00	 call	 _GetVertPortion
  05e5a	83 c4 14	 add	 esp, 20			; 00000014H
  05e5d	a3 00 00 00 00	 mov	 DWORD PTR _uHitTestPortion, eax
$L23602:

; 2853 : 			}
; 2854 : 
; 2855 : 			if(uLastHitTestPortion != uHitTestPortion)

  05e62	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uLastHitTestPortion
  05e68	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _uHitTestPortion
  05e6e	0f 84 af 00 00
	00		 je	 $L23603

; 2856 : 			{
; 2857 : 				rect = MouseOverRect;

  05e74	a1 00 00 00 00	 mov	 eax, DWORD PTR _MouseOverRect
  05e79	89 45 dc	 mov	 DWORD PTR _rect$23594[ebp], eax
  05e7c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _MouseOverRect+4
  05e82	89 4d e0	 mov	 DWORD PTR _rect$23594[ebp+4], ecx
  05e85	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _MouseOverRect+8
  05e8b	89 55 e4	 mov	 DWORD PTR _rect$23594[ebp+8], edx
  05e8e	a1 0c 00 00 00	 mov	 eax, DWORD PTR _MouseOverRect+12
  05e93	89 45 e8	 mov	 DWORD PTR _rect$23594[ebp+12], eax

; 2858 : 				GetRealScrollRect(sbar, &rect);

  05e96	8d 4d dc	 lea	 ecx, DWORD PTR _rect$23594[ebp]
  05e99	51		 push	 ecx
  05e9a	8b 55 b8	 mov	 edx, DWORD PTR _sbar$23597[ebp]
  05e9d	52		 push	 edx
  05e9e	e8 00 00 00 00	 call	 _GetRealScrollRect
  05ea3	83 c4 08	 add	 esp, 8

; 2859 : 
; 2860 : 				GetWindowRect(hwnd, &winrect);

  05ea6	8b f4		 mov	 esi, esp
  05ea8	8d 45 c4	 lea	 eax, DWORD PTR _winrect$23595[ebp]
  05eab	50		 push	 eax
  05eac	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  05eaf	51		 push	 ecx
  05eb0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowRect@8
  05eb6	3b f4		 cmp	 esi, esp
  05eb8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2861 : 				OffsetRect(&rect, -winrect.left, -winrect.top);

  05ebd	8b 55 c8	 mov	 edx, DWORD PTR _winrect$23595[ebp+4]
  05ec0	f7 da		 neg	 edx
  05ec2	8b f4		 mov	 esi, esp
  05ec4	52		 push	 edx
  05ec5	8b 45 c4	 mov	 eax, DWORD PTR _winrect$23595[ebp]
  05ec8	f7 d8		 neg	 eax
  05eca	50		 push	 eax
  05ecb	8d 4d dc	 lea	 ecx, DWORD PTR _rect$23594[ebp]
  05ece	51		 push	 ecx
  05ecf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12
  05ed5	3b f4		 cmp	 esi, esp
  05ed7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2862 : 
; 2863 : 				hdc = GetWindowDC(hwnd);

  05edc	8b f4		 mov	 esi, esp
  05ede	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05ee1	52		 push	 edx
  05ee2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowDC@4
  05ee8	3b f4		 cmp	 esi, esp
  05eea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05eef	89 45 bc	 mov	 DWORD PTR _hdc$23596[ebp], eax

; 2864 : 				NCDrawScrollbar(sbar, hwnd, hdc, &rect, HTSCROLL_NONE);

  05ef2	6a ff		 push	 -1
  05ef4	8d 45 dc	 lea	 eax, DWORD PTR _rect$23594[ebp]
  05ef7	50		 push	 eax
  05ef8	8b 4d bc	 mov	 ecx, DWORD PTR _hdc$23596[ebp]
  05efb	51		 push	 ecx
  05efc	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05eff	52		 push	 edx
  05f00	8b 45 b8	 mov	 eax, DWORD PTR _sbar$23597[ebp]
  05f03	50		 push	 eax
  05f04	e8 00 00 00 00	 call	 _NCDrawScrollbar
  05f09	83 c4 14	 add	 esp, 20			; 00000014H

; 2865 : 				ReleaseDC(hwnd, hdc);

  05f0c	8b f4		 mov	 esi, esp
  05f0e	8b 4d bc	 mov	 ecx, DWORD PTR _hdc$23596[ebp]
  05f11	51		 push	 ecx
  05f12	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05f15	52		 push	 edx
  05f16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
  05f1c	3b f4		 cmp	 esi, esp
  05f1e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23603:

; 2866 : 			}
; 2867 : 			
; 2868 : 			uLastHitTestPortion = uHitTestPortion;

  05f23	a1 00 00 00 00	 mov	 eax, DWORD PTR _uHitTestPortion
  05f28	a3 00 00 00 00	 mov	 DWORD PTR _uLastHitTestPortion, eax
$L23600:

; 2869 : 		}
; 2870 : 
; 2871 : 		return 0;

  05f2d	33 c0		 xor	 eax, eax
  05f2f	e9 01 01 00 00	 jmp	 $L23590
$L23592:

; 2872 : 	}
; 2873 : #endif // HOT_TRACKING
; 2874 : 
; 2875 : 	//if the first timer goes off, then we can start a more
; 2876 : 	//regular timer interval to auto-generate scroll messages
; 2877 : 	//this gives a slight pause between first pressing the scroll arrow, and the
; 2878 : 	//actual scroll starting
; 2879 : 	if(wTimerId == COOLSB_TIMERID1)

  05f34	81 7d 10 fd ff
	00 00		 cmp	 DWORD PTR _wTimerId$[ebp], 65533 ; 0000fffdH
  05f3b	75 42		 jne	 SHORT $L23604

; 2880 : 	{
; 2881 : 		KillTimer(hwnd, uScrollTimerId);

  05f3d	8b f4		 mov	 esi, esp
  05f3f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uScrollTimerId
  05f45	51		 push	 ecx
  05f46	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05f49	52		 push	 edx
  05f4a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8
  05f50	3b f4		 cmp	 esi, esp
  05f52	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2882 : #pragma warning( disable: 4244)	
; 2883 : 		uScrollTimerId = SetTimer(hwnd, COOLSB_TIMERID2, COOLSB_TIMERINTERVAL2, 0);

  05f57	8b f4		 mov	 esi, esp
  05f59	6a 00		 push	 0
  05f5b	6a 37		 push	 55			; 00000037H
  05f5d	68 fe ff 00 00	 push	 65534			; 0000fffeH
  05f62	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05f65	50		 push	 eax
  05f66	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetTimer@16
  05f6c	3b f4		 cmp	 esi, esp
  05f6e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  05f73	a3 00 00 00 00	 mov	 DWORD PTR _uScrollTimerId, eax

; 2884 : #pragma warning( default: 4244)	
; 2885 : 		return 0;

  05f78	33 c0		 xor	 eax, eax
  05f7a	e9 b6 00 00 00	 jmp	 $L23590
$L23604:

; 2886 : 	}
; 2887 : 	//send the scrollbar message repeatedly
; 2888 : 	else if(wTimerId == COOLSB_TIMERID2)

  05f7f	81 7d 10 fe ff
	00 00		 cmp	 DWORD PTR _wTimerId$[ebp], 65534 ; 0000fffeH
  05f86	0f 85 82 00 00
	00		 jne	 $L23606

; 2889 : 	{
; 2890 : 		//need to process a spoof WM_MOUSEMOVE, so that
; 2891 : 		//we know where the mouse is each time the scroll timer goes off.
; 2892 : 		//This is so we can stop sending scroll messages if the thumb moves
; 2893 : 		//under the mouse.
; 2894 : 		POINT pt;
; 2895 : 		GetCursorPos(&pt);

  05f8c	8b f4		 mov	 esi, esp
  05f8e	8d 4d ac	 lea	 ecx, DWORD PTR _pt$23607[ebp]
  05f91	51		 push	 ecx
  05f92	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCursorPos@4
  05f98	3b f4		 cmp	 esi, esp
  05f9a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2896 : 		ScreenToClient(hwnd, &pt);

  05f9f	8b f4		 mov	 esi, esp
  05fa1	8d 55 ac	 lea	 edx, DWORD PTR _pt$23607[ebp]
  05fa4	52		 push	 edx
  05fa5	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  05fa8	50		 push	 eax
  05fa9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ScreenToClient@8
  05faf	3b f4		 cmp	 esi, esp
  05fb1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2897 : 		
; 2898 : 		MouseMove(swnd, hwnd, MK_LBUTTON, MAKELPARAM(pt.x, pt.y));

  05fb6	8b 4d ac	 mov	 ecx, DWORD PTR _pt$23607[ebp]
  05fb9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  05fbf	0f b7 d1	 movzx	 edx, cx
  05fc2	8b 45 b0	 mov	 eax, DWORD PTR _pt$23607[ebp+4]
  05fc5	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  05fca	0f b7 c8	 movzx	 ecx, ax
  05fcd	c1 e1 10	 shl	 ecx, 16			; 00000010H
  05fd0	0b d1		 or	 edx, ecx
  05fd2	52		 push	 edx
  05fd3	6a 01		 push	 1
  05fd5	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  05fd8	52		 push	 edx
  05fd9	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  05fdc	50		 push	 eax
  05fdd	e8 00 00 00 00	 call	 _MouseMove
  05fe2	83 c4 10	 add	 esp, 16			; 00000010H

; 2899 : 
; 2900 : 		if(uScrollTimerPortion != HTSCROLL_NONE)

  05fe5	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _uScrollTimerPortion, -1
  05fec	74 1c		 je	 SHORT $L23616

; 2901 : 			SendScrollMessage(hwnd, uScrollTimerMsg, uScrollTimerPortion, 0);

  05fee	6a 00		 push	 0
  05ff0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _uScrollTimerPortion
  05ff6	51		 push	 ecx
  05ff7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _uScrollTimerMsg
  05ffd	52		 push	 edx
  05ffe	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  06001	50		 push	 eax
  06002	e8 00 00 00 00	 call	 _SendScrollMessage
  06007	83 c4 10	 add	 esp, 16			; 00000010H
$L23616:

; 2902 : 		
; 2903 : 		return 0;

  0600a	33 c0		 xor	 eax, eax
  0600c	eb 27		 jmp	 SHORT $L23590
$L23606:

; 2904 : 	}
; 2905 : 	else
; 2906 : 	{
; 2907 : 		return CallWindowProc(swnd->oldproc, hwnd, WM_TIMER, wTimerId, lParam);

  0600e	8b f4		 mov	 esi, esp
  06010	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  06013	51		 push	 ecx
  06014	8b 55 10	 mov	 edx, DWORD PTR _wTimerId$[ebp]
  06017	52		 push	 edx
  06018	68 13 01 00 00	 push	 275			; 00000113H
  0601d	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  06020	50		 push	 eax
  06021	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  06024	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  06027	52		 push	 edx
  06028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  0602e	3b f4		 cmp	 esi, esp
  06030	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23590:

; 2908 : 	}
; 2909 : }

  06035	52		 push	 edx
  06036	8b cd		 mov	 ecx, ebp
  06038	50		 push	 eax
  06039	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L24052
  0603f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  06044	58		 pop	 eax
  06045	5a		 pop	 edx
  06046	5f		 pop	 edi
  06047	5e		 pop	 esi
  06048	83 c4 58	 add	 esp, 88			; 00000058H
  0604b	3b ec		 cmp	 ebp, esp
  0604d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  06052	8b e5		 mov	 esp, ebp
  06054	5d		 pop	 ebp
  06055	c3		 ret	 0
$L24052:
  06056	04 00 00 00	 DD	 4
  0605a	00 00 00 00	 DD	 $L24051
$L24051:
  0605e	f4 ff ff ff	 DD	 -12			; fffffff4H
  06062	08 00 00 00	 DD	 8
  06066	00 00 00 00	 DD	 $L24047
  0606a	dc ff ff ff	 DD	 -36			; ffffffdcH
  0606e	10 00 00 00	 DD	 16			; 00000010H
  06072	00 00 00 00	 DD	 $L24048
  06076	c4 ff ff ff	 DD	 -60			; ffffffc4H
  0607a	10 00 00 00	 DD	 16			; 00000010H
  0607e	00 00 00 00	 DD	 $L24049
  06082	ac ff ff ff	 DD	 -84			; ffffffacH
  06086	08 00 00 00	 DD	 8
  0608a	00 00 00 00	 DD	 $L24050
$L24050:
  0608e	70		 DB	 112			; 00000070H
  0608f	74		 DB	 116			; 00000074H
  06090	00		 DB	 0
$L24049:
  06091	77		 DB	 119			; 00000077H
  06092	69		 DB	 105			; 00000069H
  06093	6e		 DB	 110			; 0000006eH
  06094	72		 DB	 114			; 00000072H
  06095	65		 DB	 101			; 00000065H
  06096	63		 DB	 99			; 00000063H
  06097	74		 DB	 116			; 00000074H
  06098	00		 DB	 0
$L24048:
  06099	72		 DB	 114			; 00000072H
  0609a	65		 DB	 101			; 00000065H
  0609b	63		 DB	 99			; 00000063H
  0609c	74		 DB	 116			; 00000074H
  0609d	00		 DB	 0
$L24047:
  0609e	70		 DB	 112			; 00000070H
  0609f	74		 DB	 116			; 00000074H
  060a0	00		 DB	 0
_CoolSB_Timer ENDP
; Function compile flags: /Odt /RTCsu
_ss$ = -4						; size = 4
_swnd$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_msg$ = 16						; size = 4
_wParam$ = 20						; size = 4
_lParam$ = 24						; size = 4
_CoolSB_StyleChange PROC NEAR

; 2916 : {

  060b0	55		 push	 ebp
  060b1	8b ec		 mov	 ebp, esp
  060b3	51		 push	 ecx
  060b4	56		 push	 esi
  060b5	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2917 : 	STYLESTRUCT *ss = (STYLESTRUCT *)lParam;

  060bc	8b 45 18	 mov	 eax, DWORD PTR _lParam$[ebp]
  060bf	89 45 fc	 mov	 DWORD PTR _ss$[ebp], eax

; 2918 : 
; 2919 : 	if(wParam == GWL_EXSTYLE)

  060c2	83 7d 14 ec	 cmp	 DWORD PTR _wParam$[ebp], -20 ; ffffffecH
  060c6	75 2a		 jne	 SHORT $L23632

; 2920 : 	{
; 2921 : 		if(ss->styleNew & WS_EX_LEFTSCROLLBAR)

  060c8	8b 4d fc	 mov	 ecx, DWORD PTR _ss$[ebp]
  060cb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  060ce	81 e2 00 40 00
	00		 and	 edx, 16384		; 00004000H
  060d4	74 0f		 je	 SHORT $L23633

; 2922 : 			swnd->fLeftScrollbar = TRUE;

  060d6	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  060d9	c7 80 a4 06 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+1700], 1

; 2923 : 		else

  060e3	eb 0d		 jmp	 SHORT $L23632
$L23633:

; 2924 : 			swnd->fLeftScrollbar = FALSE;

  060e5	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  060e8	c7 81 a4 06 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+1700], 0
$L23632:

; 2925 : 	}
; 2926 : 
; 2927 : 	return CallWindowProc(swnd->oldproc, hwnd, msg, wParam, lParam);

  060f2	8b f4		 mov	 esi, esp
  060f4	8b 55 18	 mov	 edx, DWORD PTR _lParam$[ebp]
  060f7	52		 push	 edx
  060f8	8b 45 14	 mov	 eax, DWORD PTR _wParam$[ebp]
  060fb	50		 push	 eax
  060fc	8b 4d 10	 mov	 ecx, DWORD PTR _msg$[ebp]
  060ff	51		 push	 ecx
  06100	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  06103	52		 push	 edx
  06104	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  06107	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0610a	51		 push	 ecx
  0610b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  06111	3b f4		 cmp	 esi, esp
  06113	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2928 : }

  06118	5e		 pop	 esi
  06119	83 c4 04	 add	 esp, 4
  0611c	3b ec		 cmp	 ebp, esp
  0611e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  06123	8b e5		 mov	 esp, ebp
  06125	5d		 pop	 ebp
  06126	c3		 ret	 0
_CoolSB_StyleChange ENDP
_TEXT	ENDS
EXTRN	__imp__GetModuleHandleA@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_nmdi$ = -4						; size = 4
_swnd$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CoolSB_Notify PROC NEAR

; 2932 : {

  06130	55		 push	 ebp
  06131	8b ec		 mov	 ebp, esp
  06133	51		 push	 ecx
  06134	56		 push	 esi
  06135	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 2933 : #ifdef COOLSB_TOOLTIPS
; 2934 : 
; 2935 : 	NMTTDISPINFO *nmdi = (NMTTDISPINFO *)lParam;

  0613c	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0613f	89 45 fc	 mov	 DWORD PTR _nmdi$[ebp], eax

; 2936 : 
; 2937 : 	if(nmdi->hdr.hwndFrom == swnd->hwndToolTip &&
; 2938 : 		nmdi->hdr.code == TTN_GETDISPINFO)

  06142	8b 4d fc	 mov	 ecx, DWORD PTR _nmdi$[ebp]
  06145	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  06148	8b 01		 mov	 eax, DWORD PTR [ecx]
  0614a	3b 82 a8 06 00
	00		 cmp	 eax, DWORD PTR [edx+1704]
  06150	75 3d		 jne	 SHORT $L23648
  06152	8b 4d fc	 mov	 ecx, DWORD PTR _nmdi$[ebp]
  06155	81 79 08 f8 fd
	ff ff		 cmp	 DWORD PTR [ecx+8], -520	; fffffdf8H
  0615c	75 31		 jne	 SHORT $L23648

; 2939 : 	{
; 2940 : 		//convert the tooltip notify from a "ISHWND" style
; 2941 : 		//request to an id-based request. 
; 2942 : 		//We do this because our tooltip is a window-style
; 2943 : 		//tip, with no tools, and the GETDISPINFO request must
; 2944 : 		//indicate which button to retrieve the text for
; 2945 : 		//nmdi->hdr.idFrom = curTool;
; 2946 : 		nmdi->hdr.idFrom = curTool;

  0615e	8b 55 fc	 mov	 edx, DWORD PTR _nmdi$[ebp]
  06161	a1 00 00 00 00	 mov	 eax, DWORD PTR _curTool
  06166	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 2947 : 		nmdi->hinst = GetModuleHandle(0);

  06169	8b f4		 mov	 esi, esp
  0616b	6a 00		 push	 0
  0616d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  06173	3b f4		 cmp	 esi, esp
  06175	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0617a	8b 4d fc	 mov	 ecx, DWORD PTR _nmdi$[ebp]
  0617d	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 2948 : 		nmdi->uFlags &= ~TTF_IDISHWND;

  06180	8b 55 fc	 mov	 edx, DWORD PTR _nmdi$[ebp]
  06183	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  06186	83 e0 fe	 and	 eax, -2			; fffffffeH
  06189	8b 4d fc	 mov	 ecx, DWORD PTR _nmdi$[ebp]
  0618c	89 41 64	 mov	 DWORD PTR [ecx+100], eax
$L23648:

; 2949 : 	}
; 2950 : #endif	//COOLSB_TOOLTIPS
; 2951 : 
; 2952 : 	return CallWindowProc(swnd->oldproc, hwnd, WM_NOTIFY, wParam, lParam);	

  0618f	8b f4		 mov	 esi, esp
  06191	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  06194	52		 push	 edx
  06195	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  06198	50		 push	 eax
  06199	6a 4e		 push	 78			; 0000004eH
  0619b	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  0619e	51		 push	 ecx
  0619f	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  061a2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  061a5	50		 push	 eax
  061a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  061ac	3b f4		 cmp	 esi, esp
  061ae	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2953 : }

  061b3	5e		 pop	 esi
  061b4	83 c4 04	 add	 esp, 4
  061b7	3b ec		 cmp	 ebp, esp
  061b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  061be	8b e5		 mov	 esp, ebp
  061c0	5d		 pop	 ebp
  061c1	c3		 ret	 0
_CoolSB_Notify ENDP
_TEXT	ENDS
EXTRN	__imp__SetCursor@4:NEAR
EXTRN	__imp__IsWindowVisible@4:NEAR
_BSS	SEGMENT
?lastid@?1??CoolSB_SetCursor@@9@9 DD 01H DUP (?)	; `CoolSB_SetCursor'::`2'::lastid
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
_TEXT	SEGMENT
_id$ = -64						; size = 4
_pt$ = -56						; size = 8
_sbut$ = -44						; size = 4
_sbar$ = -40						; size = 4
_rect$ = -32						; size = 16
_xy$ = -12						; size = 4
_hi$ = -8						; size = 4
_lo$ = -4						; size = 4
_swnd$ = 8						; size = 4
_hwnd$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_CoolSB_SetCursor PROC NEAR

; 2972 : {

  061d0	55		 push	 ebp
  061d1	8b ec		 mov	 ebp, esp
  061d3	83 ec 40	 sub	 esp, 64			; 00000040H
  061d6	56		 push	 esi
  061d7	57		 push	 edi
  061d8	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  061db	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  061e0	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  061e5	f3 ab		 rep stosd

; 2973 : #ifdef INCLUDE_BUTTONS
; 2974 : 	UINT lo = LOWORD(lParam);

  061e7	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  061ea	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  061ef	0f b7 c8	 movzx	 ecx, ax
  061f2	89 4d fc	 mov	 DWORD PTR _lo$[ebp], ecx

; 2975 : 	UINT hi = HIWORD(lParam);

  061f5	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  061f8	c1 ea 10	 shr	 edx, 16			; 00000010H
  061fb	0f b7 c2	 movzx	 eax, dx
  061fe	89 45 f8	 mov	 DWORD PTR _hi$[ebp], eax

; 2976 : 	UINT xy;
; 2977 : 	RECT rect;
; 2978 : 	SCROLLBAR *sbar;
; 2979 : 	SCROLLBUT *sbut;
; 2980 : 	POINT pt;
; 2981 : 	UINT id;
; 2982 : 	static UINT lastid;
; 2983 : 
; 2984 : #ifdef HIDE_CURSOR_AFTER_MOUSEUP
; 2985 : 	static UINT lastmsg;
; 2986 : 	if(lastmsg == WM_LBUTTONDOWN)
; 2987 : 	{
; 2988 : 		lastmsg =  hi;
; 2989 : 		return CallWindowProc(swnd->oldproc, hwnd, WM_SETCURSOR, wParam, lParam);	
; 2990 : 	}
; 2991 : 	else
; 2992 : 		lastmsg =  hi;
; 2993 : #endif
; 2994 : 	
; 2995 : 	//if we are over either or our scrollbars
; 2996 : 	if(lo == HTHSCROLL || lo == HTVSCROLL)

  06201	83 7d fc 06	 cmp	 DWORD PTR _lo$[ebp], 6
  06205	74 0a		 je	 SHORT $L23684
  06207	83 7d fc 07	 cmp	 DWORD PTR _lo$[ebp], 7
  0620b	0f 85 23 02 00
	00		 jne	 $L23683
$L23684:

; 2997 : 	{
; 2998 : 		xy = GetMessagePos();

  06211	8b f4		 mov	 esi, esp
  06213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessagePos@0
  06219	3b f4		 cmp	 esi, esp
  0621b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  06220	89 45 f4	 mov	 DWORD PTR _xy$[ebp], eax

; 2999 : 		pt.x = LOWORD(xy);

  06223	8b 4d f4	 mov	 ecx, DWORD PTR _xy$[ebp]
  06226	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0622c	0f b7 d1	 movzx	 edx, cx
  0622f	89 55 c8	 mov	 DWORD PTR _pt$[ebp], edx

; 3000 : 		pt.y = HIWORD(xy);

  06232	8b 45 f4	 mov	 eax, DWORD PTR _xy$[ebp]
  06235	c1 e8 10	 shr	 eax, 16			; 00000010H
  06238	0f b7 c8	 movzx	 ecx, ax
  0623b	89 4d cc	 mov	 DWORD PTR _pt$[ebp+4], ecx

; 3001 : 
; 3002 : 		if(lo == HTHSCROLL)

  0623e	83 7d fc 06	 cmp	 DWORD PTR _lo$[ebp], 6
  06242	75 40		 jne	 SHORT $L23689

; 3003 : 		{
; 3004 : 			sbar = &swnd->sbarHorz;

  06244	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  06247	83 c2 08	 add	 edx, 8
  0624a	89 55 d8	 mov	 DWORD PTR _sbar$[ebp], edx

; 3005 : 			GetScrollRect(swnd, SB_HORZ, hwnd, &rect);

  0624d	8d 45 e0	 lea	 eax, DWORD PTR _rect$[ebp]
  06250	50		 push	 eax
  06251	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  06254	51		 push	 ecx
  06255	6a 00		 push	 0
  06257	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  0625a	52		 push	 edx
  0625b	e8 00 00 00 00	 call	 _GetScrollRect
  06260	83 c4 10	 add	 esp, 16			; 00000010H

; 3006 : 			id = GetHorzPortion(sbar, hwnd, &rect, pt.x, pt.y);

  06263	8b 45 cc	 mov	 eax, DWORD PTR _pt$[ebp+4]
  06266	50		 push	 eax
  06267	8b 4d c8	 mov	 ecx, DWORD PTR _pt$[ebp]
  0626a	51		 push	 ecx
  0626b	8d 55 e0	 lea	 edx, DWORD PTR _rect$[ebp]
  0626e	52		 push	 edx
  0626f	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  06272	50		 push	 eax
  06273	8b 4d d8	 mov	 ecx, DWORD PTR _sbar$[ebp]
  06276	51		 push	 ecx
  06277	e8 00 00 00 00	 call	 _GetHorzPortion
  0627c	83 c4 14	 add	 esp, 20			; 00000014H
  0627f	89 45 c0	 mov	 DWORD PTR _id$[ebp], eax

; 3007 : 		}
; 3008 : 		else

  06282	eb 41		 jmp	 SHORT $L23690
$L23689:

; 3009 : 		{
; 3010 : 			sbar = &swnd->sbarVert;

  06284	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  06287	81 c2 54 03 00
	00		 add	 edx, 852		; 00000354H
  0628d	89 55 d8	 mov	 DWORD PTR _sbar$[ebp], edx

; 3011 : 			GetScrollRect(swnd, SB_VERT, hwnd, &rect);

  06290	8d 45 e0	 lea	 eax, DWORD PTR _rect$[ebp]
  06293	50		 push	 eax
  06294	8b 4d 0c	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  06297	51		 push	 ecx
  06298	6a 01		 push	 1
  0629a	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  0629d	52		 push	 edx
  0629e	e8 00 00 00 00	 call	 _GetScrollRect
  062a3	83 c4 10	 add	 esp, 16			; 00000010H

; 3012 : 			id = GetVertPortion(sbar, hwnd, &rect, pt.x, pt.y);

  062a6	8b 45 cc	 mov	 eax, DWORD PTR _pt$[ebp+4]
  062a9	50		 push	 eax
  062aa	8b 4d c8	 mov	 ecx, DWORD PTR _pt$[ebp]
  062ad	51		 push	 ecx
  062ae	8d 55 e0	 lea	 edx, DWORD PTR _rect$[ebp]
  062b1	52		 push	 edx
  062b2	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  062b5	50		 push	 eax
  062b6	8b 4d d8	 mov	 ecx, DWORD PTR _sbar$[ebp]
  062b9	51		 push	 ecx
  062ba	e8 00 00 00 00	 call	 _GetVertPortion
  062bf	83 c4 14	 add	 esp, 20			; 00000014H
  062c2	89 45 c0	 mov	 DWORD PTR _id$[ebp], eax
$L23690:

; 3013 : 		}
; 3014 : 
; 3015 : 		if(id != HTSCROLL_INSERTED)

  062c5	81 7d c0 80 00
	00 00		 cmp	 DWORD PTR _id$[ebp], 128 ; 00000080H
  062cc	74 6b		 je	 SHORT $L23691

; 3016 : 		{
; 3017 : 			if(swnd->hwndToolTip != 0)

  062ce	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  062d1	83 ba a8 06 00
	00 00		 cmp	 DWORD PTR [edx+1704], 0
  062d8	74 36		 je	 SHORT $L23692

; 3018 : 			{
; 3019 : 				SendToolTipMessage(swnd->hwndToolTip, TTM_ACTIVATE, FALSE, 0);

  062da	6a 00		 push	 0
  062dc	6a 00		 push	 0
  062de	68 01 04 00 00	 push	 1025			; 00000401H
  062e3	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  062e6	8b 88 a8 06 00
	00		 mov	 ecx, DWORD PTR [eax+1704]
  062ec	51		 push	 ecx
  062ed	e8 00 00 00 00	 call	 _SendToolTipMessage0
  062f2	83 c4 10	 add	 esp, 16			; 00000010H

; 3020 : 				SendToolTipMessage(swnd->hwndToolTip, TTM_POP, 0, 0);

  062f5	6a 00		 push	 0
  062f7	6a 00		 push	 0
  062f9	68 1c 04 00 00	 push	 1052			; 0000041cH
  062fe	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  06301	8b 82 a8 06 00
	00		 mov	 eax, DWORD PTR [edx+1704]
  06307	50		 push	 eax
  06308	e8 00 00 00 00	 call	 _SendToolTipMessage0
  0630d	83 c4 10	 add	 esp, 16			; 00000010H
$L23692:

; 3021 : 			}
; 3022 : 
; 3023 : 			return CallWindowProc(swnd->oldproc, hwnd, WM_SETCURSOR, wParam, lParam);

  06310	8b f4		 mov	 esi, esp
  06312	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  06315	51		 push	 ecx
  06316	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  06319	52		 push	 edx
  0631a	6a 20		 push	 32			; 00000020H
  0631c	8b 45 0c	 mov	 eax, DWORD PTR _hwnd$[ebp]
  0631f	50		 push	 eax
  06320	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  06323	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  06326	52		 push	 edx
  06327	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  0632d	3b f4		 cmp	 esi, esp
  0632f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  06334	e9 61 01 00 00	 jmp	 $L23668
$L23691:

; 3024 : 		}
; 3025 : 		
; 3026 : 		if(swnd->hwndToolTip != 0)

  06339	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  0633c	83 b8 a8 06 00
	00 00		 cmp	 DWORD PTR [eax+1704], 0
  06343	74 1b		 je	 SHORT $L23693

; 3027 : 		{
; 3028 : 			SendToolTipMessage(swnd->hwndToolTip, TTM_ACTIVATE, TRUE, 0);

  06345	6a 00		 push	 0
  06347	6a 01		 push	 1
  06349	68 01 04 00 00	 push	 1025			; 00000401H
  0634e	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  06351	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  06357	52		 push	 edx
  06358	e8 00 00 00 00	 call	 _SendToolTipMessage0
  0635d	83 c4 10	 add	 esp, 16			; 00000010H
$L23693:

; 3029 : 		}
; 3030 : 
; 3031 : 		//set the cursor if one has been specified
; 3032 : 		if((id = GetButtonFromPt(sbar, &rect, pt, TRUE)) != -1)

  06360	6a 01		 push	 1
  06362	8b 45 cc	 mov	 eax, DWORD PTR _pt$[ebp+4]
  06365	50		 push	 eax
  06366	8b 4d c8	 mov	 ecx, DWORD PTR _pt$[ebp]
  06369	51		 push	 ecx
  0636a	8d 55 e0	 lea	 edx, DWORD PTR _rect$[ebp]
  0636d	52		 push	 edx
  0636e	8b 45 d8	 mov	 eax, DWORD PTR _sbar$[ebp]
  06371	50		 push	 eax
  06372	e8 00 00 00 00	 call	 _GetButtonFromPt
  06377	83 c4 14	 add	 esp, 20			; 00000014H
  0637a	89 45 c0	 mov	 DWORD PTR _id$[ebp], eax
  0637d	83 7d c0 ff	 cmp	 DWORD PTR _id$[ebp], -1
  06381	0f 84 97 00 00
	00		 je	 $L23694

; 3033 : 		{
; 3034 : 			sbut = &sbar->sbButtons[id];

  06387	8b 4d c0	 mov	 ecx, DWORD PTR _id$[ebp]
  0638a	6b c9 30	 imul	 ecx, 48			; 00000030H
  0638d	8b 55 d8	 mov	 edx, DWORD PTR _sbar$[ebp]
  06390	8d 44 0a 2c	 lea	 eax, DWORD PTR [edx+ecx+44]
  06394	89 45 d4	 mov	 DWORD PTR _sbut$[ebp], eax

; 3035 : 			curTool = sbut->uCmdId;

  06397	8b 4d d4	 mov	 ecx, DWORD PTR _sbut$[ebp]
  0639a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0639d	89 15 00 00 00
	00		 mov	 DWORD PTR _curTool, edx

; 3036 : 
; 3037 : 			if(lastid != id && swnd->hwndToolTip != 0)

  063a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lastid@?1??CoolSB_SetCursor@@9@9
  063a8	3b 45 c0	 cmp	 eax, DWORD PTR _id$[ebp]
  063ab	74 44		 je	 SHORT $L23695
  063ad	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  063b0	83 b9 a8 06 00
	00 00		 cmp	 DWORD PTR [ecx+1704], 0
  063b7	74 38		 je	 SHORT $L23695

; 3038 : 			{
; 3039 : 				if(IsWindowVisible(swnd->hwndToolTip))

  063b9	8b f4		 mov	 esi, esp
  063bb	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  063be	8b 82 a8 06 00
	00		 mov	 eax, DWORD PTR [edx+1704]
  063c4	50		 push	 eax
  063c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWindowVisible@4
  063cb	3b f4		 cmp	 esi, esp
  063cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  063d2	85 c0		 test	 eax, eax
  063d4	74 1b		 je	 SHORT $L23695

; 3040 : 					SendToolTipMessage(swnd->hwndToolTip, TTM_UPDATE, TRUE, 0);

  063d6	6a 00		 push	 0
  063d8	6a 01		 push	 1
  063da	68 1d 04 00 00	 push	 1053			; 0000041dH
  063df	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  063e2	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  063e8	52		 push	 edx
  063e9	e8 00 00 00 00	 call	 _SendToolTipMessage0
  063ee	83 c4 10	 add	 esp, 16			; 00000010H
$L23695:

; 3041 : 			}
; 3042 : 
; 3043 : 			lastid = id;

  063f1	8b 45 c0	 mov	 eax, DWORD PTR _id$[ebp]
  063f4	a3 00 00 00 00	 mov	 DWORD PTR ?lastid@?1??CoolSB_SetCursor@@9@9, eax

; 3044 : 
; 3045 : 			if(sbut->hCurs != 0)

  063f9	8b 4d d4	 mov	 ecx, DWORD PTR _sbut$[ebp]
  063fc	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  06400	74 1a		 je	 SHORT $L23697

; 3046 : 			{
; 3047 : 				SetCursor(sbut->hCurs);

  06402	8b f4		 mov	 esi, esp
  06404	8b 55 d4	 mov	 edx, DWORD PTR _sbut$[ebp]
  06407	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0640a	50		 push	 eax
  0640b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCursor@4
  06411	3b f4		 cmp	 esi, esp
  06413	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3048 : 				return 0;

  06418	33 c0		 xor	 eax, eax
  0641a	eb 7e		 jmp	 SHORT $L23668
$L23697:

; 3049 : 			}
; 3050 : 		}
; 3051 : 		else

  0641c	eb 14		 jmp	 SHORT $L23698
$L23694:

; 3052 : 		{
; 3053 : 			curTool = -1;

  0641e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _curTool, -1

; 3054 : 			lastid = -1;

  06428	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?lastid@?1??CoolSB_SetCursor@@9@9, -1
$L23698:

; 3055 : 		}
; 3056 : 	}
; 3057 : 	else if(swnd->hwndToolTip != 0)

  06432	eb 42		 jmp	 SHORT $L23699
$L23683:
  06434	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  06437	83 b9 a8 06 00
	00 00		 cmp	 DWORD PTR [ecx+1704], 0
  0643e	74 36		 je	 SHORT $L23699

; 3058 : 	{
; 3059 : 		SendToolTipMessage(swnd->hwndToolTip, TTM_ACTIVATE, FALSE, 0);

  06440	6a 00		 push	 0
  06442	6a 00		 push	 0
  06444	68 01 04 00 00	 push	 1025			; 00000401H
  06449	8b 55 08	 mov	 edx, DWORD PTR _swnd$[ebp]
  0644c	8b 82 a8 06 00
	00		 mov	 eax, DWORD PTR [edx+1704]
  06452	50		 push	 eax
  06453	e8 00 00 00 00	 call	 _SendToolTipMessage0
  06458	83 c4 10	 add	 esp, 16			; 00000010H

; 3060 : 		SendToolTipMessage(swnd->hwndToolTip, TTM_POP, 0, 0);

  0645b	6a 00		 push	 0
  0645d	6a 00		 push	 0
  0645f	68 1c 04 00 00	 push	 1052			; 0000041cH
  06464	8b 4d 08	 mov	 ecx, DWORD PTR _swnd$[ebp]
  06467	8b 91 a8 06 00
	00		 mov	 edx, DWORD PTR [ecx+1704]
  0646d	52		 push	 edx
  0646e	e8 00 00 00 00	 call	 _SendToolTipMessage0
  06473	83 c4 10	 add	 esp, 16			; 00000010H
$L23699:

; 3061 : 	}
; 3062 : 
; 3063 : #endif	//INCLUDE_BUTTONS
; 3064 : 	return CallWindowProc(swnd->oldproc, hwnd, WM_SETCURSOR, wParam, lParam);

  06476	8b f4		 mov	 esi, esp
  06478	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0647b	50		 push	 eax
  0647c	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  0647f	51		 push	 ecx
  06480	6a 20		 push	 32			; 00000020H
  06482	8b 55 0c	 mov	 edx, DWORD PTR _hwnd$[ebp]
  06485	52		 push	 edx
  06486	8b 45 08	 mov	 eax, DWORD PTR _swnd$[ebp]
  06489	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0648c	51		 push	 ecx
  0648d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20
  06493	3b f4		 cmp	 esi, esp
  06495	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L23668:

; 3065 : }

  0649a	52		 push	 edx
  0649b	8b cd		 mov	 ecx, ebp
  0649d	50		 push	 eax
  0649e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L24059
  064a4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  064a9	58		 pop	 eax
  064aa	5a		 pop	 edx
  064ab	5f		 pop	 edi
  064ac	5e		 pop	 esi
  064ad	83 c4 40	 add	 esp, 64			; 00000040H
  064b0	3b ec		 cmp	 ebp, esp
  064b2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  064b7	8b e5		 mov	 esp, ebp
  064b9	5d		 pop	 ebp
  064ba	c3		 ret	 0
$L24059:
  064bb	02 00 00 00	 DD	 2
  064bf	00 00 00 00	 DD	 $L24058
$L24058:
  064c3	e0 ff ff ff	 DD	 -32			; ffffffe0H
  064c7	10 00 00 00	 DD	 16			; 00000010H
  064cb	00 00 00 00	 DD	 $L24056
  064cf	c8 ff ff ff	 DD	 -56			; ffffffc8H
  064d3	08 00 00 00	 DD	 8
  064d7	00 00 00 00	 DD	 $L24057
$L24057:
  064db	70		 DB	 112			; 00000070H
  064dc	74		 DB	 116			; 00000074H
  064dd	00		 DB	 0
$L24056:
  064de	72		 DB	 114			; 00000072H
  064df	65		 DB	 101			; 00000065H
  064e0	63		 DB	 99			; 00000063H
  064e1	74		 DB	 116			; 00000074H
  064e2	00		 DB	 0
_CoolSB_SetCursor ENDP
; Function compile flags: /Odt /RTCsu
_hwndTT$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_SendToolTipMessage0 PROC NEAR

; 2956 : {

  064f0	55		 push	 ebp
  064f1	8b ec		 mov	 ebp, esp
  064f3	56		 push	 esi

; 2957 : 	return SendMessage(hwndTT, message, wParam, lParam);

  064f4	8b f4		 mov	 esi, esp
  064f6	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  064f9	50		 push	 eax
  064fa	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  064fd	51		 push	 ecx
  064fe	8b 55 0c	 mov	 edx, DWORD PTR _message$[ebp]
  06501	52		 push	 edx
  06502	8b 45 08	 mov	 eax, DWORD PTR _hwndTT$[ebp]
  06505	50		 push	 eax
  06506	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  0650c	3b f4		 cmp	 esi, esp
  0650e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2958 : }

  06513	5e		 pop	 esi
  06514	3b ec		 cmp	 ebp, esp
  06516	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0651b	5d		 pop	 ebp
  0651c	c3		 ret	 0
_SendToolTipMessage0 ENDP
; Function compile flags: /Odt /RTCsu
_msg$ = -32						; size = 28
_hwnd$ = 8						; size = 4
_hwndToolTip$ = 12					; size = 4
_event$ = 16						; size = 4
_RelayMouseEvent@12 PROC NEAR

; 3072 : {

  06520	55		 push	 ebp
  06521	8b ec		 mov	 ebp, esp
  06523	83 ec 24	 sub	 esp, 36			; 00000024H
  06526	56		 push	 esi
  06527	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0652c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0652f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  06532	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  06535	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  06538	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0653b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0653e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  06541	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  06544	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 3073 : #ifdef COOLSB_TOOLTIPS
; 3074 : 	MSG msg;
; 3075 : 
; 3076 : 	CoolSB_ZeroMemory(&msg, sizeof(MSG));

  06547	6a 1c		 push	 28			; 0000001cH
  06549	8d 45 e0	 lea	 eax, DWORD PTR _msg$[ebp]
  0654c	50		 push	 eax
  0654d	e8 00 00 00 00	 call	 _CoolSB_ZeroMemory
  06552	83 c4 08	 add	 esp, 8

; 3077 : 	msg.hwnd = hwnd;

  06555	8b 4d 08	 mov	 ecx, DWORD PTR _hwnd$[ebp]
  06558	89 4d e0	 mov	 DWORD PTR _msg$[ebp], ecx

; 3078 : 	msg.message = event;

  0655b	8b 55 10	 mov	 edx, DWORD PTR _event$[ebp]
  0655e	89 55 e4	 mov	 DWORD PTR _msg$[ebp+4], edx

; 3079 : #pragma warning( disable: 4311)	
; 3080 : 	SendMessage(hwndToolTip, TTM_RELAYEVENT, 0, (LONG)&msg);

  06561	8b f4		 mov	 esi, esp
  06563	8d 45 e0	 lea	 eax, DWORD PTR _msg$[ebp]
  06566	50		 push	 eax
  06567	6a 00		 push	 0
  06569	68 07 04 00 00	 push	 1031			; 00000407H
  0656e	8b 4d 0c	 mov	 ecx, DWORD PTR _hwndToolTip$[ebp]
  06571	51		 push	 ecx
  06572	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  06578	3b f4		 cmp	 esi, esp
  0657a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3081 : #pragma warning( default: 4311)	
; 3082 : #else
; 3083 : 	UNREFERENCED_PARAMETER(hwnd);
; 3084 : 	UNREFERENCED_PARAMETER(hwndToolTip);
; 3085 : 	UNREFERENCED_PARAMETER(event);
; 3086 : #endif
; 3087 : }

  0657f	52		 push	 edx
  06580	8b cd		 mov	 ecx, ebp
  06582	50		 push	 eax
  06583	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L24064
  06589	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0658e	58		 pop	 eax
  0658f	5a		 pop	 edx
  06590	5e		 pop	 esi
  06591	83 c4 24	 add	 esp, 36			; 00000024H
  06594	3b ec		 cmp	 ebp, esp
  06596	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0659b	8b e5		 mov	 esp, ebp
  0659d	5d		 pop	 ebp
  0659e	c2 0c 00	 ret	 12			; 0000000cH
$L24064:
  065a1	01 00 00 00	 DD	 1
  065a5	00 00 00 00	 DD	 $L24063
$L24063:
  065a9	e0 ff ff ff	 DD	 -32			; ffffffe0H
  065ad	1c 00 00 00	 DD	 28			; 0000001cH
  065b1	00 00 00 00	 DD	 $L24062
$L24062:
  065b5	6d		 DB	 109			; 0000006dH
  065b6	73		 DB	 115			; 00000073H
  065b7	67		 DB	 103			; 00000067H
  065b8	00		 DB	 0
_RelayMouseEvent@12 ENDP
_TEXT	ENDS
END
