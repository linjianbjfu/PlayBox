; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\src\Gui\Bitmap\DibBitmap.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
;	COMDAT ??_GCDibBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3CDibBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2CDibBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CDib@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDibBitmap@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCDib@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVCDibBitmap@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4CDibBitmap@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FG@LDNDNCJM@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FJ@DMHPDOJC@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FI@NHHJANPC@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CDibBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG187156 DB	'DISPLAY', 00H
CONST	ENDS
PUBLIC	??_R4CDibBitmap@@6B@				; CDibBitmap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDibBitmap@@@8				; CDibBitmap `RTTI Type Descriptor'
PUBLIC	??_R3CDibBitmap@@8				; CDibBitmap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDibBitmap@@8				; CDibBitmap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@CDibBitmap@@8			; CDibBitmap::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R1A@?0A@A@CDib@@8				; CDib::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCDib@@@8				; CDib `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@A@CObject@@8				; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??0CDibBitmap@@QAE@XZ				; CDibBitmap::CDibBitmap
PUBLIC	??_7CDibBitmap@@6B@				; CDibBitmap::`vftable'
PUBLIC	??_GCDibBitmap@@UAEPAXI@Z			; CDibBitmap::`scalar deleting destructor'
EXTRN	?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ:NEAR ; CDib::GetRuntimeClass
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	??0CDib@@IAE@XZ:NEAR				; CDib::CDib
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	?Serialize@CDib@@MAEXAAVCArchive@@@Z:NEAR	; CDib::Serialize
EXTRN	??0CRect@@QAE@XZ:NEAR				; CRect::CRect
EXTRN	??0CRect@@QAE@HHHH@Z:NEAR			; CRect::CRect
EXTRN	??_ECDibBitmap@@UAEPAXI@Z:NEAR			; CDibBitmap::`vector deleting destructor'
EXTRN	?AssertValid@CObject@@UBEXXZ:NEAR		; CObject::AssertValid
EXTRN	?Dump@CObject@@UBEXAAVCDumpContext@@@Z:NEAR	; CObject::Dump
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT rtc$IMZ
; File d:\boxgit\playbox\playbox\dev\prj\playbox\src\gui\bitmap\dibbitmap.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT ??_7CDibBitmap@@6B@
CONST	SEGMENT
??_7CDibBitmap@@6B@ DD FLAT:??_R4CDibBitmap@@6B@	; CDibBitmap::`vftable'
	DD	FLAT:?GetRuntimeClass@CDib@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECDibBitmap@@UAEPAXI@Z
	DD	FLAT:?Serialize@CDib@@MAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
CONST	ENDS
;	COMDAT ??_R4CDibBitmap@@6B@
rdata$r	SEGMENT
??_R4CDibBitmap@@6B@ DD 00H				; CDibBitmap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDibBitmap@@@8
	DD	FLAT:??_R3CDibBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDibBitmap@@@8
_DATA	SEGMENT
??_R0?AVCDibBitmap@@@8 DD FLAT:??_7type_info@@6B@	; CDibBitmap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDibBitmap@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CDibBitmap@@8
rdata$r	SEGMENT
??_R3CDibBitmap@@8 DD 00H				; CDibBitmap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CDibBitmap@@8
rdata$r	ENDS
;	COMDAT ??_R2CDibBitmap@@8
rdata$r	SEGMENT
??_R2CDibBitmap@@8 DD FLAT:??_R1A@?0A@A@CDibBitmap@@8	; CDibBitmap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@CDib@@8
	DD	FLAT:??_R1A@?0A@A@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDibBitmap@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CDibBitmap@@8 DD FLAT:??_R0?AVCDibBitmap@@@8 ; CDibBitmap::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@CDib@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CDib@@8 DD FLAT:??_R0?AVCDib@@@8		; CDib::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCDib@@@8
_DATA	SEGMENT
??_R0?AVCDib@@@8 DD FLAT:??_7type_info@@6B@		; CDib `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDib@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@A@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
_DATA	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
_TEXT	SEGMENT
$T187761 = -20						; size = 16
_this$ = -4						; size = 4
??0CDibBitmap@@QAE@XZ PROC NEAR				; CDibBitmap::CDibBitmap
; _this$ = ecx

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??0CDib@@IAE@XZ		; CDib::CDib
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDibBitmap@@6B@
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 38	 add	 ecx, 56			; 00000038H
  00035	8b f4		 mov	 esi, esp
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0003d	3b f4		 cmp	 esi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0004a	e8 00 00 00 00	 call	 ??0CRect@@QAE@XZ	; CRect::CRect
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	83 c1 60	 add	 ecx, 96			; 00000060H
  00055	8b f4		 mov	 esi, esp
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 6    : 	m_rect = CRect(0,0,0,0);

  00064	6a 00		 push	 0
  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	8d 4d ec	 lea	 ecx, DWORD PTR $T187761[ebp]
  0006f	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0007a	8b 10		 mov	 edx, DWORD PTR [eax]
  0007c	89 11		 mov	 DWORD PTR [ecx], edx
  0007e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00081	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00084	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00087	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0008a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0008d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 7    : 	pos_Left = -1;

  00090	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	c7 41 50 ff ff
	ff ff		 mov	 DWORD PTR [ecx+80], -1

; 8    : 	pos_Top = -1;

  0009a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009d	c7 42 4c ff ff
	ff ff		 mov	 DWORD PTR [edx+76], -1

; 9    : 	pos_Right = -1;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	c7 40 54 ff ff
	ff ff		 mov	 DWORD PTR [eax+84], -1

; 10   : 	pos_Bottom = -1;

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	c7 41 58 ff ff
	ff ff		 mov	 DWORD PTR [ecx+88], -1

; 11   : 	is_Loaded = 0;

  000b8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000bb	c6 42 5c 00	 mov	 BYTE PTR [edx+92], 0

; 12   : 	is_ChangeColor = 1;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	c6 40 5d 01	 mov	 BYTE PTR [eax+93], 1

; 13   : 	has_PopupError = false;

  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	c6 41 5e 00	 mov	 BYTE PTR [ecx+94], 0

; 14   : 	m_count = 0;

  000cd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d0	c7 42 64 00 00
	00 00		 mov	 DWORD PTR [edx+100], 0

; 15   : }

  000d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000da	5e		 pop	 esi
  000db	83 c4 14	 add	 esp, 20			; 00000014H
  000de	3b ec		 cmp	 ebp, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
??0CDibBitmap@@QAE@XZ ENDP				; CDibBitmap::CDibBitmap
_TEXT	ENDS
PUBLIC	??1CDibBitmap@@UAE@XZ				; CDibBitmap::~CDibBitmap
EXTRN	??3CObject@@SGXPAX@Z:NEAR			; CObject::operator delete
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCDibBitmap@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDibBitmap@@UAEPAXI@Z PROC NEAR			; CDibBitmap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1CDibBitmap@@UAE@XZ	; CDibBitmap::~CDibBitmap
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 09		 je	 SHORT $L187020
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$L187020:
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??_GCDibBitmap@@UAEPAXI@Z ENDP				; CDibBitmap::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1CDib@@MAE@XZ:NEAR				; CDib::~CDib
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CDibBitmap@@UAE@XZ PROC NEAR				; CDibBitmap::~CDibBitmap
; _this$ = ecx

; 18   : {

  000f0	55		 push	 ebp
  000f1	8b ec		 mov	 ebp, esp
  000f3	51		 push	 ecx
  000f4	56		 push	 esi
  000f5	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  000fc	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  000ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00102	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CDibBitmap@@6B@

; 19   : }

  00108	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	83 c1 60	 add	 ecx, 96			; 00000060H
  0010e	8b f4		 mov	 esi, esp
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00116	3b f4		 cmp	 esi, esp
  00118	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	83 c1 38	 add	 ecx, 56			; 00000038H
  00123	8b f4		 mov	 esi, esp
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0012b	3b f4		 cmp	 esi, esp
  0012d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00132	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00135	e8 00 00 00 00	 call	 ??1CDib@@MAE@XZ		; CDib::~CDib
  0013a	5e		 pop	 esi
  0013b	83 c4 04	 add	 esp, 4
  0013e	3b ec		 cmp	 ebp, esp
  00140	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
??1CDibBitmap@@UAE@XZ ENDP				; CDibBitmap::~CDibBitmap
_TEXT	ENDS
PUBLIC	?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CDibBitmap::LoadFromFile
EXTRN	?AttachMapFile@CDib@@IAEHPBDH@Z:NEAR		; CDib::AttachMapFile
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:NEAR
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:NEAR
xdata$x	SEGMENT
$T187786 DD	0ffffffffH
	DD	FLAT:$L187779
$T187783 DD	019930520H
	DD	01H
	DD	FLAT:$T187786
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T187778 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; CDibBitmap::LoadFromFile
; _this$ = ecx

; 21   : {

  00150	55		 push	 ebp
  00151	8b ec		 mov	 ebp, esp
  00153	6a ff		 push	 -1
  00155	68 00 00 00 00	 push	 __ehhandler$?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0015a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00160	50		 push	 eax
  00161	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00168	83 ec 08	 sub	 esp, 8
  0016b	56		 push	 esi
  0016c	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00173	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  0017a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0017d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 22   : 	m_path = path;

  00184	8b f4		 mov	 esi, esp
  00186	8d 45 08	 lea	 eax, DWORD PTR _path$[ebp]
  00189	50		 push	 eax
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018d	83 c1 38	 add	 ecx, 56			; 00000038H
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00196	3b f4		 cmp	 esi, esp
  00198	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 23   : 	return CDib::AttachMapFile(path,TRUE);

  0019d	6a 01		 push	 1
  0019f	8b f4		 mov	 esi, esp
  001a1	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  001aa	3b f4		 cmp	 esi, esp
  001ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b1	50		 push	 eax
  001b2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b5	e8 00 00 00 00	 call	 ?AttachMapFile@CDib@@IAEHPBDH@Z ; CDib::AttachMapFile
  001ba	89 45 ec	 mov	 DWORD PTR $T187778[ebp], eax
  001bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001c4	8b f4		 mov	 esi, esp
  001c6	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001cf	3b f4		 cmp	 esi, esp
  001d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d6	8b 45 ec	 mov	 eax, DWORD PTR $T187778[ebp]

; 24   : }

  001d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001e3	5e		 pop	 esi
  001e4	83 c4 14	 add	 esp, 20			; 00000014H
  001e7	3b ec		 cmp	 ebp, esp
  001e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ee	8b e5		 mov	 esp, ebp
  001f0	5d		 pop	 ebp
  001f1	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
$L187779:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T187783
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; CDibBitmap::LoadFromFile
PUBLIC	?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z ; CDibBitmap::LoadFromFile
EXTRN	?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z:NEAR ; CDib::AttachMapFile2
xdata$x	SEGMENT
$T187794 DD	0ffffffffH
	DD	FLAT:$L187790
$T187792 DD	019930520H
	DD	01H
	DD	FLAT:$T187794
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T187789 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
_pCutRect$ = 12						; size = 4
?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z PROC NEAR ; CDibBitmap::LoadFromFile
; _this$ = ecx

; 26   : {

  00200	55		 push	 ebp
  00201	8b ec		 mov	 ebp, esp
  00203	6a ff		 push	 -1
  00205	68 00 00 00 00	 push	 __ehhandler$?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z
  0020a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00210	50		 push	 eax
  00211	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00218	83 ec 08	 sub	 esp, 8
  0021b	56		 push	 esi
  0021c	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00223	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  0022a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0022d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 27   : 	m_path = path;

  00234	8b f4		 mov	 esi, esp
  00236	8d 45 08	 lea	 eax, DWORD PTR _path$[ebp]
  00239	50		 push	 eax
  0023a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0023d	83 c1 38	 add	 ecx, 56			; 00000038H
  00240	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00246	3b f4		 cmp	 esi, esp
  00248	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 28   : 	return CDib::AttachMapFile2(path,pCutRect,TRUE);

  0024d	6a 01		 push	 1
  0024f	8b 4d 0c	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  00252	51		 push	 ecx
  00253	8b f4		 mov	 esi, esp
  00255	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00258	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0025e	3b f4		 cmp	 esi, esp
  00260	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00265	50		 push	 eax
  00266	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	e8 00 00 00 00	 call	 ?AttachMapFile2@CDib@@IAEHPBDPAUCutRect@1@H@Z ; CDib::AttachMapFile2
  0026e	89 45 ec	 mov	 DWORD PTR $T187789[ebp], eax
  00271	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00278	8b f4		 mov	 esi, esp
  0027a	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  0027d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00283	3b f4		 cmp	 esi, esp
  00285	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028a	8b 45 ec	 mov	 eax, DWORD PTR $T187789[ebp]

; 29   : }

  0028d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00290	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00297	5e		 pop	 esi
  00298	83 c4 14	 add	 esp, 20			; 00000014H
  0029b	3b ec		 cmp	 ebp, esp
  0029d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a2	8b e5		 mov	 esp, ebp
  002a4	5d		 pop	 ebp
  002a5	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
$L187790:
  0001c	8b f4		 mov	 esi, esp
  0001e	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00027	3b f4		 cmp	 esi, esp
  00029	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z:
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T187792
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadFromFile@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAUCutRect@CDib@@@Z ENDP ; CDibBitmap::LoadFromFile
PUBLIC	?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z ; CDibBitmap::LoadFromMem
EXTRN	?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z:NEAR ; CDib::AttachMapFile2
xdata$x	SEGMENT
$T187801 DD	0ffffffffH
	DD	FLAT:$L187797
$T187799 DD	019930520H
	DD	01H
	DD	FLAT:$T187801
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T187796 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
_pVoid$ = 12						; size = 4
_nSize$ = 16						; size = 4
_pCutRect$ = 20						; size = 4
?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z PROC NEAR ; CDibBitmap::LoadFromMem
; _this$ = ecx

; 31   : {

  002b0	55		 push	 ebp
  002b1	8b ec		 mov	 ebp, esp
  002b3	6a ff		 push	 -1
  002b5	68 00 00 00 00	 push	 __ehhandler$?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z
  002ba	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  002c0	50		 push	 eax
  002c1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  002c8	83 ec 08	 sub	 esp, 8
  002cb	56		 push	 esi
  002cc	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  002d3	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  002da	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  002dd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 32   : 	m_path = path;

  002e4	8b f4		 mov	 esi, esp
  002e6	8d 45 08	 lea	 eax, DWORD PTR _path$[ebp]
  002e9	50		 push	 eax
  002ea	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  002ed	83 c1 38	 add	 ecx, 56			; 00000038H
  002f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  002f6	3b f4		 cmp	 esi, esp
  002f8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 33   : 	return CDib::AttachMapFile2(pVoid,nSize, pCutRect,TRUE);

  002fd	6a 01		 push	 1
  002ff	8b 4d 14	 mov	 ecx, DWORD PTR _pCutRect$[ebp]
  00302	51		 push	 ecx
  00303	8b 55 10	 mov	 edx, DWORD PTR _nSize$[ebp]
  00306	52		 push	 edx
  00307	8b 45 0c	 mov	 eax, DWORD PTR _pVoid$[ebp]
  0030a	50		 push	 eax
  0030b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0030e	e8 00 00 00 00	 call	 ?AttachMapFile2@CDib@@IAEHPAXIPAUCutRect@1@H@Z ; CDib::AttachMapFile2
  00313	89 45 ec	 mov	 DWORD PTR $T187796[ebp], eax
  00316	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0031d	8b f4		 mov	 esi, esp
  0031f	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00322	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00328	3b f4		 cmp	 esi, esp
  0032a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0032f	8b 45 ec	 mov	 eax, DWORD PTR $T187796[ebp]

; 34   : }

  00332	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00335	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0033c	5e		 pop	 esi
  0033d	83 c4 14	 add	 esp, 20			; 00000014H
  00340	3b ec		 cmp	 ebp, esp
  00342	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00347	8b e5		 mov	 esp, ebp
  00349	5d		 pop	 ebp
  0034a	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L187797:
  00038	8b f4		 mov	 esi, esp
  0003a	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00043	3b f4		 cmp	 esi, esp
  00045	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z:
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T187799
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?LoadFromMem@CDibBitmap@@QAEHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAXIPAUCutRect@CDib@@@Z ENDP ; CDibBitmap::LoadFromMem
PUBLIC	?LoadFromID@CDibBitmap@@QAEHI@Z			; CDibBitmap::LoadFromID
EXTRN	?AttachMemory@CDib@@QAEHPAXH0@Z:NEAR		; CDib::AttachMemory
EXTRN	__imp__FindResourceA@12:NEAR
EXTRN	__imp__LoadResource@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_lpv$ = -8						; size = 4
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?LoadFromID@CDibBitmap@@QAEHI@Z PROC NEAR		; CDibBitmap::LoadFromID
; _this$ = ecx

; 36   : {

  00350	55		 push	 ebp
  00351	8b ec		 mov	 ebp, esp
  00353	83 ec 08	 sub	 esp, 8
  00356	56		 push	 esi
  00357	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0035e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00365	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 37   : 	LPVOID lpv = (LPVOID) ::LoadResource(NULL,
; 38   :         ::FindResource(NULL, MAKEINTRESOURCE(ID),
; 39   :                        RT_BITMAP));

  00368	8b f4		 mov	 esi, esp
  0036a	6a 02		 push	 2
  0036c	0f b7 45 08	 movzx	 eax, WORD PTR _ID$[ebp]
  00370	50		 push	 eax
  00371	6a 00		 push	 0
  00373	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceA@12
  00379	3b f4		 cmp	 esi, esp
  0037b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00380	8b f4		 mov	 esi, esp
  00382	50		 push	 eax
  00383	6a 00		 push	 0
  00385	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  0038b	3b f4		 cmp	 esi, esp
  0038d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00392	89 45 f8	 mov	 DWORD PTR _lpv$[ebp], eax

; 40   : 	return CDib::AttachMemory(lpv);

  00395	6a 00		 push	 0
  00397	6a 00		 push	 0
  00399	8b 4d f8	 mov	 ecx, DWORD PTR _lpv$[ebp]
  0039c	51		 push	 ecx
  0039d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a0	e8 00 00 00 00	 call	 ?AttachMemory@CDib@@QAEHPAXH0@Z ; CDib::AttachMemory

; 41   : }

  003a5	5e		 pop	 esi
  003a6	83 c4 08	 add	 esp, 8
  003a9	3b ec		 cmp	 ebp, esp
  003ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003b0	8b e5		 mov	 esp, ebp
  003b2	5d		 pop	 ebp
  003b3	c2 04 00	 ret	 4
?LoadFromID@CDibBitmap@@QAEHI@Z ENDP			; CDibBitmap::LoadFromID
_TEXT	ENDS
PUBLIC	?GetShowRect@CDibBitmap@@AAEXAAVCRect@@V2@@Z	; CDibBitmap::GetShowRect
PUBLIC	?DrawStrechFromCenter@CDibBitmap@@QAEHPAVCDC@@@Z ; CDibBitmap::DrawStrechFromCenter
EXTRN	__imp__StretchDIBits@52:NEAR
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	?Width@CRect@@QBEHXZ:NEAR			; CRect::Width
EXTRN	?Height@CRect@@QBEHXZ:NEAR			; CRect::Height
EXTRN	??9CRect@@QBEHABUtagRECT@@@Z:NEAR		; CRect::operator!=
EXTRN	?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ:NEAR		; CDC::GetSafeHdc
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T187804 = -44						; size = 16
_imgrc$187062 = -24					; size = 16
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?DrawStrechFromCenter@CDibBitmap@@QAEHPAVCDC@@@Z PROC NEAR ; CDibBitmap::DrawStrechFromCenter
; _this$ = ecx

; 44   : {

  003c0	55		 push	 ebp
  003c1	8b ec		 mov	 ebp, esp
  003c3	83 ec 2c	 sub	 esp, 44			; 0000002cH
  003c6	56		 push	 esi
  003c7	57		 push	 edi
  003c8	51		 push	 ecx
  003c9	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  003cc	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  003d1	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  003d6	f3 ab		 rep stosd
  003d8	59		 pop	 ecx
  003d9	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	if(m_rect!= CRect(0,0,0,0))

  003dc	6a 00		 push	 0
  003de	6a 00		 push	 0
  003e0	6a 00		 push	 0
  003e2	6a 00		 push	 0
  003e4	8d 4d d4	 lea	 ecx, DWORD PTR $T187804[ebp]
  003e7	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  003ec	50		 push	 eax
  003ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003f0	83 c1 3c	 add	 ecx, 60			; 0000003cH
  003f3	e8 00 00 00 00	 call	 ??9CRect@@QBEHABUtagRECT@@@Z ; CRect::operator!=
  003f8	85 c0		 test	 eax, eax
  003fa	0f 84 ba 00 00
	00		 je	 $L187061

; 46   : 	{
; 47   : 		CRect imgrc(0,0,m_lpBMIH->biWidth,m_lpBMIH->biHeight);

  00400	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00403	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00406	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00409	52		 push	 edx
  0040a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0040d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00410	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00413	52		 push	 edx
  00414	6a 00		 push	 0
  00416	6a 00		 push	 0
  00418	8d 4d e8	 lea	 ecx, DWORD PTR _imgrc$187062[ebp]
  0041b	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect

; 48   : 		GetShowRect(imgrc,m_rect);

  00420	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00423	83 c0 3c	 add	 eax, 60			; 0000003cH
  00426	83 ec 10	 sub	 esp, 16			; 00000010H
  00429	8b cc		 mov	 ecx, esp
  0042b	8b 10		 mov	 edx, DWORD PTR [eax]
  0042d	89 11		 mov	 DWORD PTR [ecx], edx
  0042f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00432	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00435	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00438	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0043b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0043e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00441	8d 4d e8	 lea	 ecx, DWORD PTR _imgrc$187062[ebp]
  00444	51		 push	 ecx
  00445	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00448	e8 00 00 00 00	 call	 ?GetShowRect@CDibBitmap@@AAEXAAVCRect@@V2@@Z ; CDibBitmap::GetShowRect

; 49   : 		::StretchDIBits(pDC->GetSafeHdc(), m_rect.left,m_rect.top,m_rect.Width(),m_rect.Height(),
; 50   : 			imgrc.left, imgrc.top, imgrc.Width(), imgrc.Height(),	
; 51   : 			m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  0044d	8b f4		 mov	 esi, esp
  0044f	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00454	6a 00		 push	 0
  00456	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00459	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0045c	50		 push	 eax
  0045d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00460	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00463	52		 push	 edx
  00464	8d 4d e8	 lea	 ecx, DWORD PTR _imgrc$187062[ebp]
  00467	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0046c	50		 push	 eax
  0046d	8d 4d e8	 lea	 ecx, DWORD PTR _imgrc$187062[ebp]
  00470	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00475	50		 push	 eax
  00476	8b 45 ec	 mov	 eax, DWORD PTR _imgrc$187062[ebp+4]
  00479	50		 push	 eax
  0047a	8b 4d e8	 mov	 ecx, DWORD PTR _imgrc$187062[ebp]
  0047d	51		 push	 ecx
  0047e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00481	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00484	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00489	50		 push	 eax
  0048a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0048d	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00490	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00495	50		 push	 eax
  00496	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00499	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0049c	50		 push	 eax
  0049d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004a0	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  004a3	52		 push	 edx
  004a4	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  004a7	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  004ac	50		 push	 eax
  004ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52
  004b3	3b f4		 cmp	 esi, esp
  004b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L187061:

; 52   : 	}
; 53   : 	return TRUE;

  004ba	b8 01 00 00 00	 mov	 eax, 1

; 54   : }

  004bf	52		 push	 edx
  004c0	8b cd		 mov	 ecx, ebp
  004c2	50		 push	 eax
  004c3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L187807
  004c9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  004ce	58		 pop	 eax
  004cf	5a		 pop	 edx
  004d0	5f		 pop	 edi
  004d1	5e		 pop	 esi
  004d2	83 c4 2c	 add	 esp, 44			; 0000002cH
  004d5	3b ec		 cmp	 ebp, esp
  004d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004dc	8b e5		 mov	 esp, ebp
  004de	5d		 pop	 ebp
  004df	c2 04 00	 ret	 4
$L187807:
  004e2	01 00 00 00	 DD	 1
  004e6	00 00 00 00	 DD	 $L187806
$L187806:
  004ea	e8 ff ff ff	 DD	 -24			; ffffffe8H
  004ee	10 00 00 00	 DD	 16			; 00000010H
  004f2	00 00 00 00	 DD	 $L187805
$L187805:
  004f6	69		 DB	 105			; 00000069H
  004f7	6d		 DB	 109			; 0000006dH
  004f8	67		 DB	 103			; 00000067H
  004f9	72		 DB	 114			; 00000072H
  004fa	63		 DB	 99			; 00000063H
  004fb	00		 DB	 0
?DrawStrechFromCenter@CDibBitmap@@QAEHPAVCDC@@@Z ENDP	; CDibBitmap::DrawStrechFromCenter
_TEXT	ENDS
EXTRN	?DeflateRect@CRect@@QAEXHHHH@Z:NEAR		; CRect::DeflateRect
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_newwidth$187075 = -60					; size = 4
_temprc$187074 = -52					; size = 16
_newheight$187072 = -32					; size = 4
_temprc$187071 = -24					; size = 16
_this$ = -4						; size = 4
_Imgrc$ = 8						; size = 4
_Destrc$ = 12						; size = 16
?GetShowRect@CDibBitmap@@AAEXAAVCRect@@V2@@Z PROC NEAR	; CDibBitmap::GetShowRect
; _this$ = ecx

; 57   : {

  00500	55		 push	 ebp
  00501	8b ec		 mov	 ebp, esp
  00503	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00506	56		 push	 esi
  00507	57		 push	 edi
  00508	51		 push	 ecx
  00509	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  0050c	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00511	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00516	f3 ab		 rep stosd
  00518	59		 pop	 ecx
  00519	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 	if(Destrc.Width()*Imgrc.Height() - Destrc.Height()*Imgrc.Width() > 0)

  0051c	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  0051f	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00524	8b f0		 mov	 esi, eax
  00526	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  00529	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  0052e	0f af f0	 imul	 esi, eax
  00531	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  00534	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00539	8b f8		 mov	 edi, eax
  0053b	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  0053e	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00543	0f af f8	 imul	 edi, eax
  00546	2b f7		 sub	 esi, edi
  00548	85 f6		 test	 esi, esi
  0054a	7e 71		 jle	 SHORT $L187070

; 59   : 	{
; 60   : 		CRect temprc = Imgrc;

  0054c	8b 45 08	 mov	 eax, DWORD PTR _Imgrc$[ebp]
  0054f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00551	89 4d e8	 mov	 DWORD PTR _temprc$187071[ebp], ecx
  00554	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00557	89 55 ec	 mov	 DWORD PTR _temprc$187071[ebp+4], edx
  0055a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0055d	89 4d f0	 mov	 DWORD PTR _temprc$187071[ebp+8], ecx
  00560	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00563	89 55 f4	 mov	 DWORD PTR _temprc$187071[ebp+12], edx

; 61   : 		int newheight;
; 62   : 		newheight = Imgrc.Width() * Destrc.Height()/Destrc.Width();

  00566	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  00569	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0056e	8b f0		 mov	 esi, eax
  00570	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  00573	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00578	0f af f0	 imul	 esi, eax
  0057b	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  0057e	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00583	8b c8		 mov	 ecx, eax
  00585	8b c6		 mov	 eax, esi
  00587	99		 cdq
  00588	f7 f9		 idiv	 ecx
  0058a	89 45 e0	 mov	 DWORD PTR _newheight$187072[ebp], eax

; 63   : 		Imgrc.DeflateRect(0,(temprc.Height() - newheight)/2,0,(temprc.Height() - newheight)/2);

  0058d	8d 4d e8	 lea	 ecx, DWORD PTR _temprc$187071[ebp]
  00590	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00595	2b 45 e0	 sub	 eax, DWORD PTR _newheight$187072[ebp]
  00598	99		 cdq
  00599	2b c2		 sub	 eax, edx
  0059b	d1 f8		 sar	 eax, 1
  0059d	50		 push	 eax
  0059e	6a 00		 push	 0
  005a0	8d 4d e8	 lea	 ecx, DWORD PTR _temprc$187071[ebp]
  005a3	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  005a8	2b 45 e0	 sub	 eax, DWORD PTR _newheight$187072[ebp]
  005ab	99		 cdq
  005ac	2b c2		 sub	 eax, edx
  005ae	d1 f8		 sar	 eax, 1
  005b0	50		 push	 eax
  005b1	6a 00		 push	 0
  005b3	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  005b6	e8 00 00 00 00	 call	 ?DeflateRect@CRect@@QAEXHHHH@Z ; CRect::DeflateRect

; 64   : 	}
; 65   : 	else 

  005bb	eb 6f		 jmp	 SHORT $L187069
$L187070:

; 66   : 	{
; 67   : 		CRect temprc = Imgrc;

  005bd	8b 55 08	 mov	 edx, DWORD PTR _Imgrc$[ebp]
  005c0	8b 02		 mov	 eax, DWORD PTR [edx]
  005c2	89 45 cc	 mov	 DWORD PTR _temprc$187074[ebp], eax
  005c5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  005c8	89 4d d0	 mov	 DWORD PTR _temprc$187074[ebp+4], ecx
  005cb	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  005ce	89 45 d4	 mov	 DWORD PTR _temprc$187074[ebp+8], eax
  005d1	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  005d4	89 4d d8	 mov	 DWORD PTR _temprc$187074[ebp+12], ecx

; 68   : 		int newwidth;
; 69   : 		newwidth = temprc.Height() * Destrc.Width() / Destrc.Height();

  005d7	8d 4d cc	 lea	 ecx, DWORD PTR _temprc$187074[ebp]
  005da	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  005df	8b f0		 mov	 esi, eax
  005e1	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  005e4	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  005e9	0f af f0	 imul	 esi, eax
  005ec	8d 4d 0c	 lea	 ecx, DWORD PTR _Destrc$[ebp]
  005ef	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  005f4	8b c8		 mov	 ecx, eax
  005f6	8b c6		 mov	 eax, esi
  005f8	99		 cdq
  005f9	f7 f9		 idiv	 ecx
  005fb	89 45 c4	 mov	 DWORD PTR _newwidth$187075[ebp], eax

; 70   : 		Imgrc.DeflateRect((temprc.Width() - newwidth)/2,0,(temprc.Width() - newwidth)/2,0);

  005fe	6a 00		 push	 0
  00600	8d 4d cc	 lea	 ecx, DWORD PTR _temprc$187074[ebp]
  00603	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  00608	2b 45 c4	 sub	 eax, DWORD PTR _newwidth$187075[ebp]
  0060b	99		 cdq
  0060c	2b c2		 sub	 eax, edx
  0060e	d1 f8		 sar	 eax, 1
  00610	50		 push	 eax
  00611	6a 00		 push	 0
  00613	8d 4d cc	 lea	 ecx, DWORD PTR _temprc$187074[ebp]
  00616	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0061b	2b 45 c4	 sub	 eax, DWORD PTR _newwidth$187075[ebp]
  0061e	99		 cdq
  0061f	2b c2		 sub	 eax, edx
  00621	d1 f8		 sar	 eax, 1
  00623	50		 push	 eax
  00624	8b 4d 08	 mov	 ecx, DWORD PTR _Imgrc$[ebp]
  00627	e8 00 00 00 00	 call	 ?DeflateRect@CRect@@QAEXHHHH@Z ; CRect::DeflateRect
$L187069:

; 71   : 	}
; 72   : }

  0062c	52		 push	 edx
  0062d	8b cd		 mov	 ecx, ebp
  0062f	50		 push	 eax
  00630	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L187813
  00636	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0063b	58		 pop	 eax
  0063c	5a		 pop	 edx
  0063d	5f		 pop	 edi
  0063e	5e		 pop	 esi
  0063f	83 c4 3c	 add	 esp, 60			; 0000003cH
  00642	3b ec		 cmp	 ebp, esp
  00644	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00649	8b e5		 mov	 esp, ebp
  0064b	5d		 pop	 ebp
  0064c	c2 14 00	 ret	 20			; 00000014H
$L187813:
  0064f	02 00 00 00	 DD	 2
  00653	00 00 00 00	 DD	 $L187812
$L187812:
  00657	e8 ff ff ff	 DD	 -24			; ffffffe8H
  0065b	10 00 00 00	 DD	 16			; 00000010H
  0065f	00 00 00 00	 DD	 $L187810
  00663	cc ff ff ff	 DD	 -52			; ffffffccH
  00667	10 00 00 00	 DD	 16			; 00000010H
  0066b	00 00 00 00	 DD	 $L187811
$L187811:
  0066f	74		 DB	 116			; 00000074H
  00670	65		 DB	 101			; 00000065H
  00671	6d		 DB	 109			; 0000006dH
  00672	70		 DB	 112			; 00000070H
  00673	72		 DB	 114			; 00000072H
  00674	63		 DB	 99			; 00000063H
  00675	00		 DB	 0
$L187810:
  00676	74		 DB	 116			; 00000074H
  00677	65		 DB	 101			; 00000065H
  00678	6d		 DB	 109			; 0000006dH
  00679	70		 DB	 112			; 00000070H
  0067a	72		 DB	 114			; 00000072H
  0067b	63		 DB	 99			; 00000063H
  0067c	00		 DB	 0
?GetShowRect@CDibBitmap@@AAEXAAVCRect@@V2@@Z ENDP	; CDibBitmap::GetShowRect
_TEXT	ENDS
PUBLIC	?Draw@CDibBitmap@@QAEHPAVCDC@@HHHHHHHH@Z	; CDibBitmap::Draw
PUBLIC	?ValidCheck@CDibBitmap@@QAEHXZ			; CDibBitmap::ValidCheck
EXTRN	__imp__SelectPalette@12:NEAR
EXTRN	?SetStretchBltMode@CDC@@QAEHH@Z:NEAR		; CDC::SetStretchBltMode
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hOldPalette$ = -8					; size = 4
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_srcX$ = 12						; size = 4
_srcY$ = 16						; size = 4
_srcW$ = 20						; size = 4
_srcH$ = 24						; size = 4
_dstX$ = 28						; size = 4
_dstY$ = 32						; size = 4
_dstW$ = 36						; size = 4
_dstH$ = 40						; size = 4
?Draw@CDibBitmap@@QAEHPAVCDC@@HHHHHHHH@Z PROC NEAR	; CDibBitmap::Draw
; _this$ = ecx

; 75   : {

  00680	55		 push	 ebp
  00681	8b ec		 mov	 ebp, esp
  00683	83 ec 08	 sub	 esp, 8
  00686	56		 push	 esi
  00687	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0068e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00695	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 76   : 	if(!ValidCheck())

  00698	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0069b	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  006a0	85 c0		 test	 eax, eax
  006a2	75 07		 jne	 SHORT $L187088

; 77   : 		return FALSE;

  006a4	33 c0		 xor	 eax, eax
  006a6	e9 cd 00 00 00	 jmp	 $L187087
$L187088:

; 78   : 	if(m_lpBMIH == NULL) return FALSE;

  006ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  006ae	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  006b2	75 07		 jne	 SHORT $L187089
  006b4	33 c0		 xor	 eax, eax
  006b6	e9 bd 00 00 00	 jmp	 $L187087
$L187089:

; 79   : 	HPALETTE hOldPalette = NULL;

  006bb	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hOldPalette$[ebp], 0

; 80   : 	if(m_hPalette != NULL) {

  006c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006c5	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  006c9	74 24		 je	 SHORT $L187091

; 81   : 		hOldPalette = ::SelectPalette(pDC->GetSafeHdc(), m_hPalette, TRUE);

  006cb	8b f4		 mov	 esi, esp
  006cd	6a 01		 push	 1
  006cf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  006d2	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  006d5	50		 push	 eax
  006d6	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  006d9	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  006de	50		 push	 eax
  006df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  006e5	3b f4		 cmp	 esi, esp
  006e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  006ec	89 45 f8	 mov	 DWORD PTR _hOldPalette$[ebp], eax
$L187091:

; 82   : 	}
; 83   : 	pDC->SetStretchBltMode(COLORONCOLOR);

  006ef	6a 03		 push	 3
  006f1	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  006f4	e8 00 00 00 00	 call	 ?SetStretchBltMode@CDC@@QAEHH@Z ; CDC::SetStretchBltMode

; 84   : 
; 85   : 	::StretchDIBits(pDC->GetSafeHdc(), srcX, srcY, srcW, srcH, dstX, m_lpBMIH->biHeight - dstY, dstW, dstH ,
; 86   : 		m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  006f9	8b f4		 mov	 esi, esp
  006fb	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  00700	6a 00		 push	 0
  00702	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00705	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00708	52		 push	 edx
  00709	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0070c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0070f	51		 push	 ecx
  00710	8b 55 28	 mov	 edx, DWORD PTR _dstH$[ebp]
  00713	52		 push	 edx
  00714	8b 45 24	 mov	 eax, DWORD PTR _dstW$[ebp]
  00717	50		 push	 eax
  00718	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0071b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0071e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00721	2b 45 20	 sub	 eax, DWORD PTR _dstY$[ebp]
  00724	50		 push	 eax
  00725	8b 4d 1c	 mov	 ecx, DWORD PTR _dstX$[ebp]
  00728	51		 push	 ecx
  00729	8b 55 18	 mov	 edx, DWORD PTR _srcH$[ebp]
  0072c	52		 push	 edx
  0072d	8b 45 14	 mov	 eax, DWORD PTR _srcW$[ebp]
  00730	50		 push	 eax
  00731	8b 4d 10	 mov	 ecx, DWORD PTR _srcY$[ebp]
  00734	51		 push	 ecx
  00735	8b 55 0c	 mov	 edx, DWORD PTR _srcX$[ebp]
  00738	52		 push	 edx
  00739	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0073c	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  00741	50		 push	 eax
  00742	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52
  00748	3b f4		 cmp	 esi, esp
  0074a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 87   : 	if (hOldPalette != NULL)

  0074f	83 7d f8 00	 cmp	 DWORD PTR _hOldPalette$[ebp], 0
  00753	74 1e		 je	 SHORT $L187094

; 88   : 	{
; 89   : 		::SelectPalette(pDC->GetSafeHdc(), hOldPalette, TRUE);

  00755	8b f4		 mov	 esi, esp
  00757	6a 01		 push	 1
  00759	8b 45 f8	 mov	 eax, DWORD PTR _hOldPalette$[ebp]
  0075c	50		 push	 eax
  0075d	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  00760	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  00765	50		 push	 eax
  00766	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  0076c	3b f4		 cmp	 esi, esp
  0076e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L187094:

; 90   : 	}
; 91   : 	return TRUE;

  00773	b8 01 00 00 00	 mov	 eax, 1
$L187087:

; 92   : }

  00778	5e		 pop	 esi
  00779	83 c4 08	 add	 esp, 8
  0077c	3b ec		 cmp	 ebp, esp
  0077e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00783	8b e5		 mov	 esp, ebp
  00785	5d		 pop	 ebp
  00786	c2 24 00	 ret	 36			; 00000024H
?Draw@CDibBitmap@@QAEHPAVCDC@@HHHHHHHH@Z ENDP		; CDibBitmap::Draw
; Function compile flags: /Odt /RTCsu
_this$ = -4						; size = 4
?ValidCheck@CDibBitmap@@QAEHXZ PROC NEAR		; CDibBitmap::ValidCheck
; _this$ = ecx

; 95   : {

  00790	55		 push	 ebp
  00791	8b ec		 mov	 ebp, esp
  00793	51		 push	 ecx
  00794	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0079b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   : 	if(this == NULL)

  0079e	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  007a2	75 04		 jne	 SHORT $L187098

; 97   : 		return false;

  007a4	33 c0		 xor	 eax, eax
  007a6	eb 1b		 jmp	 SHORT $L187097
$L187098:

; 98   : 	if(!this->is_Loaded)

  007a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  007ab	0f b6 48 5c	 movzx	 ecx, BYTE PTR [eax+92]
  007af	85 c9		 test	 ecx, ecx
  007b1	75 0b		 jne	 SHORT $L187099

; 99   : 	{
; 100  : #ifdef _DEBUG
; 101  : 		if(!has_PopupError)
; 102  : 			;//AfxMessageBox(" " + this->m_strName  + " ");
; 103  : 		has_PopupError = true;

  007b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007b6	c6 41 5e 01	 mov	 BYTE PTR [ecx+94], 1

; 104  : #endif
; 105  : 		return FALSE;

  007ba	33 c0		 xor	 eax, eax
  007bc	eb 05		 jmp	 SHORT $L187097
$L187099:

; 106  : 	}
; 107  : 	return TRUE;

  007be	b8 01 00 00 00	 mov	 eax, 1
$L187097:

; 108  : }

  007c3	8b e5		 mov	 esp, ebp
  007c5	5d		 pop	 ebp
  007c6	c3		 ret	 0
?ValidCheck@CDibBitmap@@QAEHXZ ENDP			; CDibBitmap::ValidCheck
_TEXT	ENDS
PUBLIC	?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z		; CDibBitmap::Draw
EXTRN	?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z:NEAR ; CDib::Draw
EXTRN	??0CPoint@@QAE@HH@Z:NEAR			; CPoint::CPoint
EXTRN	?Size@CRect@@QBE?AVCSize@@XZ:NEAR		; CRect::Size
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T187818 = -20						; size = 8
$T187817 = -12						; size = 8
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_isBKTransparent$ = 12					; size = 4
_color$ = 16						; size = 4
_mode$ = 20						; size = 4
?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z PROC NEAR		; CDibBitmap::Draw
; _this$ = ecx

; 110  : {

  007d0	55		 push	 ebp
  007d1	8b ec		 mov	 ebp, esp
  007d3	83 ec 14	 sub	 esp, 20			; 00000014H
  007d6	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  007db	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  007de	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  007e1	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  007e4	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  007e7	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  007ea	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 111  : 	if(!ValidCheck())

  007ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  007f0	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  007f5	85 c0		 test	 eax, eax
  007f7	75 04		 jne	 SHORT $L187108

; 112  : 		return FALSE;

  007f9	33 c0		 xor	 eax, eax
  007fb	eb 4b		 jmp	 SHORT $L187107
$L187108:

; 113  : 	return CDib::Draw(pDC, CPoint(m_rect.left,m_rect.top), m_rect.Size(),isBKTransparent, color, (CDib::DrawMode)mode);

  007fd	8b 45 14	 mov	 eax, DWORD PTR _mode$[ebp]
  00800	50		 push	 eax
  00801	8b 4d 10	 mov	 ecx, DWORD PTR _color$[ebp]
  00804	51		 push	 ecx
  00805	8b 55 0c	 mov	 edx, DWORD PTR _isBKTransparent$[ebp]
  00808	52		 push	 edx
  00809	8d 45 f4	 lea	 eax, DWORD PTR $T187817[ebp]
  0080c	50		 push	 eax
  0080d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00810	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00813	e8 00 00 00 00	 call	 ?Size@CRect@@QBE?AVCSize@@XZ ; CRect::Size
  00818	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0081b	51		 push	 ecx
  0081c	8b 10		 mov	 edx, DWORD PTR [eax]
  0081e	52		 push	 edx
  0081f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00822	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00825	51		 push	 ecx
  00826	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00829	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0082c	50		 push	 eax
  0082d	8d 4d ec	 lea	 ecx, DWORD PTR $T187818[ebp]
  00830	e8 00 00 00 00	 call	 ??0CPoint@@QAE@HH@Z	; CPoint::CPoint
  00835	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00838	51		 push	 ecx
  00839	8b 10		 mov	 edx, DWORD PTR [eax]
  0083b	52		 push	 edx
  0083c	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  0083f	50		 push	 eax
  00840	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00843	e8 00 00 00 00	 call	 ?Draw@CDib@@IAEHPAVCDC@@VCPoint@@VCSize@@HKW4DrawMode@1@@Z ; CDib::Draw
$L187107:

; 114  : }

  00848	83 c4 14	 add	 esp, 20			; 00000014H
  0084b	3b ec		 cmp	 ebp, esp
  0084d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00852	8b e5		 mov	 esp, ebp
  00854	5d		 pop	 ebp
  00855	c2 10 00	 ret	 16			; 00000010H
?Draw@CDibBitmap@@QAEHPAVCDC@@HKH@Z ENDP		; CDibBitmap::Draw
_TEXT	ENDS
PUBLIC	?DrawImageList@CDibBitmap@@QAEHPAVCDC@@HUtagPOINT@@H@Z ; CDibBitmap::DrawImageList
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_nHight$ = -12						; size = 4
_nWidth$ = -8						; size = 4
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
_nIndex$ = 12						; size = 4
_pt$ = 16						; size = 8
_nCount$ = 24						; size = 4
?DrawImageList@CDibBitmap@@QAEHPAVCDC@@HUtagPOINT@@H@Z PROC NEAR ; CDibBitmap::DrawImageList
; _this$ = ecx

; 116  : {

  00860	55		 push	 ebp
  00861	8b ec		 mov	 ebp, esp
  00863	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00866	56		 push	 esi
  00867	57		 push	 edi
  00868	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0086f	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00876	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0087d	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	if( (m_count <= 0) || (nIndex>=m_count) || (nCount<1) )

  00880	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00883	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  00887	7e 11		 jle	 SHORT $L187120
  00889	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0088c	8b 55 0c	 mov	 edx, DWORD PTR _nIndex$[ebp]
  0088f	3b 51 64	 cmp	 edx, DWORD PTR [ecx+100]
  00892	7d 06		 jge	 SHORT $L187120
  00894	83 7d 18 01	 cmp	 DWORD PTR _nCount$[ebp], 1
  00898	7d 07		 jge	 SHORT $L187119
$L187120:

; 118  : 		return FALSE;

  0089a	33 c0		 xor	 eax, eax
  0089c	e9 06 01 00 00	 jmp	 $L187118
$L187119:

; 119  : 	
; 120  : 
; 121  : 	if(!ValidCheck())

  008a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008a4	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  008a9	85 c0		 test	 eax, eax
  008ab	75 07		 jne	 SHORT $L187121

; 122  : 		return FALSE;

  008ad	33 c0		 xor	 eax, eax
  008af	e9 f3 00 00 00	 jmp	 $L187118
$L187121:

; 123  : 	if(m_lpBMIH == NULL) return FALSE;

  008b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  008b7	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  008bb	75 07		 jne	 SHORT $L187122
  008bd	33 c0		 xor	 eax, eax
  008bf	e9 e3 00 00 00	 jmp	 $L187118
$L187122:

; 124  : 	if(m_hPalette != NULL) {

  008c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  008c7	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  008cb	74 21		 je	 SHORT $L187123

; 125  : 		::SelectPalette(pDC->GetSafeHdc(), m_hPalette, TRUE);

  008cd	8b f4		 mov	 esi, esp
  008cf	6a 01		 push	 1
  008d1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  008d4	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  008d7	50		 push	 eax
  008d8	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  008db	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  008e0	50		 push	 eax
  008e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SelectPalette@12
  008e7	3b f4		 cmp	 esi, esp
  008e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L187123:

; 126  : 	}
; 127  : 	pDC->SetStretchBltMode(COLORONCOLOR);

  008ee	6a 03		 push	 3
  008f0	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  008f3	e8 00 00 00 00	 call	 ?SetStretchBltMode@CDC@@QAEHH@Z ; CDC::SetStretchBltMode

; 128  : 
; 129  : 	int nWidth;
; 130  : 	if( nCount == 1 )

  008f8	83 7d 18 01	 cmp	 DWORD PTR _nCount$[ebp], 1
  008fc	75 15		 jne	 SHORT $L187125

; 131  : 	{
; 132  : 		nWidth =m_lpBMIH->biWidth/m_count;

  008fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00901	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00904	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00907	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0090a	99		 cdq
  0090b	f7 79 64	 idiv	 DWORD PTR [ecx+100]
  0090e	89 45 f8	 mov	 DWORD PTR _nWidth$[ebp], eax

; 133  : 	}
; 134  : 	else

  00911	eb 12		 jmp	 SHORT $L187126
$L187125:

; 135  : 	{
; 136  : 		nWidth = m_rect.Width()  / nCount;

  00913	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00916	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00919	e8 00 00 00 00	 call	 ?Width@CRect@@QBEHXZ	; CRect::Width
  0091e	99		 cdq
  0091f	f7 7d 18	 idiv	 DWORD PTR _nCount$[ebp]
  00922	89 45 f8	 mov	 DWORD PTR _nWidth$[ebp], eax
$L187126:

; 137  : 	}
; 138  : 	int nHight = m_rect.Height();

  00925	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00928	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0092b	e8 00 00 00 00	 call	 ?Height@CRect@@QBEHXZ	; CRect::Height
  00930	89 45 f4	 mov	 DWORD PTR _nHight$[ebp], eax

; 139  : 	::StretchDIBits(pDC->GetSafeHdc(), pt.x, pt.y, nWidth,nHight, m_lpBMIH->biWidth/m_count*nIndex, 0, m_lpBMIH->biWidth/m_count, m_lpBMIH->biHeight ,
; 140  : 		m_lpImage, (LPBITMAPINFO) m_lpBMIH, DIB_RGB_COLORS, SRCCOPY);

  00933	8b f4		 mov	 esi, esp
  00935	68 20 00 cc 00	 push	 13369376		; 00cc0020H
  0093a	6a 00		 push	 0
  0093c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0093f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00942	50		 push	 eax
  00943	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00946	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00949	52		 push	 edx
  0094a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0094d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00950	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00953	52		 push	 edx
  00954	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00957	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0095a	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0095d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00960	99		 cdq
  00961	f7 7f 64	 idiv	 DWORD PTR [edi+100]
  00964	50		 push	 eax
  00965	6a 00		 push	 0
  00967	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0096a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0096d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00970	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00973	99		 cdq
  00974	f7 79 64	 idiv	 DWORD PTR [ecx+100]
  00977	0f af 45 0c	 imul	 eax, DWORD PTR _nIndex$[ebp]
  0097b	50		 push	 eax
  0097c	8b 55 f4	 mov	 edx, DWORD PTR _nHight$[ebp]
  0097f	52		 push	 edx
  00980	8b 45 f8	 mov	 eax, DWORD PTR _nWidth$[ebp]
  00983	50		 push	 eax
  00984	8b 4d 14	 mov	 ecx, DWORD PTR _pt$[ebp+4]
  00987	51		 push	 ecx
  00988	8b 55 10	 mov	 edx, DWORD PTR _pt$[ebp]
  0098b	52		 push	 edx
  0098c	8b 4d 08	 mov	 ecx, DWORD PTR _pDC$[ebp]
  0098f	e8 00 00 00 00	 call	 ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ ; CDC::GetSafeHdc
  00994	50		 push	 eax
  00995	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StretchDIBits@52
  0099b	3b f4		 cmp	 esi, esp
  0099d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 141  : 	return TRUE;

  009a2	b8 01 00 00 00	 mov	 eax, 1
$L187118:

; 142  : }

  009a7	5f		 pop	 edi
  009a8	5e		 pop	 esi
  009a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  009ac	3b ec		 cmp	 ebp, esp
  009ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  009b3	8b e5		 mov	 esp, ebp
  009b5	5d		 pop	 ebp
  009b6	c2 14 00	 ret	 20			; 00000014H
?DrawImageList@CDibBitmap@@QAEHPAVCDC@@HUtagPOINT@@H@Z ENDP ; CDibBitmap::DrawImageList
_TEXT	ENDS
PUBLIC	?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z		; CDibBitmap::SetCDibRect
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rect$ = 8						; size = 16
?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z PROC NEAR	; CDibBitmap::SetCDibRect
; _this$ = ecx

; 144  : {

  009c0	55		 push	 ebp
  009c1	8b ec		 mov	 ebp, esp
  009c3	51		 push	 ecx
  009c4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  009cb	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 145  : 	if(!ValidCheck())

  009ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  009d1	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  009d6	85 c0		 test	 eax, eax
  009d8	75 02		 jne	 SHORT $L187134

; 146  : 		return;

  009da	eb 1d		 jmp	 SHORT $L187133
$L187134:

; 147  : 	m_rect = rect;

  009dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  009df	83 c0 3c	 add	 eax, 60			; 0000003cH
  009e2	8b 4d 08	 mov	 ecx, DWORD PTR _rect$[ebp]
  009e5	89 08		 mov	 DWORD PTR [eax], ecx
  009e7	8b 55 0c	 mov	 edx, DWORD PTR _rect$[ebp+4]
  009ea	89 50 04	 mov	 DWORD PTR [eax+4], edx
  009ed	8b 4d 10	 mov	 ecx, DWORD PTR _rect$[ebp+8]
  009f0	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  009f3	8b 55 14	 mov	 edx, DWORD PTR _rect$[ebp+12]
  009f6	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$L187133:

; 148  : }

  009f9	83 c4 04	 add	 esp, 4
  009fc	3b ec		 cmp	 ebp, esp
  009fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a03	8b e5		 mov	 esp, ebp
  00a05	5d		 pop	 ebp
  00a06	c2 10 00	 ret	 16			; 00000010H
?SetCDibRect@CDibBitmap@@QAEXVCRect@@@Z ENDP		; CDibBitmap::SetCDibRect
_TEXT	ENDS
PUBLIC	?SetCount@CDibBitmap@@QAEXH@Z			; CDibBitmap::SetCount
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nCount$ = 8						; size = 4
?SetCount@CDibBitmap@@QAEXH@Z PROC NEAR			; CDibBitmap::SetCount
; _this$ = ecx

; 150  : {

  00a10	55		 push	 ebp
  00a11	8b ec		 mov	 ebp, esp
  00a13	51		 push	 ecx
  00a14	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00a1b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 151  : 	m_count = nCount;

  00a1e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00a21	8b 4d 08	 mov	 ecx, DWORD PTR _nCount$[ebp]
  00a24	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 152  : 
; 153  : }

  00a27	8b e5		 mov	 esp, ebp
  00a29	5d		 pop	 ebp
  00a2a	c2 04 00	 ret	 4
?SetCount@CDibBitmap@@QAEXH@Z ENDP			; CDibBitmap::SetCount
_TEXT	ENDS
PUBLIC	?CreateBitmap@CDibBitmap@@QAEPAUHBITMAP__@@PAVCDC@@@Z ; CDibBitmap::CreateBitmap
PUBLIC	?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCDC@@@Z ; CDibBitmap::CreateRgnFromBitmap
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__imp__CreateICA@16:NEAR
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	__imp__DeleteDC@4:NEAR
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	__RTC_UninitUse:NEAR
EXTRN	__imp__ExtCreateRegion@12:NEAR
EXTRN	__imp__GetDIBits@28:NEAR
EXTRN	__imp__GetObjectA@12:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv242 = -268						; size = 4
$T187837 = -261						; size = 1
$T187836 = -260						; size = 4
$T187835 = -256						; size = 4
$T187834 = -252						; size = 4
$T187833 = -248						; size = 4
$T187832 = -244						; size = 4
$T187831 = -240						; size = 16
$T187830 = -224						; size = 4
$T187829 = -220						; size = 4
$T187828 = -216						; size = 16
$T187827 = -200						; size = 4
$T187826 = -196						; size = 4
$T187825 = -192						; size = 4
$T187824 = -188						; size = 4
$T187823 = -184						; size = 4
_hRgn$ = -180						; size = 4
_i$187252 = -176					; size = 4
_pRgnDataNew$187242 = -172				; size = 4
_pRgnDataNew$187228 = -168				; size = 4
_k$187208 = -164					; size = 4
_pRects$ = -160						; size = 4
_pRgnData$ = -156					; size = 4
_ismask$ = -150						; size = 1
_wasfirst$ = -149					; size = 1
_first$ = -148						; size = 4
_j$ = -144						; size = 4
_i$ = -140						; size = 4
_dwRectsCount$ = -136					; size = 4
_dwLineBackLen$ = -132					; size = 4
_pColor$ = -128						; size = 4
_m_dwAlignedWidthBytes$ = -124				; size = 4
_Bpp$ = -117						; size = 1
_ADD_RECTS_COUNT$ = -116				; size = 4
_RGNDATAHEADER_SIZE$ = -112				; size = 4
_tmp$ = -105						; size = 1
_pClr$ = -104						; size = 4
_bm$ = -96						; size = 24
_clr_tbl$ = -68						; size = 4
_bih$ = -64						; size = 4
_old_bi$187162 = -60					; size = 4
_pBits$ = -56						; size = 4
_res$ = -52						; size = 4
_dc$ = -48						; size = 4
_bi$ = -44						; size = 4
_bmp$ = -36						; size = 24
_hBmp$ = -8						; size = 4
_this$ = -4						; size = 4
_color$ = 8						; size = 4
_pDC$ = 12						; size = 4
?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCDC@@@Z PROC NEAR ; CDibBitmap::CreateRgnFromBitmap
; _this$ = ecx

; 155  : {

  00a30	55		 push	 ebp
  00a31	8b ec		 mov	 ebp, esp
  00a33	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00a39	56		 push	 esi
  00a3a	57		 push	 edi
  00a3b	51		 push	 ecx
  00a3c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00a42	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00a47	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00a4c	f3 ab		 rep stosd
  00a4e	59		 pop	 ecx
  00a4f	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00a52	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR $T187837[ebp], 0

; 156  : 	if(!ValidCheck())

  00a59	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a5c	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  00a61	85 c0		 test	 eax, eax
  00a63	75 07		 jne	 SHORT $L187144

; 157  : 		return NULL;

  00a65	33 c0		 xor	 eax, eax
  00a67	e9 ac 07 00 00	 jmp	 $L187143
$L187144:

; 158  : 	HBITMAP hBmp = CreateBitmap(pDC);

  00a6c	8b 45 0c	 mov	 eax, DWORD PTR _pDC$[ebp]
  00a6f	50		 push	 eax
  00a70	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a73	e8 00 00 00 00	 call	 ?CreateBitmap@CDibBitmap@@QAEPAUHBITMAP__@@PAVCDC@@@Z ; CDibBitmap::CreateBitmap
  00a78	89 45 f8	 mov	 DWORD PTR _hBmp$[ebp], eax

; 159  : 	// get image properties
; 160  : 	BITMAP bmp = { 0 };

  00a7b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bmp$[ebp], 0
  00a82	33 c9		 xor	 ecx, ecx
  00a84	89 4d e0	 mov	 DWORD PTR _bmp$[ebp+4], ecx
  00a87	89 4d e4	 mov	 DWORD PTR _bmp$[ebp+8], ecx
  00a8a	89 4d e8	 mov	 DWORD PTR _bmp$[ebp+12], ecx
  00a8d	89 4d ec	 mov	 DWORD PTR _bmp$[ebp+16], ecx
  00a90	89 4d f0	 mov	 DWORD PTR _bmp$[ebp+20], ecx

; 161  : 	GetObject( hBmp, sizeof(BITMAP), &bmp );

  00a93	8b f4		 mov	 esi, esp
  00a95	8d 55 dc	 lea	 edx, DWORD PTR _bmp$[ebp]
  00a98	52		 push	 edx
  00a99	6a 18		 push	 24			; 00000018H
  00a9b	8b 45 f8	 mov	 eax, DWORD PTR _hBmp$[ebp]
  00a9e	50		 push	 eax
  00a9f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12
  00aa5	3b f4		 cmp	 esi, esp
  00aa7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 162  : 	// allocate memory for extended image information
; 163  : 	LPBITMAPINFO bi = (LPBITMAPINFO) new BYTE[ sizeof(BITMAPINFO) + 8 ];

  00aac	6a 34		 push	 52			; 00000034H
  00aae	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00ab3	83 c4 04	 add	 esp, 4
  00ab6	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T187823[ebp], eax
  00abc	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR $T187823[ebp]
  00ac2	89 4d d4	 mov	 DWORD PTR _bi$[ebp], ecx

; 164  : 	memset( bi, 0, sizeof(BITMAPINFO) + 8 );

  00ac5	6a 34		 push	 52			; 00000034H
  00ac7	6a 00		 push	 0
  00ac9	8b 55 d4	 mov	 edx, DWORD PTR _bi$[ebp]
  00acc	52		 push	 edx
  00acd	e8 00 00 00 00	 call	 _memset
  00ad2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 	bi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

  00ad5	8b 45 d4	 mov	 eax, DWORD PTR _bi$[ebp]
  00ad8	c7 00 28 00 00
	00		 mov	 DWORD PTR [eax], 40	; 00000028H

; 166  : 	// set window size
; 167  : 	//m_dwWidth	= bmp.bmWidth;		// bitmap width
; 168  : 	//m_dwHeight	= bmp.bmHeight;		// bitmap height
; 169  : 	// create temporary dc
; 170  : 	HDC dc = CreateIC( "DISPLAY",NULL,NULL,NULL );

  00ade	8b f4		 mov	 esi, esp
  00ae0	6a 00		 push	 0
  00ae2	6a 00		 push	 0
  00ae4	6a 00		 push	 0
  00ae6	68 00 00 00 00	 push	 OFFSET FLAT:$SG187156
  00aeb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateICA@16
  00af1	3b f4		 cmp	 esi, esp
  00af3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00af8	89 45 d0	 mov	 DWORD PTR _dc$[ebp], eax

; 171  : 	// get extended information about image (length, compression, length of color table if exist, ...)
; 172  : 	DWORD res = GetDIBits( dc, hBmp, 0, bmp.bmHeight, 0, bi, DIB_RGB_COLORS );

  00afb	8b f4		 mov	 esi, esp
  00afd	6a 00		 push	 0
  00aff	8b 4d d4	 mov	 ecx, DWORD PTR _bi$[ebp]
  00b02	51		 push	 ecx
  00b03	6a 00		 push	 0
  00b05	8b 55 e4	 mov	 edx, DWORD PTR _bmp$[ebp+8]
  00b08	52		 push	 edx
  00b09	6a 00		 push	 0
  00b0b	8b 45 f8	 mov	 eax, DWORD PTR _hBmp$[ebp]
  00b0e	50		 push	 eax
  00b0f	8b 4d d0	 mov	 ecx, DWORD PTR _dc$[ebp]
  00b12	51		 push	 ecx
  00b13	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDIBits@28
  00b19	3b f4		 cmp	 esi, esp
  00b1b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b20	89 45 cc	 mov	 DWORD PTR _res$[ebp], eax

; 173  : 	// allocate memory for image data (colors)
; 174  : 	LPBYTE pBits = new BYTE[ bi->bmiHeader.biSizeImage + 4 ];

  00b23	8b 55 d4	 mov	 edx, DWORD PTR _bi$[ebp]
  00b26	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00b29	83 c0 04	 add	 eax, 4
  00b2c	50		 push	 eax
  00b2d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00b32	83 c4 04	 add	 esp, 4
  00b35	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T187824[ebp], eax
  00b3b	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR $T187824[ebp]
  00b41	89 4d c8	 mov	 DWORD PTR _pBits$[ebp], ecx

; 175  : 	// allocate memory for color table
; 176  : 	if ( bi->bmiHeader.biBitCount == 8 )

  00b44	8b 55 d4	 mov	 edx, DWORD PTR _bi$[ebp]
  00b47	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00b4b	83 f8 08	 cmp	 eax, 8
  00b4e	75 4c		 jne	 SHORT $L187161

; 177  : 	{
; 178  : 		// actually color table should be appended to this header(BITMAPINFO),
; 179  : 		// so we have to reallocate and copy it
; 180  : 		LPBITMAPINFO old_bi = bi;

  00b50	8b 4d d4	 mov	 ecx, DWORD PTR _bi$[ebp]
  00b53	89 4d c4	 mov	 DWORD PTR _old_bi$187162[ebp], ecx

; 181  : 		// 255 - because there is one in BITMAPINFOHEADER
; 182  : 		bi = (LPBITMAPINFO)new char[ sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD) ];

  00b56	68 28 04 00 00	 push	 1064			; 00000428H
  00b5b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00b60	83 c4 04	 add	 esp, 4
  00b63	89 85 40 ff ff
	ff		 mov	 DWORD PTR $T187825[ebp], eax
  00b69	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR $T187825[ebp]
  00b6f	89 55 d4	 mov	 DWORD PTR _bi$[ebp], edx

; 183  : 		memcpy( bi, old_bi, sizeof(BITMAPINFO) );

  00b72	6a 2c		 push	 44			; 0000002cH
  00b74	8b 45 c4	 mov	 eax, DWORD PTR _old_bi$187162[ebp]
  00b77	50		 push	 eax
  00b78	8b 4d d4	 mov	 ecx, DWORD PTR _bi$[ebp]
  00b7b	51		 push	 ecx
  00b7c	e8 00 00 00 00	 call	 _memcpy
  00b81	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 		// release old header
; 185  : 		delete old_bi;

  00b84	8b 55 c4	 mov	 edx, DWORD PTR _old_bi$187162[ebp]
  00b87	89 95 3c ff ff
	ff		 mov	 DWORD PTR $T187826[ebp], edx
  00b8d	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR $T187826[ebp]
  00b93	50		 push	 eax
  00b94	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00b99	83 c4 04	 add	 esp, 4
$L187161:

; 186  : 	}
; 187  : 	// get bitmap info header
; 188  : 	BITMAPINFOHEADER& bih = bi->bmiHeader;

  00b9c	8b 4d d4	 mov	 ecx, DWORD PTR _bi$[ebp]
  00b9f	89 4d c0	 mov	 DWORD PTR _bih$[ebp], ecx

; 189  : 	// get color table (for 256 color mode contains 256 entries of RGBQUAD(=DWORD))
; 190  : 	LPDWORD clr_tbl = (LPDWORD)&bi->bmiColors;

  00ba2	8b 55 d4	 mov	 edx, DWORD PTR _bi$[ebp]
  00ba5	83 c2 28	 add	 edx, 40			; 00000028H
  00ba8	89 55 bc	 mov	 DWORD PTR _clr_tbl$[ebp], edx

; 191  : 	// fill bits buffer
; 192  : 	res = GetDIBits( dc, hBmp, 0, bih.biHeight, pBits, bi, DIB_RGB_COLORS );

  00bab	8b f4		 mov	 esi, esp
  00bad	6a 00		 push	 0
  00baf	8b 45 d4	 mov	 eax, DWORD PTR _bi$[ebp]
  00bb2	50		 push	 eax
  00bb3	8b 4d c8	 mov	 ecx, DWORD PTR _pBits$[ebp]
  00bb6	51		 push	 ecx
  00bb7	8b 55 c0	 mov	 edx, DWORD PTR _bih$[ebp]
  00bba	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00bbd	50		 push	 eax
  00bbe	6a 00		 push	 0
  00bc0	8b 4d f8	 mov	 ecx, DWORD PTR _hBmp$[ebp]
  00bc3	51		 push	 ecx
  00bc4	8b 55 d0	 mov	 edx, DWORD PTR _dc$[ebp]
  00bc7	52		 push	 edx
  00bc8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDIBits@28
  00bce	3b f4		 cmp	 esi, esp
  00bd0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00bd5	89 45 cc	 mov	 DWORD PTR _res$[ebp], eax

; 193  : 	DeleteDC( dc );

  00bd8	8b f4		 mov	 esi, esp
  00bda	8b 45 d0	 mov	 eax, DWORD PTR _dc$[ebp]
  00bdd	50		 push	 eax
  00bde	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
  00be4	3b f4		 cmp	 esi, esp
  00be6	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 194  : 
; 195  : 	BITMAP bm;
; 196  : 	GetObject( hBmp, sizeof(BITMAP), &bm );

  00beb	8b f4		 mov	 esi, esp
  00bed	8d 4d a0	 lea	 ecx, DWORD PTR _bm$[ebp]
  00bf0	51		 push	 ecx
  00bf1	6a 18		 push	 24			; 00000018H
  00bf3	8b 55 f8	 mov	 edx, DWORD PTR _hBmp$[ebp]
  00bf6	52		 push	 edx
  00bf7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12
  00bfd	3b f4		 cmp	 esi, esp
  00bff	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 197  : 	// shift bits and byte per pixel (for comparing colors)
; 198  : 	LPBYTE pClr = (LPBYTE)&color;

  00c04	8d 45 08	 lea	 eax, DWORD PTR _color$[ebp]
  00c07	89 45 98	 mov	 DWORD PTR _pClr$[ebp], eax

; 199  : 	// swap red and blue components
; 200  : 	BYTE tmp = pClr[0]; pClr[0] = pClr[2]; pClr[2] = tmp;

  00c0a	8b 4d 98	 mov	 ecx, DWORD PTR _pClr$[ebp]
  00c0d	8a 11		 mov	 dl, BYTE PTR [ecx]
  00c0f	88 55 97	 mov	 BYTE PTR _tmp$[ebp], dl
  00c12	8b 45 98	 mov	 eax, DWORD PTR _pClr$[ebp]
  00c15	8b 4d 98	 mov	 ecx, DWORD PTR _pClr$[ebp]
  00c18	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  00c1b	88 10		 mov	 BYTE PTR [eax], dl
  00c1d	8b 45 98	 mov	 eax, DWORD PTR _pClr$[ebp]
  00c20	8a 4d 97	 mov	 cl, BYTE PTR _tmp$[ebp]
  00c23	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 201  : 	// convert color if curent DC is 16-bit (5:6:5) or 15-bit (5:5:5)
; 202  : 	if ( bih.biBitCount == 16 )

  00c26	8b 55 c0	 mov	 edx, DWORD PTR _bih$[ebp]
  00c29	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00c2d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00c30	75 36		 jne	 SHORT $L187178

; 203  : 	{
; 204  : 		// for 16 bit
; 205  : 		color = ((DWORD)(pClr[0] & 0xf8) >> 3) |
; 206  : 				((DWORD)(pClr[1] & 0xfc) << 3) |
; 207  : 				((DWORD)(pClr[2] & 0xf8) << 8);

  00c32	8b 4d 98	 mov	 ecx, DWORD PTR _pClr$[ebp]
  00c35	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00c38	81 e2 f8 00 00
	00		 and	 edx, 248		; 000000f8H
  00c3e	c1 ea 03	 shr	 edx, 3
  00c41	8b 45 98	 mov	 eax, DWORD PTR _pClr$[ebp]
  00c44	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00c48	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00c4e	c1 e1 03	 shl	 ecx, 3
  00c51	0b d1		 or	 edx, ecx
  00c53	8b 45 98	 mov	 eax, DWORD PTR _pClr$[ebp]
  00c56	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00c5a	81 e1 f8 00 00
	00		 and	 ecx, 248		; 000000f8H
  00c60	c1 e1 08	 shl	 ecx, 8
  00c63	0b d1		 or	 edx, ecx
  00c65	89 55 08	 mov	 DWORD PTR _color$[ebp], edx
$L187178:

; 208  : 		// for 15 bit
; 209  : //		color = ((DWORD)(pClr[0] & 0xf8) >> 3) |
; 210  : //				((DWORD)(pClr[1] & 0xf8) << 2) |
; 211  : //				((DWORD)(pClr[2] & 0xf8) << 7);
; 212  : 	}
; 213  : 
; 214  : 	const DWORD RGNDATAHEADER_SIZE	= sizeof(RGNDATAHEADER);

  00c68	c7 45 90 20 00
	00 00		 mov	 DWORD PTR _RGNDATAHEADER_SIZE$[ebp], 32 ; 00000020H

; 215  : 	const DWORD ADD_RECTS_COUNT		= 40;			// number of rects to be appended

  00c6f	c7 45 8c 28 00
	00 00		 mov	 DWORD PTR _ADD_RECTS_COUNT$[ebp], 40 ; 00000028H

; 216  : 													// to region data buffer
; 217  : 
; 218  : 	// BitPerPixel
; 219  : 	BYTE	Bpp = bih.biBitCount >> 3;				// bytes per pixel

  00c76	8b 55 c0	 mov	 edx, DWORD PTR _bih$[ebp]
  00c79	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00c7d	c1 f8 03	 sar	 eax, 3
  00c80	88 45 8b	 mov	 BYTE PTR _Bpp$[ebp], al

; 220  : 	// bytes per line in pBits is DWORD aligned and bmp.bmWidthBytes is WORD aligned
; 221  : 	// so, both of them not
; 222  : 	DWORD m_dwAlignedWidthBytes = (bmp.bmWidthBytes & ~0x3) + (!!(bmp.bmWidthBytes & 0x3) << 2);

  00c83	8b 4d e8	 mov	 ecx, DWORD PTR _bmp$[ebp+12]
  00c86	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00c89	8b 55 e8	 mov	 edx, DWORD PTR _bmp$[ebp+12]
  00c8c	83 e2 03	 and	 edx, 3
  00c8f	f7 da		 neg	 edx
  00c91	1b d2		 sbb	 edx, edx
  00c93	f7 da		 neg	 edx
  00c95	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00c98	89 45 84	 mov	 DWORD PTR _m_dwAlignedWidthBytes$[ebp], eax

; 223  : 	// DIB image is flipped that's why we scan it from the last line
; 224  : 	LPBYTE	pColor = pBits + (bih.biHeight - 1) * m_dwAlignedWidthBytes;

  00c9b	8b 4d c0	 mov	 ecx, DWORD PTR _bih$[ebp]
  00c9e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00ca1	83 ea 01	 sub	 edx, 1
  00ca4	0f af 55 84	 imul	 edx, DWORD PTR _m_dwAlignedWidthBytes$[ebp]
  00ca8	03 55 c8	 add	 edx, DWORD PTR _pBits$[ebp]
  00cab	89 55 80	 mov	 DWORD PTR _pColor$[ebp], edx

; 225  : 	DWORD	dwLineBackLen = m_dwAlignedWidthBytes + bih.biWidth * Bpp;	// offset of previous scan line

  00cae	0f b6 45 8b	 movzx	 eax, BYTE PTR _Bpp$[ebp]
  00cb2	8b 4d c0	 mov	 ecx, DWORD PTR _bih$[ebp]
  00cb5	0f af 41 04	 imul	 eax, DWORD PTR [ecx+4]
  00cb9	03 45 84	 add	 eax, DWORD PTR _m_dwAlignedWidthBytes$[ebp]
  00cbc	89 85 7c ff ff
	ff		 mov	 DWORD PTR _dwLineBackLen$[ebp], eax

; 226  : 													// (after processing of current)
; 227  : 	DWORD	dwRectsCount = bih.biHeight;			// number of rects in allocated buffer

  00cc2	8b 55 c0	 mov	 edx, DWORD PTR _bih$[ebp]
  00cc5	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00cc8	89 85 78 ff ff
	ff		 mov	 DWORD PTR _dwRectsCount$[ebp], eax

; 228  : 	INT		i, j;									// current position in mask image
; 229  : 	INT		first = 0;								// left position of current scan line

  00cce	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _first$[ebp], 0

; 230  : 													// where mask was found
; 231  : 	bool	wasfirst = false;						// set when mask has been found in current scan line

  00cd8	c6 85 6b ff ff
	ff 00		 mov	 BYTE PTR _wasfirst$[ebp], 0

; 232  : 	bool	ismask;									// set when current color is mask color
; 233  : 
; 234  : 	// allocate memory for region data
; 235  : 	// region data here is set of regions that are rectangles with height 1 pixel (scan line)
; 236  : 	// that's why first allocation is <bm.biHeight> RECTs - number of scan lines in image
; 237  : 	RGNDATAHEADER* pRgnData = 
; 238  : 		(RGNDATAHEADER*)new BYTE[ RGNDATAHEADER_SIZE + dwRectsCount * sizeof(RECT) ];

  00cdf	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _dwRectsCount$[ebp]
  00ce5	c1 e1 04	 shl	 ecx, 4
  00ce8	83 c1 20	 add	 ecx, 32			; 00000020H
  00ceb	51		 push	 ecx
  00cec	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00cf1	83 c4 04	 add	 esp, 4
  00cf4	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T187827[ebp], eax
  00cfa	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR $T187827[ebp]
  00d00	89 95 64 ff ff
	ff		 mov	 DWORD PTR _pRgnData$[ebp], edx

; 239  : 	// get pointer to RECT table
; 240  : 	LPRECT pRects = (LPRECT)((LPBYTE)pRgnData + RGNDATAHEADER_SIZE);

  00d06	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00d0c	83 c0 20	 add	 eax, 32			; 00000020H
  00d0f	89 85 60 ff ff
	ff		 mov	 DWORD PTR _pRects$[ebp], eax

; 241  : 	// zero region data header memory (header  part only)
; 242  : 	memset( pRgnData, 0, RGNDATAHEADER_SIZE + dwRectsCount * sizeof(RECT) );

  00d15	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _dwRectsCount$[ebp]
  00d1b	c1 e1 04	 shl	 ecx, 4
  00d1e	83 c1 20	 add	 ecx, 32			; 00000020H
  00d21	51		 push	 ecx
  00d22	6a 00		 push	 0
  00d24	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00d2a	52		 push	 edx
  00d2b	e8 00 00 00 00	 call	 _memset
  00d30	83 c4 0c	 add	 esp, 12			; 0000000cH

; 243  : 	// fill it by default
; 244  : 	pRgnData->dwSize	= RGNDATAHEADER_SIZE;

  00d33	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00d39	c7 00 20 00 00
	00		 mov	 DWORD PTR [eax], 32	; 00000020H

; 245  : 	pRgnData->iType		= RDH_RECTANGLES;

  00d3f	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00d45	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 246  : 
; 247  : 	for ( i = 0; i < bih.biHeight; i++ )

  00d4c	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00d56	eb 0f		 jmp	 SHORT $L187204
$L187205:
  00d58	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  00d5e	83 c2 01	 add	 edx, 1
  00d61	89 95 74 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], edx
$L187204:
  00d67	8b 45 c0	 mov	 eax, DWORD PTR _bih$[ebp]
  00d6a	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00d70	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00d73	0f 8d f2 03 00
	00		 jge	 $L187206

; 248  : 	{
; 249  : 		if(i == 35)

  00d79	83 bd 74 ff ff
	ff 23		 cmp	 DWORD PTR _i$[ebp], 35	; 00000023H
  00d80	75 0a		 jne	 SHORT $L187207

; 250  : 			int k = 0;

  00d82	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _k$187208[ebp], 0
$L187207:

; 251  : 		for ( j = 0; j < bih.biWidth; j++ )

  00d8c	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _j$[ebp], 0
  00d96	eb 0f		 jmp	 SHORT $L187209
$L187210:
  00d98	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00d9e	83 c2 01	 add	 edx, 1
  00da1	89 95 70 ff ff
	ff		 mov	 DWORD PTR _j$[ebp], edx
$L187209:
  00da7	8b 45 c0	 mov	 eax, DWORD PTR _bih$[ebp]
  00daa	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  00db0	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00db3	0f 8d 4a 02 00
	00		 jge	 $L187211

; 252  : 		{
; 253  : 			// get color
; 254  : 			switch ( bih.biBitCount )

  00db9	8b 55 c0	 mov	 edx, DWORD PTR _bih$[ebp]
  00dbc	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00dc0	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv242[ebp], eax
  00dc6	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv242[ebp]
  00dcc	83 e9 08	 sub	 ecx, 8
  00dcf	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv242[ebp], ecx
  00dd5	83 bd f4 fe ff
	ff 18		 cmp	 DWORD PTR tv242[ebp], 24 ; 00000018H
  00ddc	0f 87 93 00 00
	00		 ja	 $L187213
  00de2	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv242[ebp]
  00de8	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $L187843[edx]
  00def	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L187848[eax*4]
$L187216:

; 255  : 			{
; 256  : 			case 8:
; 257  : 				ismask = (clr_tbl[ *pColor ] != color);

  00df6	8b 4d 80	 mov	 ecx, DWORD PTR _pColor$[ebp]
  00df9	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00dfc	8b 45 bc	 mov	 eax, DWORD PTR _clr_tbl$[ebp]
  00dff	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00e02	33 d2		 xor	 edx, edx
  00e04	3b 4d 08	 cmp	 ecx, DWORD PTR _color$[ebp]
  00e07	0f 95 c2	 setne	 dl
  00e0a	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR $T187837[ebp], 1
  00e11	88 95 6a ff ff
	ff		 mov	 BYTE PTR _ismask$[ebp], dl

; 258  : 				break;

  00e17	eb 5c		 jmp	 SHORT $L187213
$L187217:

; 259  : 			case 16:
; 260  : 				ismask = (*(LPWORD)pColor != (WORD)color);

  00e19	8b 45 80	 mov	 eax, DWORD PTR _pColor$[ebp]
  00e1c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00e1f	0f b7 55 08	 movzx	 edx, WORD PTR _color$[ebp]
  00e23	33 c0		 xor	 eax, eax
  00e25	3b ca		 cmp	 ecx, edx
  00e27	0f 95 c0	 setne	 al
  00e2a	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR $T187837[ebp], 1
  00e31	88 85 6a ff ff
	ff		 mov	 BYTE PTR _ismask$[ebp], al

; 261  : 				break;

  00e37	eb 3c		 jmp	 SHORT $L187213
$L187220:

; 262  : 			case 24:
; 263  : 				ismask = ((*(LPDWORD)pColor & 0x00ffffff) != color);

  00e39	8b 4d 80	 mov	 ecx, DWORD PTR _pColor$[ebp]
  00e3c	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e3e	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  00e44	33 c0		 xor	 eax, eax
  00e46	3b 55 08	 cmp	 edx, DWORD PTR _color$[ebp]
  00e49	0f 95 c0	 setne	 al
  00e4c	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR $T187837[ebp], 1
  00e53	88 85 6a ff ff
	ff		 mov	 BYTE PTR _ismask$[ebp], al

; 264  : 				break;

  00e59	eb 1a		 jmp	 SHORT $L187213
$L187222:

; 265  : 			case 32:
; 266  : 				ismask = (*(LPDWORD)pColor != color);

  00e5b	8b 4d 80	 mov	 ecx, DWORD PTR _pColor$[ebp]
  00e5e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e60	33 c0		 xor	 eax, eax
  00e62	3b 55 08	 cmp	 edx, DWORD PTR _color$[ebp]
  00e65	0f 95 c0	 setne	 al
  00e68	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR $T187837[ebp], 1
  00e6f	88 85 6a ff ff
	ff		 mov	 BYTE PTR _ismask$[ebp], al
$L187213:

; 267  : 			}
; 268  : 			// shift pointer to next color
; 269  : 			pColor += Bpp;

  00e75	0f b6 4d 8b	 movzx	 ecx, BYTE PTR _Bpp$[ebp]
  00e79	03 4d 80	 add	 ecx, DWORD PTR _pColor$[ebp]
  00e7c	89 4d 80	 mov	 DWORD PTR _pColor$[ebp], ecx

; 270  : 			// place part of scan line as RECT region if transparent color found after mask color or
; 271  : 			// mask color found at the end of mask image
; 272  : 			if ( wasfirst )

  00e7f	0f b6 95 6b ff
	ff ff		 movzx	 edx, BYTE PTR _wasfirst$[ebp]
  00e86	85 d2		 test	 edx, edx
  00e88	0f 84 3c 01 00
	00		 je	 $L187224

; 273  : 			{
; 274  : 				if ( !ismask )

  00e8e	80 bd fb fe ff
	ff 00		 cmp	 BYTE PTR $T187837[ebp], 0
  00e95	75 0d		 jne	 SHORT $L187838
  00e97	68 00 00 00 00	 push	 OFFSET FLAT:$L187839
  00e9c	e8 00 00 00 00	 call	 __RTC_UninitUse
  00ea1	83 c4 04	 add	 esp, 4
$L187838:
  00ea4	0f b6 85 6a ff
	ff ff		 movzx	 eax, BYTE PTR _ismask$[ebp]
  00eab	85 c0		 test	 eax, eax
  00ead	0f 85 15 01 00
	00		 jne	 $L187225

; 275  : 				{
; 276  : 					// save current RECT
; 277  : 					pRects[ pRgnData->nCount++ ] = CRect( first, i, j, i + 1 );

  00eb3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _i$[ebp]
  00eb9	83 c1 01	 add	 ecx, 1
  00ebc	51		 push	 ecx
  00ebd	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _j$[ebp]
  00ec3	52		 push	 edx
  00ec4	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00eca	50		 push	 eax
  00ecb	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _first$[ebp]
  00ed1	51		 push	 ecx
  00ed2	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T187828[ebp]
  00ed8	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  00edd	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00ee3	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00ee6	c1 e1 04	 shl	 ecx, 4
  00ee9	03 8d 60 ff ff
	ff		 add	 ecx, DWORD PTR _pRects$[ebp]
  00eef	8b 10		 mov	 edx, DWORD PTR [eax]
  00ef1	89 11		 mov	 DWORD PTR [ecx], edx
  00ef3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00ef6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00ef9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00efc	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00eff	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00f02	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00f05	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00f0b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00f0e	83 c2 01	 add	 edx, 1
  00f11	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00f17	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 278  : 					// if buffer full reallocate it with more room
; 279  : 					if ( pRgnData->nCount >= dwRectsCount )

  00f1a	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00f20	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00f23	3b 95 78 ff ff
	ff		 cmp	 edx, DWORD PTR _dwRectsCount$[ebp]
  00f29	0f 82 92 00 00
	00		 jb	 $L187227

; 280  : 					{
; 281  : 						dwRectsCount += ADD_RECTS_COUNT;

  00f2f	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _dwRectsCount$[ebp]
  00f35	83 c0 28	 add	 eax, 40			; 00000028H
  00f38	89 85 78 ff ff
	ff		 mov	 DWORD PTR _dwRectsCount$[ebp], eax

; 282  : 						// allocate new buffer
; 283  : 						LPBYTE pRgnDataNew = new BYTE[ RGNDATAHEADER_SIZE + dwRectsCount * sizeof(RECT) ];

  00f3e	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _dwRectsCount$[ebp]
  00f44	c1 e1 04	 shl	 ecx, 4
  00f47	83 c1 20	 add	 ecx, 32			; 00000020H
  00f4a	51		 push	 ecx
  00f4b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00f50	83 c4 04	 add	 esp, 4
  00f53	89 85 24 ff ff
	ff		 mov	 DWORD PTR $T187829[ebp], eax
  00f59	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR $T187829[ebp]
  00f5f	89 95 58 ff ff
	ff		 mov	 DWORD PTR _pRgnDataNew$187228[ebp], edx

; 284  : 						// copy current region data to it
; 285  : 						memcpy( pRgnDataNew, pRgnData, RGNDATAHEADER_SIZE + pRgnData->nCount * sizeof(RECT) );

  00f65	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnData$[ebp]
  00f6b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00f6e	c1 e1 04	 shl	 ecx, 4
  00f71	83 c1 20	 add	 ecx, 32			; 00000020H
  00f74	51		 push	 ecx
  00f75	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _pRgnData$[ebp]
  00f7b	52		 push	 edx
  00f7c	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnDataNew$187228[ebp]
  00f82	50		 push	 eax
  00f83	e8 00 00 00 00	 call	 _memcpy
  00f88	83 c4 0c	 add	 esp, 12			; 0000000cH

; 286  : 						// delte old region data buffer
; 287  : 						delete []pRgnData;

  00f8b	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00f91	89 8d 20 ff ff
	ff		 mov	 DWORD PTR $T187830[ebp], ecx
  00f97	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR $T187830[ebp]
  00f9d	52		 push	 edx
  00f9e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00fa3	83 c4 04	 add	 esp, 4

; 288  : 						// set pointer to new regiondata buffer to current
; 289  : 						pRgnData = (RGNDATAHEADER*)pRgnDataNew;

  00fa6	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnDataNew$187228[ebp]
  00fac	89 85 64 ff ff
	ff		 mov	 DWORD PTR _pRgnData$[ebp], eax

; 290  : 						// correct pointer to RECT table
; 291  : 						pRects = (LPRECT)((LPBYTE)pRgnData + RGNDATAHEADER_SIZE);

  00fb2	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  00fb8	83 c1 20	 add	 ecx, 32			; 00000020H
  00fbb	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _pRects$[ebp], ecx
$L187227:

; 292  : 					}
; 293  : 					wasfirst = false;

  00fc1	c6 85 6b ff ff
	ff 00		 mov	 BYTE PTR _wasfirst$[ebp], 0
$L187225:

; 294  : 				}
; 295  : 			}
; 296  : 			else if ( ismask )		// set wasfirst when mask is found

  00fc8	eb 34		 jmp	 SHORT $L187237
$L187224:
  00fca	80 bd fb fe ff
	ff 00		 cmp	 BYTE PTR $T187837[ebp], 0
  00fd1	75 0d		 jne	 SHORT $L187841
  00fd3	68 00 00 00 00	 push	 OFFSET FLAT:$L187839
  00fd8	e8 00 00 00 00	 call	 __RTC_UninitUse
  00fdd	83 c4 04	 add	 esp, 4
$L187841:
  00fe0	0f b6 95 6a ff
	ff ff		 movzx	 edx, BYTE PTR _ismask$[ebp]
  00fe7	85 d2		 test	 edx, edx
  00fe9	74 13		 je	 SHORT $L187237

; 297  : 			{
; 298  : 				first = j;

  00feb	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _j$[ebp]
  00ff1	89 85 6c ff ff
	ff		 mov	 DWORD PTR _first$[ebp], eax

; 299  : 				wasfirst = true;

  00ff7	c6 85 6b ff ff
	ff 01		 mov	 BYTE PTR _wasfirst$[ebp], 1
$L187237:

; 300  : 			}
; 301  : 		}

  00ffe	e9 95 fd ff ff	 jmp	 $L187210
$L187211:

; 302  : 
; 303  : 		if ( wasfirst && ismask )

  01003	0f b6 8d 6b ff
	ff ff		 movzx	 ecx, BYTE PTR _wasfirst$[ebp]
  0100a	85 c9		 test	 ecx, ecx
  0100c	0f 84 3a 01 00
	00		 je	 $L187239
  01012	80 bd fb fe ff
	ff 00		 cmp	 BYTE PTR $T187837[ebp], 0
  01019	75 0d		 jne	 SHORT $L187842
  0101b	68 00 00 00 00	 push	 OFFSET FLAT:$L187839
  01020	e8 00 00 00 00	 call	 __RTC_UninitUse
  01025	83 c4 04	 add	 esp, 4
$L187842:
  01028	0f b6 95 6a ff
	ff ff		 movzx	 edx, BYTE PTR _ismask$[ebp]
  0102f	85 d2		 test	 edx, edx
  01031	0f 84 15 01 00
	00		 je	 $L187239

; 304  : 		{
; 305  : 			// save current RECT
; 306  : 			pRects[ pRgnData->nCount++ ] = CRect( first, i, j, i + 1 );

  01037	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  0103d	83 c0 01	 add	 eax, 1
  01040	50		 push	 eax
  01041	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _j$[ebp]
  01047	51		 push	 ecx
  01048	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _i$[ebp]
  0104e	52		 push	 edx
  0104f	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _first$[ebp]
  01055	50		 push	 eax
  01056	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T187831[ebp]
  0105c	e8 00 00 00 00	 call	 ??0CRect@@QAE@HHHH@Z	; CRect::CRect
  01061	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  01067	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0106a	c1 e2 04	 shl	 edx, 4
  0106d	03 95 60 ff ff
	ff		 add	 edx, DWORD PTR _pRects$[ebp]
  01073	8b 08		 mov	 ecx, DWORD PTR [eax]
  01075	89 0a		 mov	 DWORD PTR [edx], ecx
  01077	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0107a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0107d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01080	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  01083	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  01086	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  01089	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  0108f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01092	83 c2 01	 add	 edx, 1
  01095	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnData$[ebp]
  0109b	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 307  : 			// if buffer full reallocate it with more room
; 308  : 			if ( pRgnData->nCount >= dwRectsCount )

  0109e	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  010a4	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  010a7	3b 95 78 ff ff
	ff		 cmp	 edx, DWORD PTR _dwRectsCount$[ebp]
  010ad	0f 82 92 00 00
	00		 jb	 $L187241

; 309  : 			{
; 310  : 				dwRectsCount += ADD_RECTS_COUNT;

  010b3	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _dwRectsCount$[ebp]
  010b9	83 c0 28	 add	 eax, 40			; 00000028H
  010bc	89 85 78 ff ff
	ff		 mov	 DWORD PTR _dwRectsCount$[ebp], eax

; 311  : 				// allocate new buffer
; 312  : 				LPBYTE pRgnDataNew = new BYTE[ RGNDATAHEADER_SIZE + dwRectsCount * sizeof(RECT) ];

  010c2	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _dwRectsCount$[ebp]
  010c8	c1 e1 04	 shl	 ecx, 4
  010cb	83 c1 20	 add	 ecx, 32			; 00000020H
  010ce	51		 push	 ecx
  010cf	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  010d4	83 c4 04	 add	 esp, 4
  010d7	89 85 0c ff ff
	ff		 mov	 DWORD PTR $T187832[ebp], eax
  010dd	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR $T187832[ebp]
  010e3	89 95 54 ff ff
	ff		 mov	 DWORD PTR _pRgnDataNew$187242[ebp], edx

; 313  : 				// copy current region data to it
; 314  : 				memcpy( pRgnDataNew, pRgnData, RGNDATAHEADER_SIZE + pRgnData->nCount * sizeof(RECT) );

  010e9	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnData$[ebp]
  010ef	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  010f2	c1 e1 04	 shl	 ecx, 4
  010f5	83 c1 20	 add	 ecx, 32			; 00000020H
  010f8	51		 push	 ecx
  010f9	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _pRgnData$[ebp]
  010ff	52		 push	 edx
  01100	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnDataNew$187242[ebp]
  01106	50		 push	 eax
  01107	e8 00 00 00 00	 call	 _memcpy
  0110c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 315  : 				// delte old region data buffer
; 316  : 				delete []pRgnData;

  0110f	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  01115	89 8d 08 ff ff
	ff		 mov	 DWORD PTR $T187833[ebp], ecx
  0111b	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR $T187833[ebp]
  01121	52		 push	 edx
  01122	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  01127	83 c4 04	 add	 esp, 4

; 317  : 				// set pointer to new regiondata buffer to current
; 318  : 				pRgnData = (RGNDATAHEADER*)pRgnDataNew;

  0112a	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnDataNew$187242[ebp]
  01130	89 85 64 ff ff
	ff		 mov	 DWORD PTR _pRgnData$[ebp], eax

; 319  : 				// correct pointer to RECT table
; 320  : 				pRects = (LPRECT)((LPBYTE)pRgnData + RGNDATAHEADER_SIZE);

  01136	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pRgnData$[ebp]
  0113c	83 c1 20	 add	 ecx, 32			; 00000020H
  0113f	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _pRects$[ebp], ecx
$L187241:

; 321  : 			}
; 322  : 			wasfirst = false;

  01145	c6 85 6b ff ff
	ff 00		 mov	 BYTE PTR _wasfirst$[ebp], 0
$L187239:

; 323  : 		}
; 324  : 
; 325  : 
; 326  : 		if(pColor - dwLineBackLen >= pBits)

  0114c	8b 55 80	 mov	 edx, DWORD PTR _pColor$[ebp]
  0114f	2b 95 7c ff ff
	ff		 sub	 edx, DWORD PTR _dwLineBackLen$[ebp]
  01155	3b 55 c8	 cmp	 edx, DWORD PTR _pBits$[ebp]
  01158	72 0c		 jb	 SHORT $L187251

; 327  : 			pColor -= dwLineBackLen;

  0115a	8b 45 80	 mov	 eax, DWORD PTR _pColor$[ebp]
  0115d	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _dwLineBackLen$[ebp]
  01163	89 45 80	 mov	 DWORD PTR _pColor$[ebp], eax
$L187251:

; 328  : 	}

  01166	e9 ed fb ff ff	 jmp	 $L187205
$L187206:

; 329  : 
; 330  : 	for(int i = 0 ; i<(int)pRgnData->nCount; i++)

  0116b	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$187252[ebp], 0
  01175	eb 0f		 jmp	 SHORT $L187254
$L187255:
  01177	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _i$187252[ebp]
  0117d	83 c1 01	 add	 ecx, 1
  01180	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _i$187252[ebp], ecx
$L187254:
  01186	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _pRgnData$[ebp]
  0118c	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _i$187252[ebp]
  01192	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  01195	7d 02		 jge	 SHORT $L187256

; 331  : 	{
; 332  : 	//	TRACE("\n count:%2d, [%2d, %2d, %2d,%2d]", i, pRects[i].left,  pRects[i].right,  pRects[i].top,  pRects[i].bottom);
; 333  : 	}

  01197	eb de		 jmp	 SHORT $L187255
$L187256:

; 334  : 	// release image data
; 335  : 	delete []pBits;

  01199	8b 4d c8	 mov	 ecx, DWORD PTR _pBits$[ebp]
  0119c	89 8d 04 ff ff
	ff		 mov	 DWORD PTR $T187834[ebp], ecx
  011a2	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR $T187834[ebp]
  011a8	52		 push	 edx
  011a9	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  011ae	83 c4 04	 add	 esp, 4

; 336  : 	delete []bi;

  011b1	8b 45 d4	 mov	 eax, DWORD PTR _bi$[ebp]
  011b4	89 85 00 ff ff
	ff		 mov	 DWORD PTR $T187835[ebp], eax
  011ba	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR $T187835[ebp]
  011c0	51		 push	 ecx
  011c1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  011c6	83 c4 04	 add	 esp, 4

; 337  : 
; 338  : 	// create region
; 339  : 	HRGN hRgn = ExtCreateRegion( NULL, RGNDATAHEADER_SIZE + pRgnData->nCount * sizeof(RECT), (LPRGNDATA)pRgnData );

  011c9	8b f4		 mov	 esi, esp
  011cb	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _pRgnData$[ebp]
  011d1	52		 push	 edx
  011d2	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _pRgnData$[ebp]
  011d8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  011db	c1 e1 04	 shl	 ecx, 4
  011de	83 c1 20	 add	 ecx, 32			; 00000020H
  011e1	51		 push	 ecx
  011e2	6a 00		 push	 0
  011e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExtCreateRegion@12
  011ea	3b f4		 cmp	 esi, esp
  011ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  011f1	89 85 4c ff ff
	ff		 mov	 DWORD PTR _hRgn$[ebp], eax

; 340  : 	// release region data
; 341  : 	delete []pRgnData;

  011f7	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _pRgnData$[ebp]
  011fd	89 95 fc fe ff
	ff		 mov	 DWORD PTR $T187836[ebp], edx
  01203	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T187836[ebp]
  01209	50		 push	 eax
  0120a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0120f	83 c4 04	 add	 esp, 4

; 342  : 	return hRgn;

  01212	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _hRgn$[ebp]
$L187143:

; 343  : }

  01218	52		 push	 edx
  01219	8b cd		 mov	 ecx, ebp
  0121b	50		 push	 eax
  0121c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L187847
  01222	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  01227	58		 pop	 eax
  01228	5a		 pop	 edx
  01229	5f		 pop	 edi
  0122a	5e		 pop	 esi
  0122b	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  01231	3b ec		 cmp	 ebp, esp
  01233	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01238	8b e5		 mov	 esp, ebp
  0123a	5d		 pop	 ebp
  0123b	c2 08 00	 ret	 8
$L187847:
  0123e	02 00 00 00	 DD	 2
  01242	00 00 00 00	 DD	 $L187846
$L187846:
  01246	dc ff ff ff	 DD	 -36			; ffffffdcH
  0124a	18 00 00 00	 DD	 24			; 00000018H
  0124e	00 00 00 00	 DD	 $L187844
  01252	a0 ff ff ff	 DD	 -96			; ffffffa0H
  01256	18 00 00 00	 DD	 24			; 00000018H
  0125a	00 00 00 00	 DD	 $L187845
$L187845:
  0125e	62		 DB	 98			; 00000062H
  0125f	6d		 DB	 109			; 0000006dH
  01260	00		 DB	 0
$L187844:
  01261	62		 DB	 98			; 00000062H
  01262	6d		 DB	 109			; 0000006dH
  01263	70		 DB	 112			; 00000070H
  01264	00		 DB	 0
$L187839:
  01265	69		 DB	 105			; 00000069H
  01266	73		 DB	 115			; 00000073H
  01267	6d		 DB	 109			; 0000006dH
  01268	61		 DB	 97			; 00000061H
  01269	73		 DB	 115			; 00000073H
  0126a	6b		 DB	 107			; 0000006bH
  0126b	00		 DB	 0
$L187848:
  0126c	00 00 00 00	 DD	 $L187216
  01270	00 00 00 00	 DD	 $L187217
  01274	00 00 00 00	 DD	 $L187220
  01278	00 00 00 00	 DD	 $L187222
  0127c	00 00 00 00	 DD	 $L187213
$L187843:
  01280	00		 DB	 0
  01281	04		 DB	 4
  01282	04		 DB	 4
  01283	04		 DB	 4
  01284	04		 DB	 4
  01285	04		 DB	 4
  01286	04		 DB	 4
  01287	04		 DB	 4
  01288	01		 DB	 1
  01289	04		 DB	 4
  0128a	04		 DB	 4
  0128b	04		 DB	 4
  0128c	04		 DB	 4
  0128d	04		 DB	 4
  0128e	04		 DB	 4
  0128f	04		 DB	 4
  01290	02		 DB	 2
  01291	04		 DB	 4
  01292	04		 DB	 4
  01293	04		 DB	 4
  01294	04		 DB	 4
  01295	04		 DB	 4
  01296	04		 DB	 4
  01297	04		 DB	 4
  01298	03		 DB	 3
?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCDC@@@Z ENDP ; CDibBitmap::CreateRgnFromBitmap
_TEXT	ENDS
PUBLIC	?GetWidth@CDibBitmap@@QAEHXZ			; CDibBitmap::GetWidth
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWidth@CDibBitmap@@QAEHXZ PROC NEAR			; CDibBitmap::GetWidth
; _this$ = ecx

; 448  : {

  012a0	55		 push	 ebp
  012a1	8b ec		 mov	 ebp, esp
  012a3	51		 push	 ecx
  012a4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  012ab	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 449  : 	if(!ValidCheck())

  012ae	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012b1	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  012b6	85 c0		 test	 eax, eax
  012b8	75 04		 jne	 SHORT $L187266

; 450  : 		return 0;

  012ba	33 c0		 xor	 eax, eax
  012bc	eb 09		 jmp	 SHORT $L187265
$L187266:

; 451  : 	return this->m_lpBMIH->biWidth;

  012be	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  012c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  012c4	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
$L187265:

; 452  : }

  012c7	83 c4 04	 add	 esp, 4
  012ca	3b ec		 cmp	 ebp, esp
  012cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  012d1	8b e5		 mov	 esp, ebp
  012d3	5d		 pop	 ebp
  012d4	c3		 ret	 0
?GetWidth@CDibBitmap@@QAEHXZ ENDP			; CDibBitmap::GetWidth
_TEXT	ENDS
PUBLIC	?GetHeight@CDibBitmap@@QAEHXZ			; CDibBitmap::GetHeight
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHeight@CDibBitmap@@QAEHXZ PROC NEAR			; CDibBitmap::GetHeight
; _this$ = ecx

; 454  : {

  012e0	55		 push	 ebp
  012e1	8b ec		 mov	 ebp, esp
  012e3	51		 push	 ecx
  012e4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  012eb	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 455  : 	if(!ValidCheck())

  012ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  012f1	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  012f6	85 c0		 test	 eax, eax
  012f8	75 04		 jne	 SHORT $L187270

; 456  : 		return 0;

  012fa	33 c0		 xor	 eax, eax
  012fc	eb 09		 jmp	 SHORT $L187269
$L187270:

; 457  : 	return this->m_lpBMIH->biHeight;

  012fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01301	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01304	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
$L187269:

; 458  : }

  01307	83 c4 04	 add	 esp, 4
  0130a	3b ec		 cmp	 ebp, esp
  0130c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01311	8b e5		 mov	 esp, ebp
  01313	5d		 pop	 ebp
  01314	c3		 ret	 0
?GetHeight@CDibBitmap@@QAEHXZ ENDP			; CDibBitmap::GetHeight
_TEXT	ENDS
PUBLIC	?GetPath@CDibBitmap@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CDibBitmap::GetPath
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T187853 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetPath@CDibBitmap@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; CDibBitmap::GetPath
; _this$ = ecx

; 460  : {

  01320	55		 push	 ebp
  01321	8b ec		 mov	 ebp, esp
  01323	83 ec 08	 sub	 esp, 8
  01326	56		 push	 esi
  01327	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0132e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  01335	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  01338	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T187853[ebp], 0

; 461  : 	return m_path;

  0133f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  01342	83 c0 38	 add	 eax, 56			; 00000038H
  01345	8b f4		 mov	 esi, esp
  01347	50		 push	 eax
  01348	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0134b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  01351	3b f4		 cmp	 esi, esp
  01353	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01358	8b 4d f8	 mov	 ecx, DWORD PTR $T187853[ebp]
  0135b	83 c9 01	 or	 ecx, 1
  0135e	89 4d f8	 mov	 DWORD PTR $T187853[ebp], ecx
  01361	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 462  : }

  01364	5e		 pop	 esi
  01365	83 c4 08	 add	 esp, 8
  01368	3b ec		 cmp	 ebp, esp
  0136a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0136f	8b e5		 mov	 esp, ebp
  01371	5d		 pop	 ebp
  01372	c2 04 00	 ret	 4
?GetPath@CDibBitmap@@QAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; CDibBitmap::GetPath
_TEXT	ENDS
PUBLIC	?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCWnd@@@Z ; CDibBitmap::CreateRgnFromBitmap
EXTRN	?GetDC@CWnd@@QAEPAVCDC@@XZ:NEAR			; CWnd::GetDC
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_color$ = 8						; size = 4
_pWnd$ = 12						; size = 4
?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCWnd@@@Z PROC NEAR ; CDibBitmap::CreateRgnFromBitmap
; _this$ = ecx

; 468  : {

  01380	55		 push	 ebp
  01381	8b ec		 mov	 ebp, esp
  01383	51		 push	 ecx
  01384	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0138b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 469  : 	return CreateRgnFromBitmap(color,pWnd->GetDC());

  0138e	8b 4d 0c	 mov	 ecx, DWORD PTR _pWnd$[ebp]
  01391	e8 00 00 00 00	 call	 ?GetDC@CWnd@@QAEPAVCDC@@XZ ; CWnd::GetDC
  01396	50		 push	 eax
  01397	8b 45 08	 mov	 eax, DWORD PTR _color$[ebp]
  0139a	50		 push	 eax
  0139b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0139e	e8 00 00 00 00	 call	 ?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCDC@@@Z ; CDibBitmap::CreateRgnFromBitmap

; 470  : }

  013a3	83 c4 04	 add	 esp, 4
  013a6	3b ec		 cmp	 ebp, esp
  013a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  013ad	8b e5		 mov	 esp, ebp
  013af	5d		 pop	 ebp
  013b0	c2 08 00	 ret	 8
?CreateRgnFromBitmap@CDibBitmap@@QAEPAUHRGN__@@KPAVCWnd@@@Z ENDP ; CDibBitmap::CreateRgnFromBitmap
_TEXT	ENDS
EXTRN	?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z:NEAR ; CDib::CreateBitmap
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pDC$ = 8						; size = 4
?CreateBitmap@CDibBitmap@@QAEPAUHBITMAP__@@PAVCDC@@@Z PROC NEAR ; CDibBitmap::CreateBitmap
; _this$ = ecx

; 473  : {

  013c0	55		 push	 ebp
  013c1	8b ec		 mov	 ebp, esp
  013c3	51		 push	 ecx
  013c4	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  013cb	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 474  : 	if(!ValidCheck())

  013ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013d1	e8 00 00 00 00	 call	 ?ValidCheck@CDibBitmap@@QAEHXZ ; CDibBitmap::ValidCheck
  013d6	85 c0		 test	 eax, eax
  013d8	75 04		 jne	 SHORT $L187284

; 475  : 		return NULL;

  013da	33 c0		 xor	 eax, eax
  013dc	eb 0c		 jmp	 SHORT $L187283
$L187284:

; 476  : 	return __super::CreateBitmap(pDC);

  013de	8b 45 08	 mov	 eax, DWORD PTR _pDC$[ebp]
  013e1	50		 push	 eax
  013e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  013e5	e8 00 00 00 00	 call	 ?CreateBitmap@CDib@@IAEPAUHBITMAP__@@PAVCDC@@@Z ; CDib::CreateBitmap
$L187283:

; 477  : }

  013ea	83 c4 04	 add	 esp, 4
  013ed	3b ec		 cmp	 ebp, esp
  013ef	e8 00 00 00 00	 call	 __RTC_CheckEsp
  013f4	8b e5		 mov	 esp, ebp
  013f6	5d		 pop	 ebp
  013f7	c2 04 00	 ret	 4
?CreateBitmap@CDibBitmap@@QAEPAUHBITMAP__@@PAVCDC@@@Z ENDP ; CDibBitmap::CreateBitmap
_TEXT	ENDS
END
