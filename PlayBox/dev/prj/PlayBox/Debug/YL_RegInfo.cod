; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\boxgit\PlayBox\CommonLib\common\YL_RegInfo.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EM@KKHJFHNK@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_DebugHeapString@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@_W@std@@YAD_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@_WDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0IPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVdomain_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVrange_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@codecvt_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@_WDH@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@A@?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4underflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4overflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVunderflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4domain_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_exception@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4invalid_argument@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$codecvt@_WDH@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4range_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_exception@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$codecvt@_WDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R2invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@_WDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVoverflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
CONST	SEGMENT
$SG65087 DB	00H
	ORG $+3
$SG65102 DB	'\', 00H
$SG65131 DB	00H
CONST	ENDS
PUBLIC	?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_RegInfo::CreateKey
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:NEAR
EXTRN	__imp__RegCloseKey@4:NEAR
EXTRN	__imp__RegCreateKeyExA@36:NEAR
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	@_RTC_CheckStackVars@8:NEAR
;	COMDAT rtc$IMZ
; File d:\boxgit\playbox\commonlib\common\yl_reginfo.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
_TEXT	SEGMENT
_err$ = -16						; size = 4
_hKey$ = -8						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; YL_RegInfo::CreateKey

; 4    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000d	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00010	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00013	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00016	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 5    : 	HKEY hKey; 		
; 6    : 	LONG err;
; 7    : 	err = RegCreateKeyEx(hRegKey, strRegEntry.c_str(), 0L, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,&hKey, NULL );

  00019	8b f4		 mov	 esi, esp
  0001b	6a 00		 push	 0
  0001d	8d 45 f8	 lea	 eax, DWORD PTR _hKey$[ebp]
  00020	50		 push	 eax
  00021	6a 00		 push	 0
  00023	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00028	6a 00		 push	 0
  0002a	6a 00		 push	 0
  0002c	6a 00		 push	 0
  0002e	8b fc		 mov	 edi, esp
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00039	3b fc		 cmp	 edi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00044	51		 push	 ecx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExA@36
  0004b	3b f4		 cmp	 esi, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 8    : 
; 9    : 	if( err == ERROR_SUCCESS )

  00055	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  00059	75 1b		 jne	 SHORT $L65072

; 10   : 	{
; 11   : 		if( RegCloseKey( hKey ) == ERROR_SUCCESS )

  0005b	8b f4		 mov	 esi, esp
  0005d	8b 55 f8	 mov	 edx, DWORD PTR _hKey$[ebp]
  00060	52		 push	 edx
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	85 c0		 test	 eax, eax
  00070	75 04		 jne	 SHORT $L65072

; 12   : 		{
; 13   : 			return true;

  00072	b0 01		 mov	 al, 1
  00074	eb 02		 jmp	 SHORT $L65069
$L65072:

; 14   : 		}
; 15   : 	}
; 16   : 		
; 17   : 	return false;		

  00076	32 c0		 xor	 al, al
$L65069:

; 18   : }

  00078	52		 push	 edx
  00079	8b cd		 mov	 ecx, ebp
  0007b	50		 push	 eax
  0007c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69404
  00082	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00087	58		 pop	 eax
  00088	5a		 pop	 edx
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$L69404:
  00099	01 00 00 00	 DD	 1
  0009d	00 00 00 00	 DD	 $L69403
$L69403:
  000a1	f8 ff ff ff	 DD	 -8			; fffffff8H
  000a5	04 00 00 00	 DD	 4
  000a9	00 00 00 00	 DD	 $L69402
$L69402:
  000ad	68		 DB	 104			; 00000068H
  000ae	4b		 DB	 75			; 0000004bH
  000af	65		 DB	 101			; 00000065H
  000b0	79		 DB	 121			; 00000079H
  000b1	00		 DB	 0
?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; YL_RegInfo::CreateKey
_TEXT	ENDS
PUBLIC	?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z	; YL_RegInfo::CreateKey
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
xdata$x	SEGMENT
$T69416	DD	0ffffffffH
	DD	FLAT:$L69409
$T69413	DD	019930520H
	DD	01H
	DD	FLAT:$T69416
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv74 = -52						; size = 4
tv75 = -48						; size = 4
$T69408 = -44						; size = 28
$T69407 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z PROC NEAR	; YL_RegInfo::CreateKey

; 21   : {

  000c0	55		 push	 ebp
  000c1	8b ec		 mov	 ebp, esp
  000c3	6a ff		 push	 -1
  000c5	68 00 00 00 00	 push	 __ehhandler$?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z
  000ca	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  000d0	50		 push	 eax
  000d1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  000d8	83 ec 28	 sub	 esp, 40			; 00000028H
  000db	56		 push	 esi
  000dc	57		 push	 edi
  000dd	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  000e0	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000e5	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  000ea	f3 ab		 rep stosd

; 22   : 	if( pszRegEntry == NULL )

  000ec	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  000f0	75 04		 jne	 SHORT $L65078

; 23   : 	{
; 24   : 		return false;

  000f2	32 c0		 xor	 al, al
  000f4	eb 55		 jmp	 SHORT $L65077
$L65078:

; 25   : 	}
; 26   : 	return CreateKey( hRegKey,string(pszRegEntry) );

  000f6	8b f4		 mov	 esi, esp
  000f8	8b 45 0c	 mov	 eax, DWORD PTR _pszRegEntry$[ebp]
  000fb	50		 push	 eax
  000fc	8d 4d d4	 lea	 ecx, DWORD PTR $T69408[ebp]
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00105	3b f4		 cmp	 esi, esp
  00107	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010c	89 45 d0	 mov	 DWORD PTR tv75[ebp], eax
  0010f	8b 4d d0	 mov	 ecx, DWORD PTR tv75[ebp]
  00112	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  00115	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0011c	8b 55 cc	 mov	 edx, DWORD PTR tv74[ebp]
  0011f	52		 push	 edx
  00120	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_RegInfo::CreateKey
  00129	83 c4 08	 add	 esp, 8
  0012c	88 45 f3	 mov	 BYTE PTR $T69407[ebp], al
  0012f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00136	8b f4		 mov	 esi, esp
  00138	8d 4d d4	 lea	 ecx, DWORD PTR $T69408[ebp]
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00141	3b f4		 cmp	 esi, esp
  00143	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00148	8a 45 f3	 mov	 al, BYTE PTR $T69407[ebp]
$L65077:

; 27   : }

  0014b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	83 c4 34	 add	 esp, 52			; 00000034H
  0015a	3b ec		 cmp	 ebp, esp
  0015c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L69409:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d4	 lea	 ecx, DWORD PTR $T69408[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69413
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD@Z ENDP	; YL_RegInfo::CreateKey
PUBLIC	?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteKey
PUBLIC	?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z	; YL_RegInfo::DeleteKey
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z:NEAR
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:NEAR
EXTRN	__imp__RegDeleteKeyA@8:NEAR
EXTRN	__imp__RegDeleteValueA@8:NEAR
EXTRN	__imp__RegEnumKeyExA@32:NEAR
EXTRN	__imp__RegOpenKeyExA@20:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
xdata$x	SEGMENT
$T69442	DD	0ffffffffH
	DD	FLAT:$L69425
	DD	00H
	DD	FLAT:$L69426
$T69428	DD	019930520H
	DD	02H
	DD	FLAT:$T69442
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T69424 = -421						; size = 1
$T69423 = -420						; size = 1
$T69422 = -419						; size = 1
$T69421 = -418						; size = 1
$T69420 = -417						; size = 1
_err$65114 = -416					; size = 4
_hKey$65113 = -408					; size = 4
_strTmp$65107 = -396					; size = 28
_strSubKey$65093 = -360					; size = 28
_ftWrite$65092 = -324					; size = 8
_hKey$65091 = -308					; size = 4
_szName$65090 = -296					; size = 260
_dwSize$65089 = -28					; size = 4
_lResult$65088 = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z PROC NEAR ; YL_RegInfo::DeleteKey

; 30   : {		

  00170	55		 push	 ebp
  00171	8b ec		 mov	 ebp, esp
  00173	6a ff		 push	 -1
  00175	68 00 00 00 00	 push	 __ehhandler$?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z
  0017a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00180	50		 push	 eax
  00181	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00188	81 ec 9c 01 00
	00		 sub	 esp, 412		; 0000019cH
  0018e	56		 push	 esi
  0018f	57		 push	 edi
  00190	8d bd 58 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-424]
  00196	b9 67 00 00 00	 mov	 ecx, 103		; 00000067H
  0019b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  001a0	f3 ab		 rep stosd
  001a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  001a7	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 31   : 	if( strKeyName == "" )

  001aa	8b f4		 mov	 esi, esp
  001ac	68 00 00 00 00	 push	 OFFSET FLAT:$SG65087
  001b1	8b 45 10	 mov	 eax, DWORD PTR _strKeyName$[ebp]
  001b4	50		 push	 eax
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  001bb	83 c4 08	 add	 esp, 8
  001be	3b f4		 cmp	 esi, esp
  001c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c5	0f b6 c8	 movzx	 ecx, al
  001c8	85 c9		 test	 ecx, ecx
  001ca	0f 84 36 03 00
	00		 je	 $L65086

; 32   : 	{
; 33   : 		LONG lResult;
; 34   : 		DWORD dwSize;
; 35   : 		TCHAR szName[MAX_PATH];
; 36   : 		HKEY hKey;
; 37   : 		FILETIME ftWrite;
; 38   : 		
; 39   : 		string strSubKey = strRegEntry;

  001d0	8b f4		 mov	 esi, esp
  001d2	8b 55 0c	 mov	 edx, DWORD PTR _strRegEntry$[ebp]
  001d5	52		 push	 edx
  001d6	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  001dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  001e2	3b f4		 cmp	 esi, esp
  001e4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 				
; 41   : 
; 42   : 		// First, see if we can delete the key without having
; 43   : 		// to recurse.
; 44   : 
; 45   : 		lResult = RegDeleteKey(hRegKey, strSubKey.c_str());

  001f0	8b f4		 mov	 esi, esp
  001f2	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  001fe	3b f4		 cmp	 esi, esp
  00200	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00205	8b f4		 mov	 esi, esp
  00207	50		 push	 eax
  00208	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  0020b	50		 push	 eax
  0020c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  00212	3b f4		 cmp	 esi, esp
  00214	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00219	89 45 ec	 mov	 DWORD PTR _lResult$65088[ebp], eax

; 46   : 
; 47   : 		if (lResult == ERROR_SUCCESS) 

  0021c	83 7d ec 00	 cmp	 DWORD PTR _lResult$65088[ebp], 0
  00220	75 2e		 jne	 SHORT $L65094

; 48   : 			return true;

  00222	c6 85 5f fe ff
	ff 01		 mov	 BYTE PTR $T69420[ebp], 1
  00229	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00230	8b f4		 mov	 esi, esp
  00232	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0023e	3b f4		 cmp	 esi, esp
  00240	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00245	8a 85 5f fe ff
	ff		 mov	 al, BYTE PTR $T69420[ebp]
  0024b	e9 7f 03 00 00	 jmp	 $L65085
$L65094:

; 49   : 
; 50   : 		lResult = RegOpenKeyEx (hRegKey, strSubKey.c_str(), 0, KEY_READ, &hKey);

  00250	8b f4		 mov	 esi, esp
  00252	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _hKey$65091[ebp]
  00258	51		 push	 ecx
  00259	68 19 00 02 00	 push	 131097			; 00020019H
  0025e	6a 00		 push	 0
  00260	8b fc		 mov	 edi, esp
  00262	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  00268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0026e	3b fc		 cmp	 edi, esp
  00270	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00275	50		 push	 eax
  00276	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  00279	52		 push	 edx
  0027a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00280	3b f4		 cmp	 esi, esp
  00282	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00287	89 45 ec	 mov	 DWORD PTR _lResult$65088[ebp], eax

; 51   : 
; 52   : 		if (lResult != ERROR_SUCCESS) 

  0028a	83 7d ec 00	 cmp	 DWORD PTR _lResult$65088[ebp], 0
  0028e	74 62		 je	 SHORT $L65096

; 53   : 		{
; 54   : 			if (lResult == ERROR_FILE_NOT_FOUND) 

  00290	83 7d ec 02	 cmp	 DWORD PTR _lResult$65088[ebp], 2
  00294	75 2e		 jne	 SHORT $L65097

; 55   : 			{
; 56   : 				return true;

  00296	c6 85 5e fe ff
	ff 01		 mov	 BYTE PTR $T69421[ebp], 1
  0029d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002a4	8b f4		 mov	 esi, esp
  002a6	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  002ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  002b2	3b f4		 cmp	 esi, esp
  002b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b9	8a 85 5e fe ff
	ff		 mov	 al, BYTE PTR $T69421[ebp]
  002bf	e9 0b 03 00 00	 jmp	 $L65085
$L65097:

; 57   : 			} 
; 58   : 			else 
; 59   : 			{			
; 60   : 				return false;

  002c4	c6 85 5d fe ff
	ff 00		 mov	 BYTE PTR $T69422[ebp], 0
  002cb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002d2	8b f4		 mov	 esi, esp
  002d4	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  002da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  002e0	3b f4		 cmp	 esi, esp
  002e2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e7	8a 85 5d fe ff
	ff		 mov	 al, BYTE PTR $T69422[ebp]
  002ed	e9 dd 02 00 00	 jmp	 $L65085
$L65096:

; 61   : 			}
; 62   : 		}
; 63   : 
; 64   : 		// Check for an ending slash and add one if it is missing.
; 65   : 
; 66   : 		if( strSubKey[strSubKey.length()-1] != '\\' )

  002f2	8b f4		 mov	 esi, esp
  002f4	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  002fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00300	3b f4		 cmp	 esi, esp
  00302	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00307	83 e8 01	 sub	 eax, 1
  0030a	8b f4		 mov	 esi, esp
  0030c	50		 push	 eax
  0030d	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  00313	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
  00319	3b f4		 cmp	 esi, esp
  0031b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00320	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00323	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00326	74 1a		 je	 SHORT $L65101

; 67   : 		{
; 68   : 			strSubKey += "\\";

  00328	8b f4		 mov	 esi, esp
  0032a	68 00 00 00 00	 push	 OFFSET FLAT:$SG65102
  0032f	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  0033b	3b f4		 cmp	 esi, esp
  0033d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L65101:

; 69   : 		}
; 70   : 
; 71   : 		// Enumerate the keys
; 72   : 
; 73   : 		dwSize = MAX_PATH;

  00342	c7 45 e4 04 01
	00 00		 mov	 DWORD PTR _dwSize$65089[ebp], 260 ; 00000104H

; 74   : 		lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
; 75   : 			NULL, NULL, &ftWrite);

  00349	8b f4		 mov	 esi, esp
  0034b	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _ftWrite$65092[ebp]
  00351	51		 push	 ecx
  00352	6a 00		 push	 0
  00354	6a 00		 push	 0
  00356	6a 00		 push	 0
  00358	8d 55 e4	 lea	 edx, DWORD PTR _dwSize$65089[ebp]
  0035b	52		 push	 edx
  0035c	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _szName$65090[ebp]
  00362	50		 push	 eax
  00363	6a 00		 push	 0
  00365	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _hKey$65091[ebp]
  0036b	51		 push	 ecx
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegEnumKeyExA@32
  00372	3b f4		 cmp	 esi, esp
  00374	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00379	89 45 ec	 mov	 DWORD PTR _lResult$65088[ebp], eax

; 76   : 
; 77   : 		if (lResult == ERROR_SUCCESS) 

  0037c	83 7d ec 00	 cmp	 DWORD PTR _lResult$65088[ebp], 0
  00380	0f 85 df 00 00
	00		 jne	 $L65103
$L65104:

; 78   : 		{
; 79   : 			do {
; 80   : 				
; 81   : 				string strTmp = strSubKey;

  00386	8b f4		 mov	 esi, esp
  00388	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR _strSubKey$65093[ebp]
  0038e	52		 push	 edx
  0038f	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$65107[ebp]
  00395	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0039b	3b f4		 cmp	 esi, esp
  0039d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 82   : 				strTmp += szName;

  003a6	8b f4		 mov	 esi, esp
  003a8	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _szName$65090[ebp]
  003ae	50		 push	 eax
  003af	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$65107[ebp]
  003b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  003bb	3b f4		 cmp	 esi, esp
  003bd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 83   : 
; 84   : 				if (!DeleteKey(hRegKey, strTmp.c_str()))

  003c2	6a 00		 push	 0
  003c4	8b f4		 mov	 esi, esp
  003c6	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$65107[ebp]
  003cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  003d2	3b f4		 cmp	 esi, esp
  003d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d9	50		 push	 eax
  003da	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  003dd	51		 push	 ecx
  003de	e8 00 00 00 00	 call	 ?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z ; YL_RegInfo::DeleteKey
  003e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e6	0f b6 d0	 movzx	 edx, al
  003e9	85 d2		 test	 edx, edx
  003eb	75 1b		 jne	 SHORT $L65108

; 85   : 				{
; 86   : 					break;

  003ed	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003f1	8b f4		 mov	 esi, esp
  003f3	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$65107[ebp]
  003f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  003ff	3b f4		 cmp	 esi, esp
  00401	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00406	eb 5d		 jmp	 SHORT $L65103
$L65108:

; 87   : 				}
; 88   : 
; 89   : 				dwSize = MAX_PATH;

  00408	c7 45 e4 04 01
	00 00		 mov	 DWORD PTR _dwSize$65089[ebp], 260 ; 00000104H

; 90   : 
; 91   : 				lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
; 92   : 					NULL, NULL, &ftWrite);

  0040f	8b f4		 mov	 esi, esp
  00411	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _ftWrite$65092[ebp]
  00417	50		 push	 eax
  00418	6a 00		 push	 0
  0041a	6a 00		 push	 0
  0041c	6a 00		 push	 0
  0041e	8d 4d e4	 lea	 ecx, DWORD PTR _dwSize$65089[ebp]
  00421	51		 push	 ecx
  00422	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR _szName$65090[ebp]
  00428	52		 push	 edx
  00429	6a 00		 push	 0
  0042b	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR _hKey$65091[ebp]
  00431	50		 push	 eax
  00432	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegEnumKeyExA@32
  00438	3b f4		 cmp	 esi, esp
  0043a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0043f	89 45 ec	 mov	 DWORD PTR _lResult$65088[ebp], eax

; 93   : 
; 94   : 			} while (lResult == ERROR_SUCCESS);

  00442	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00446	8b f4		 mov	 esi, esp
  00448	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$65107[ebp]
  0044e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00454	3b f4		 cmp	 esi, esp
  00456	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0045b	83 7d ec 00	 cmp	 DWORD PTR _lResult$65088[ebp], 0
  0045f	0f 84 21 ff ff
	ff		 je	 $L65104
$L65103:

; 95   : 		}
; 96   : 
; 97   : 		RegCloseKey (hKey);

  00465	8b f4		 mov	 esi, esp
  00467	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _hKey$65091[ebp]
  0046d	51		 push	 ecx
  0046e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00474	3b f4		 cmp	 esi, esp
  00476	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 98   : 
; 99   : 		// Try again to delete the key.
; 100  : 
; 101  : 		lResult = RegDeleteKey(hRegKey, strRegEntry.c_str());

  0047b	8b f4		 mov	 esi, esp
  0047d	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00480	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00486	3b f4		 cmp	 esi, esp
  00488	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0048d	8b f4		 mov	 esi, esp
  0048f	50		 push	 eax
  00490	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  00493	52		 push	 edx
  00494	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  0049a	3b f4		 cmp	 esi, esp
  0049c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004a1	89 45 ec	 mov	 DWORD PTR _lResult$65088[ebp], eax

; 102  : 
; 103  : 		if (lResult == ERROR_SUCCESS) 

  004a4	83 7d ec 00	 cmp	 DWORD PTR _lResult$65088[ebp], 0
  004a8	75 2e		 jne	 SHORT $L65109

; 104  : 			return true;

  004aa	c6 85 5c fe ff
	ff 01		 mov	 BYTE PTR $T69423[ebp], 1
  004b1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004b8	8b f4		 mov	 esi, esp
  004ba	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  004c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  004c6	3b f4		 cmp	 esi, esp
  004c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004cd	8a 85 5c fe ff
	ff		 mov	 al, BYTE PTR $T69423[ebp]
  004d3	e9 f7 00 00 00	 jmp	 $L65085
$L65109:

; 105  : 
; 106  : 		return false;

  004d8	c6 85 5b fe ff
	ff 00		 mov	 BYTE PTR $T69424[ebp], 0
  004df	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004e6	8b f4		 mov	 esi, esp
  004e8	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  004ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  004f4	3b f4		 cmp	 esi, esp
  004f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004fb	8a 85 5b fe ff
	ff		 mov	 al, BYTE PTR $T69424[ebp]
  00501	e9 c9 00 00 00	 jmp	 $L65085
$L65086:

; 107  : 	} 
; 108  : 	else
; 109  : 	{
; 110  : 		HKEY hKey; 
; 111  : 		LONG err ; 
; 112  : 		err = RegOpenKeyEx(hRegKey, strRegEntry.c_str(),0, KEY_ALL_ACCESS, &hKey);

  00506	8b f4		 mov	 esi, esp
  00508	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _hKey$65113[ebp]
  0050e	50		 push	 eax
  0050f	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00514	6a 00		 push	 0
  00516	8b fc		 mov	 edi, esp
  00518	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  0051b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00521	3b fc		 cmp	 edi, esp
  00523	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00528	50		 push	 eax
  00529	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  0052c	51		 push	 ecx
  0052d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00533	3b f4		 cmp	 esi, esp
  00535	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0053a	89 85 60 fe ff
	ff		 mov	 DWORD PTR _err$65114[ebp], eax

; 113  : 		if(err == ERROR_SUCCESS) 

  00540	83 bd 60 fe ff
	ff 00		 cmp	 DWORD PTR _err$65114[ebp], 0
  00547	75 77		 jne	 SHORT $L65115

; 114  : 		{ 
; 115  : 			err = RegDeleteValue(hKey, strKeyName.c_str()); 

  00549	8b f4		 mov	 esi, esp
  0054b	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  0054e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00554	3b f4		 cmp	 esi, esp
  00556	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0055b	8b f4		 mov	 esi, esp
  0055d	50		 push	 eax
  0055e	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR _hKey$65113[ebp]
  00564	52		 push	 edx
  00565	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8
  0056b	3b f4		 cmp	 esi, esp
  0056d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00572	89 85 60 fe ff
	ff		 mov	 DWORD PTR _err$65114[ebp], eax

; 116  : 			if( (err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS ) || (err == ERROR_FILE_NOT_FOUND ) )

  00578	83 bd 60 fe ff
	ff 00		 cmp	 DWORD PTR _err$65114[ebp], 0
  0057f	75 1a		 jne	 SHORT $L65118
  00581	8b f4		 mov	 esi, esp
  00583	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _hKey$65113[ebp]
  00589	50		 push	 eax
  0058a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00590	3b f4		 cmp	 esi, esp
  00592	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00597	85 c0		 test	 eax, eax
  00599	74 09		 je	 SHORT $L65117
$L65118:
  0059b	83 bd 60 fe ff
	ff 02		 cmp	 DWORD PTR _err$65114[ebp], 2
  005a2	75 04		 jne	 SHORT $L65116
$L65117:

; 117  : 			{
; 118  : 				return true;

  005a4	b0 01		 mov	 al, 1
  005a6	eb 27		 jmp	 SHORT $L65085
$L65116:

; 119  : 			}
; 120  : 			RegCloseKey( hKey );

  005a8	8b f4		 mov	 esi, esp
  005aa	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR _hKey$65113[ebp]
  005b0	51		 push	 ecx
  005b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  005b7	3b f4		 cmp	 esi, esp
  005b9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 121  : 		} 
; 122  : 		else if( err == ERROR_FILE_NOT_FOUND )

  005be	eb 0d		 jmp	 SHORT $L65119
$L65115:
  005c0	83 bd 60 fe ff
	ff 02		 cmp	 DWORD PTR _err$65114[ebp], 2
  005c7	75 04		 jne	 SHORT $L65119

; 123  : 		{
; 124  : 			return true;

  005c9	b0 01		 mov	 al, 1
  005cb	eb 02		 jmp	 SHORT $L65085
$L65119:

; 125  : 		}
; 126  : 
; 127  : 		return false;

  005cd	32 c0		 xor	 al, al
$L65085:

; 128  : 	}
; 129  : }

  005cf	52		 push	 edx
  005d0	8b cd		 mov	 ecx, ebp
  005d2	50		 push	 eax
  005d3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69440
  005d9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005de	58		 pop	 eax
  005df	5a		 pop	 edx
  005e0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005e3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  005ea	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f2	5f		 pop	 edi
  005f3	5e		 pop	 esi
  005f4	81 c4 a8 01 00
	00		 add	 esp, 424		; 000001a8H
  005fa	3b ec		 cmp	 ebp, esp
  005fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00601	8b e5		 mov	 esp, ebp
  00603	5d		 pop	 ebp
  00604	c3		 ret	 0
$L69440:
  00605	07 00 00 00	 DD	 7
  00609	00 00 00 00	 DD	 $L69439
$L69439:
  0060d	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00611	04 00 00 00	 DD	 4
  00615	00 00 00 00	 DD	 $L69429
  00619	d8 fe ff ff	 DD	 -296			; fffffed8H
  0061d	04 01 00 00	 DD	 260			; 00000104H
  00621	00 00 00 00	 DD	 $L69430
  00625	cc fe ff ff	 DD	 -308			; fffffeccH
  00629	04 00 00 00	 DD	 4
  0062d	00 00 00 00	 DD	 $L69431
  00631	bc fe ff ff	 DD	 -324			; fffffebcH
  00635	08 00 00 00	 DD	 8
  00639	00 00 00 00	 DD	 $L69432
  0063d	98 fe ff ff	 DD	 -360			; fffffe98H
  00641	1c 00 00 00	 DD	 28			; 0000001cH
  00645	00 00 00 00	 DD	 $L69433
  00649	74 fe ff ff	 DD	 -396			; fffffe74H
  0064d	1c 00 00 00	 DD	 28			; 0000001cH
  00651	00 00 00 00	 DD	 $L69434
  00655	68 fe ff ff	 DD	 -408			; fffffe68H
  00659	04 00 00 00	 DD	 4
  0065d	00 00 00 00	 DD	 $L69435
$L69435:
  00661	68		 DB	 104			; 00000068H
  00662	4b		 DB	 75			; 0000004bH
  00663	65		 DB	 101			; 00000065H
  00664	79		 DB	 121			; 00000079H
  00665	00		 DB	 0
$L69434:
  00666	73		 DB	 115			; 00000073H
  00667	74		 DB	 116			; 00000074H
  00668	72		 DB	 114			; 00000072H
  00669	54		 DB	 84			; 00000054H
  0066a	6d		 DB	 109			; 0000006dH
  0066b	70		 DB	 112			; 00000070H
  0066c	00		 DB	 0
$L69433:
  0066d	73		 DB	 115			; 00000073H
  0066e	74		 DB	 116			; 00000074H
  0066f	72		 DB	 114			; 00000072H
  00670	53		 DB	 83			; 00000053H
  00671	75		 DB	 117			; 00000075H
  00672	62		 DB	 98			; 00000062H
  00673	4b		 DB	 75			; 0000004bH
  00674	65		 DB	 101			; 00000065H
  00675	79		 DB	 121			; 00000079H
  00676	00		 DB	 0
$L69432:
  00677	66		 DB	 102			; 00000066H
  00678	74		 DB	 116			; 00000074H
  00679	57		 DB	 87			; 00000057H
  0067a	72		 DB	 114			; 00000072H
  0067b	69		 DB	 105			; 00000069H
  0067c	74		 DB	 116			; 00000074H
  0067d	65		 DB	 101			; 00000065H
  0067e	00		 DB	 0
$L69431:
  0067f	68		 DB	 104			; 00000068H
  00680	4b		 DB	 75			; 0000004bH
  00681	65		 DB	 101			; 00000065H
  00682	79		 DB	 121			; 00000079H
  00683	00		 DB	 0
$L69430:
  00684	73		 DB	 115			; 00000073H
  00685	7a		 DB	 122			; 0000007aH
  00686	4e		 DB	 78			; 0000004eH
  00687	61		 DB	 97			; 00000061H
  00688	6d		 DB	 109			; 0000006dH
  00689	65		 DB	 101			; 00000065H
  0068a	00		 DB	 0
$L69429:
  0068b	64		 DB	 100			; 00000064H
  0068c	77		 DB	 119			; 00000077H
  0068d	53		 DB	 83			; 00000053H
  0068e	69		 DB	 105			; 00000069H
  0068f	7a		 DB	 122			; 0000007aH
  00690	65		 DB	 101			; 00000065H
  00691	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L69425:
  0001c	8b f4		 mov	 esi, esp
  0001e	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$65093[ebp]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002a	3b f4		 cmp	 esi, esp
  0002c	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69426:
  00031	8b f4		 mov	 esi, esp
  00033	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR _strTmp$65107[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0003f	3b f4		 cmp	 esi, esp
  00041	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z:
  00046	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69428
  0004b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ENDP ; YL_RegInfo::DeleteKey
xdata$x	SEGMENT
$T69457	DD	0ffffffffH
	DD	FLAT:$L69450
	DD	00H
	DD	FLAT:$L69451
	DD	0ffffffffH
	DD	FLAT:$L69452
	DD	02H
	DD	FLAT:$L69453
$T69455	DD	019930520H
	DD	04H
	DD	FLAT:$T69457
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv131 = -156						; size = 4
tv139 = -152						; size = 4
tv129 = -148						; size = 4
tv136 = -144						; size = 4
tv95 = -140						; size = 4
tv133 = -136						; size = 4
$T69449 = -132						; size = 28
$T69448 = -104						; size = 28
$T69447 = -73						; size = 1
$T69446 = -72						; size = 28
$T69445 = -44						; size = 28
$T69444 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z PROC NEAR	; YL_RegInfo::DeleteKey

; 132  : {

  006a0	55		 push	 ebp
  006a1	8b ec		 mov	 ebp, esp
  006a3	6a ff		 push	 -1
  006a5	68 00 00 00 00	 push	 __ehhandler$?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z
  006aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  006b0	50		 push	 eax
  006b1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  006b8	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  006be	56		 push	 esi
  006bf	57		 push	 edi
  006c0	8d bd 64 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-156]
  006c6	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  006cb	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  006d0	f3 ab		 rep stosd

; 133  : 	if( pszRegEntry == NULL )

  006d2	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  006d6	75 07		 jne	 SHORT $L65126

; 134  : 	{
; 135  : 		return false;

  006d8	32 c0		 xor	 al, al
  006da	e9 55 01 00 00	 jmp	 $L65125
$L65126:

; 136  : 	}
; 137  : 	if( pszKeyName == NULL )

  006df	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  006e3	0f 85 9b 00 00
	00		 jne	 $L65127

; 138  : 	{
; 139  : 		return DeleteKey( hRegKey,string(pszRegEntry) );

  006e9	8b f4		 mov	 esi, esp
  006eb	68 00 00 00 00	 push	 OFFSET FLAT:$SG65131
  006f0	8d 4d d4	 lea	 ecx, DWORD PTR $T69445[ebp]
  006f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  006f9	3b f4		 cmp	 esi, esp
  006fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00700	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00707	8b f4		 mov	 esi, esp
  00709	8b 45 0c	 mov	 eax, DWORD PTR _pszRegEntry$[ebp]
  0070c	50		 push	 eax
  0070d	8d 4d b8	 lea	 ecx, DWORD PTR $T69446[ebp]
  00710	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00716	3b f4		 cmp	 esi, esp
  00718	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0071d	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv133[ebp], eax
  00723	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv133[ebp]
  00729	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv95[ebp], ecx
  0072f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00733	8d 55 d4	 lea	 edx, DWORD PTR $T69445[ebp]
  00736	52		 push	 edx
  00737	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv95[ebp]
  0073d	50		 push	 eax
  0073e	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00741	51		 push	 ecx
  00742	e8 00 00 00 00	 call	 ?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteKey
  00747	83 c4 0c	 add	 esp, 12			; 0000000cH
  0074a	88 45 f3	 mov	 BYTE PTR $T69444[ebp], al
  0074d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00751	8b f4		 mov	 esi, esp
  00753	8d 4d b8	 lea	 ecx, DWORD PTR $T69446[ebp]
  00756	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0075c	3b f4		 cmp	 esi, esp
  0075e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00763	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0076a	8b f4		 mov	 esi, esp
  0076c	8d 4d d4	 lea	 ecx, DWORD PTR $T69445[ebp]
  0076f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00775	3b f4		 cmp	 esi, esp
  00777	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0077c	8a 45 f3	 mov	 al, BYTE PTR $T69444[ebp]
  0077f	e9 b0 00 00 00	 jmp	 $L65125
$L65127:

; 140  : 	}
; 141  : 	else
; 142  : 	{
; 143  : 		return DeleteKey( hRegKey,string(pszRegEntry),string(pszKeyName) );

  00784	8b f4		 mov	 esi, esp
  00786	8b 55 10	 mov	 edx, DWORD PTR _pszKeyName$[ebp]
  00789	52		 push	 edx
  0078a	8d 4d 98	 lea	 ecx, DWORD PTR $T69448[ebp]
  0078d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00793	3b f4		 cmp	 esi, esp
  00795	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0079a	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv136[ebp], eax
  007a0	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv136[ebp]
  007a6	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv129[ebp], eax
  007ac	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  007b3	8b f4		 mov	 esi, esp
  007b5	8b 4d 0c	 mov	 ecx, DWORD PTR _pszRegEntry$[ebp]
  007b8	51		 push	 ecx
  007b9	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T69449[ebp]
  007bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  007c5	3b f4		 cmp	 esi, esp
  007c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  007cc	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv139[ebp], eax
  007d2	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv139[ebp]
  007d8	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv131[ebp], edx
  007de	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  007e2	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv129[ebp]
  007e8	50		 push	 eax
  007e9	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv131[ebp]
  007ef	51		 push	 ecx
  007f0	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  007f3	52		 push	 edx
  007f4	e8 00 00 00 00	 call	 ?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteKey
  007f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  007fc	88 45 b7	 mov	 BYTE PTR $T69447[ebp], al
  007ff	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00803	8b f4		 mov	 esi, esp
  00805	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T69449[ebp]
  0080b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00811	3b f4		 cmp	 esi, esp
  00813	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00818	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0081f	8b f4		 mov	 esi, esp
  00821	8d 4d 98	 lea	 ecx, DWORD PTR $T69448[ebp]
  00824	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0082a	3b f4		 cmp	 esi, esp
  0082c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00831	8a 45 b7	 mov	 al, BYTE PTR $T69447[ebp]
$L65125:

; 144  : 	}
; 145  : }

  00834	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00837	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0083e	5f		 pop	 edi
  0083f	5e		 pop	 esi
  00840	81 c4 9c 00 00
	00		 add	 esp, 156		; 0000009cH
  00846	3b ec		 cmp	 ebp, esp
  00848	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0084d	8b e5		 mov	 esp, ebp
  0084f	5d		 pop	 ebp
  00850	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L69450:
  00050	8b f4		 mov	 esi, esp
  00052	8d 4d d4	 lea	 ecx, DWORD PTR $T69445[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0005b	3b f4		 cmp	 esi, esp
  0005d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69451:
  00062	8b f4		 mov	 esi, esp
  00064	8d 4d b8	 lea	 ecx, DWORD PTR $T69446[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0006d	3b f4		 cmp	 esi, esp
  0006f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69452:
  00074	8b f4		 mov	 esi, esp
  00076	8d 4d 98	 lea	 ecx, DWORD PTR $T69448[ebp]
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0007f	3b f4		 cmp	 esi, esp
  00081	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69453:
  00086	8b f4		 mov	 esi, esp
  00088	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T69449[ebp]
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00094	3b f4		 cmp	 esi, esp
  00096	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z:
  0009b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69455
  000a0	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DeleteKey@YL_RegInfo@@SA_NPAUHKEY__@@PBD1@Z ENDP	; YL_RegInfo::DeleteKey
PUBLIC	?DeleteValue@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteValue
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_err$ = -16						; size = 4
_hKey$ = -8						; size = 4
_regClass$ = 8						; size = 4
_regEntry$ = 12						; size = 4
_valueName$ = 16					; size = 4
?DeleteValue@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z PROC NEAR ; YL_RegInfo::DeleteValue

; 148  : {

  00860	55		 push	 ebp
  00861	8b ec		 mov	 ebp, esp
  00863	83 ec 10	 sub	 esp, 16			; 00000010H
  00866	56		 push	 esi
  00867	57		 push	 edi
  00868	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0086d	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00870	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00873	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00876	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 149  : 	HKEY hKey; 
; 150  : 	LONG err ; 
; 151  : 	err = RegOpenKeyEx(regClass, regEntry.c_str(),0, KEY_ALL_ACCESS, &hKey);

  00879	8b f4		 mov	 esi, esp
  0087b	8d 45 f8	 lea	 eax, DWORD PTR _hKey$[ebp]
  0087e	50		 push	 eax
  0087f	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00884	6a 00		 push	 0
  00886	8b fc		 mov	 edi, esp
  00888	8b 4d 0c	 mov	 ecx, DWORD PTR _regEntry$[ebp]
  0088b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00891	3b fc		 cmp	 edi, esp
  00893	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00898	50		 push	 eax
  00899	8b 4d 08	 mov	 ecx, DWORD PTR _regClass$[ebp]
  0089c	51		 push	 ecx
  0089d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  008a3	3b f4		 cmp	 esi, esp
  008a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  008aa	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 152  : 	if(err == ERROR_SUCCESS) 

  008ad	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  008b1	75 3c		 jne	 SHORT $L65143

; 153  : 	{ 
; 154  : 		err = RegDeleteValue(hKey, valueName.c_str()); 

  008b3	8b f4		 mov	 esi, esp
  008b5	8b 4d 10	 mov	 ecx, DWORD PTR _valueName$[ebp]
  008b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  008be	3b f4		 cmp	 esi, esp
  008c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  008c5	8b f4		 mov	 esi, esp
  008c7	50		 push	 eax
  008c8	8b 55 f8	 mov	 edx, DWORD PTR _hKey$[ebp]
  008cb	52		 push	 edx
  008cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueA@8
  008d2	3b f4		 cmp	 esi, esp
  008d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  008d9	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 155  : 		RegCloseKey(hKey); 

  008dc	8b f4		 mov	 esi, esp
  008de	8b 45 f8	 mov	 eax, DWORD PTR _hKey$[ebp]
  008e1	50		 push	 eax
  008e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  008e8	3b f4		 cmp	 esi, esp
  008ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L65143:

; 156  : 	} 
; 157  : 
; 158  : 	return err;

  008ef	8b 45 f0	 mov	 eax, DWORD PTR _err$[ebp]

; 159  : }

  008f2	52		 push	 edx
  008f3	8b cd		 mov	 ecx, ebp
  008f5	50		 push	 eax
  008f6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69461
  008fc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00901	58		 pop	 eax
  00902	5a		 pop	 edx
  00903	5f		 pop	 edi
  00904	5e		 pop	 esi
  00905	83 c4 10	 add	 esp, 16			; 00000010H
  00908	3b ec		 cmp	 ebp, esp
  0090a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0090f	8b e5		 mov	 esp, ebp
  00911	5d		 pop	 ebp
  00912	c3		 ret	 0
$L69461:
  00913	01 00 00 00	 DD	 1
  00917	00 00 00 00	 DD	 $L69460
$L69460:
  0091b	f8 ff ff ff	 DD	 -8			; fffffff8H
  0091f	04 00 00 00	 DD	 4
  00923	00 00 00 00	 DD	 $L69459
$L69459:
  00927	68		 DB	 104			; 00000068H
  00928	4b		 DB	 75			; 0000004bH
  00929	65		 DB	 101			; 00000065H
  0092a	79		 DB	 121			; 00000079H
  0092b	00		 DB	 0
?DeleteValue@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ENDP ; YL_RegInfo::DeleteValue
_TEXT	ENDS
PUBLIC	?DeleteSubKey@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ; YL_RegInfo::DeleteSubKey
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_err$ = -16						; size = 4
_hKey$ = -8						; size = 4
_regClass$ = 8						; size = 4
_regEntry$ = 12						; size = 4
_keyName$ = 16						; size = 4
?DeleteSubKey@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z PROC NEAR ; YL_RegInfo::DeleteSubKey

; 162  : {

  00930	55		 push	 ebp
  00931	8b ec		 mov	 ebp, esp
  00933	83 ec 10	 sub	 esp, 16			; 00000010H
  00936	56		 push	 esi
  00937	57		 push	 edi
  00938	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0093d	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00940	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00943	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00946	89 45 fc	 mov	 DWORD PTR [ebp-4], eax

; 163  : 	HKEY hKey; 
; 164  : 	LONG err ; 
; 165  : 	err = RegOpenKeyEx(regClass, regEntry.c_str(),0, KEY_ALL_ACCESS, &hKey);

  00949	8b f4		 mov	 esi, esp
  0094b	8d 45 f8	 lea	 eax, DWORD PTR _hKey$[ebp]
  0094e	50		 push	 eax
  0094f	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00954	6a 00		 push	 0
  00956	8b fc		 mov	 edi, esp
  00958	8b 4d 0c	 mov	 ecx, DWORD PTR _regEntry$[ebp]
  0095b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00961	3b fc		 cmp	 edi, esp
  00963	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00968	50		 push	 eax
  00969	8b 4d 08	 mov	 ecx, DWORD PTR _regClass$[ebp]
  0096c	51		 push	 ecx
  0096d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00973	3b f4		 cmp	 esi, esp
  00975	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0097a	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 166  : 	if(err == ERROR_SUCCESS) 

  0097d	83 7d f0 00	 cmp	 DWORD PTR _err$[ebp], 0
  00981	75 3c		 jne	 SHORT $L65151

; 167  : 	{ 
; 168  : 		err = RegDeleteKey(hKey, keyName.c_str()); 

  00983	8b f4		 mov	 esi, esp
  00985	8b 4d 10	 mov	 ecx, DWORD PTR _keyName$[ebp]
  00988	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  0098e	3b f4		 cmp	 esi, esp
  00990	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00995	8b f4		 mov	 esi, esp
  00997	50		 push	 eax
  00998	8b 55 f8	 mov	 edx, DWORD PTR _hKey$[ebp]
  0099b	52		 push	 edx
  0099c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyA@8
  009a2	3b f4		 cmp	 esi, esp
  009a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  009a9	89 45 f0	 mov	 DWORD PTR _err$[ebp], eax

; 169  : 		RegCloseKey(hKey); 

  009ac	8b f4		 mov	 esi, esp
  009ae	8b 45 f8	 mov	 eax, DWORD PTR _hKey$[ebp]
  009b1	50		 push	 eax
  009b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  009b8	3b f4		 cmp	 esi, esp
  009ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L65151:

; 170  : 	} 
; 171  : 
; 172  : 	return err;

  009bf	8b 45 f0	 mov	 eax, DWORD PTR _err$[ebp]

; 173  : }

  009c2	52		 push	 edx
  009c3	8b cd		 mov	 ecx, ebp
  009c5	50		 push	 eax
  009c6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69465
  009cc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  009d1	58		 pop	 eax
  009d2	5a		 pop	 edx
  009d3	5f		 pop	 edi
  009d4	5e		 pop	 esi
  009d5	83 c4 10	 add	 esp, 16			; 00000010H
  009d8	3b ec		 cmp	 ebp, esp
  009da	e8 00 00 00 00	 call	 __RTC_CheckEsp
  009df	8b e5		 mov	 esp, ebp
  009e1	5d		 pop	 ebp
  009e2	c3		 ret	 0
$L69465:
  009e3	01 00 00 00	 DD	 1
  009e7	00 00 00 00	 DD	 $L69464
$L69464:
  009eb	f8 ff ff ff	 DD	 -8			; fffffff8H
  009ef	04 00 00 00	 DD	 4
  009f3	00 00 00 00	 DD	 $L69463
$L69463:
  009f7	68		 DB	 104			; 00000068H
  009f8	4b		 DB	 75			; 0000004bH
  009f9	65		 DB	 101			; 00000065H
  009fa	79		 DB	 121			; 00000079H
  009fb	00		 DB	 0
?DeleteSubKey@YL_RegInfo@@SAJPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1@Z ENDP ; YL_RegInfo::DeleteSubKey
_TEXT	ENDS
PUBLIC	?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@11@Z ; YL_RegInfo::WriteString
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp__RegSetValueExA@24:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_regType$65173 = -48					; size = 4
_err$65172 = -44					; size = 4
_dw$65170 = -40						; size = 4
_hKey$65169 = -32					; size = 4
_regType$ = -24						; size = 4
_err$ = -20						; size = 4
_dw$ = -16						; size = 4
_hKey$ = -8						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
_strKeyValue$ = 20					; size = 4
?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@11@Z PROC NEAR ; YL_RegInfo::WriteString

; 176  : {

  00a00	55		 push	 ebp
  00a01	8b ec		 mov	 ebp, esp
  00a03	83 ec 30	 sub	 esp, 48			; 00000030H
  00a06	56		 push	 esi
  00a07	57		 push	 edi
  00a08	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  00a0b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00a10	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00a15	f3 ab		 rep stosd

; 177  : 	HKEY hKey;
; 178  : 	DWORD dw = (DWORD)strKeyValue.size(); 

  00a17	8b f4		 mov	 esi, esp
  00a19	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  00a1c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00a22	3b f4		 cmp	 esi, esp
  00a24	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a29	89 45 f0	 mov	 DWORD PTR _dw$[ebp], eax

; 179  : 	LONG err = -1; 

  00a2c	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1

; 180  : 	DWORD regType = REG_SZ; 	

  00a33	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _regType$[ebp], 1

; 181  : 
; 182  : 	err = RegOpenKeyEx( hRegKey, strRegEntry.c_str(),0, KEY_SET_VALUE, &hKey ) ;

  00a3a	8b f4		 mov	 esi, esp
  00a3c	8d 45 f8	 lea	 eax, DWORD PTR _hKey$[ebp]
  00a3f	50		 push	 eax
  00a40	6a 02		 push	 2
  00a42	6a 00		 push	 0
  00a44	8b fc		 mov	 edi, esp
  00a46	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00a49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00a4f	3b fc		 cmp	 edi, esp
  00a51	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a56	50		 push	 eax
  00a57	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00a5a	51		 push	 ecx
  00a5b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00a61	3b f4		 cmp	 esi, esp
  00a63	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a68	89 45 ec	 mov	 DWORD PTR _err$[ebp], eax

; 183  : 	if(err == ERROR_SUCCESS)

  00a6b	83 7d ec 00	 cmp	 DWORD PTR _err$[ebp], 0
  00a6f	0f 85 82 00 00
	00		 jne	 $L65163

; 184  : 	{ 
; 185  : 		err = RegSetValueEx( hKey, strKeyName.c_str() , 0, regType, (LPBYTE) strKeyValue.c_str(), dw ); 

  00a75	8b f4		 mov	 esi, esp
  00a77	8b 55 f0	 mov	 edx, DWORD PTR _dw$[ebp]
  00a7a	52		 push	 edx
  00a7b	8b fc		 mov	 edi, esp
  00a7d	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  00a80	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00a86	3b fc		 cmp	 edi, esp
  00a88	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00a8d	50		 push	 eax
  00a8e	8b 45 e8	 mov	 eax, DWORD PTR _regType$[ebp]
  00a91	50		 push	 eax
  00a92	6a 00		 push	 0
  00a94	8b fc		 mov	 edi, esp
  00a96	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  00a99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00a9f	3b fc		 cmp	 edi, esp
  00aa1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00aa6	50		 push	 eax
  00aa7	8b 4d f8	 mov	 ecx, DWORD PTR _hKey$[ebp]
  00aaa	51		 push	 ecx
  00aab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00ab1	3b f4		 cmp	 esi, esp
  00ab3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ab8	89 45 ec	 mov	 DWORD PTR _err$[ebp], eax

; 186  : 		if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  00abb	83 7d ec 00	 cmp	 DWORD PTR _err$[ebp], 0
  00abf	75 1e		 jne	 SHORT $L65165
  00ac1	8b f4		 mov	 esi, esp
  00ac3	8b 55 f8	 mov	 edx, DWORD PTR _hKey$[ebp]
  00ac6	52		 push	 edx
  00ac7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00acd	3b f4		 cmp	 esi, esp
  00acf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ad4	85 c0		 test	 eax, eax
  00ad6	75 07		 jne	 SHORT $L65165

; 187  : 		{
; 188  : 			return true;

  00ad8	b0 01		 mov	 al, 1
  00ada	e9 13 01 00 00	 jmp	 $L65157
$L65165:

; 189  : 		}
; 190  : 		RegCloseKey( hKey );

  00adf	8b f4		 mov	 esi, esp
  00ae1	8b 45 f8	 mov	 eax, DWORD PTR _hKey$[ebp]
  00ae4	50		 push	 eax
  00ae5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00aeb	3b f4		 cmp	 esi, esp
  00aed	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 191  : 	} 
; 192  : 	else if( err == ERROR_FILE_NOT_FOUND )

  00af2	e9 f9 00 00 00	 jmp	 $L65166
$L65163:
  00af7	83 7d ec 02	 cmp	 DWORD PTR _err$[ebp], 2
  00afb	0f 85 ef 00 00
	00		 jne	 $L65166

; 193  : 	{		
; 194  : 		if( CreateKey( hRegKey,strRegEntry) )

  00b01	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00b04	51		 push	 ecx
  00b05	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  00b08	52		 push	 edx
  00b09	e8 00 00 00 00	 call	 ?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_RegInfo::CreateKey
  00b0e	83 c4 08	 add	 esp, 8
  00b11	0f b6 c0	 movzx	 eax, al
  00b14	85 c0		 test	 eax, eax
  00b16	0f 84 d4 00 00
	00		 je	 $L65166

; 195  : 		{
; 196  : 			HKEY hKey;
; 197  : 			DWORD dw = (DWORD)strKeyValue.size(); 

  00b1c	8b f4		 mov	 esi, esp
  00b1e	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  00b21	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00b27	3b f4		 cmp	 esi, esp
  00b29	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b2e	89 45 d8	 mov	 DWORD PTR _dw$65170[ebp], eax

; 198  : 			LONG err = -1; 

  00b31	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR _err$65172[ebp], -1

; 199  : 			DWORD regType = REG_SZ; 	

  00b38	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _regType$65173[ebp], 1

; 200  : 
; 201  : 			err = RegOpenKeyEx( hRegKey, strRegEntry.c_str(),0, KEY_SET_VALUE, &hKey ) ;

  00b3f	8b f4		 mov	 esi, esp
  00b41	8d 4d e0	 lea	 ecx, DWORD PTR _hKey$65169[ebp]
  00b44	51		 push	 ecx
  00b45	6a 02		 push	 2
  00b47	6a 00		 push	 0
  00b49	8b fc		 mov	 edi, esp
  00b4b	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00b4e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00b54	3b fc		 cmp	 edi, esp
  00b56	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b5b	50		 push	 eax
  00b5c	8b 55 08	 mov	 edx, DWORD PTR _hRegKey$[ebp]
  00b5f	52		 push	 edx
  00b60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00b66	3b f4		 cmp	 esi, esp
  00b68	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b6d	89 45 d4	 mov	 DWORD PTR _err$65172[ebp], eax

; 202  : 			if(err == ERROR_SUCCESS)

  00b70	83 7d d4 00	 cmp	 DWORD PTR _err$65172[ebp], 0
  00b74	75 7a		 jne	 SHORT $L65166

; 203  : 			{ 
; 204  : 				err = RegSetValueEx( hKey, strKeyName.c_str() , 0, regType, (LPBYTE) strKeyValue.c_str(), dw ); 

  00b76	8b f4		 mov	 esi, esp
  00b78	8b 45 d8	 mov	 eax, DWORD PTR _dw$65170[ebp]
  00b7b	50		 push	 eax
  00b7c	8b fc		 mov	 edi, esp
  00b7e	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  00b81	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00b87	3b fc		 cmp	 edi, esp
  00b89	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00b8e	50		 push	 eax
  00b8f	8b 4d d0	 mov	 ecx, DWORD PTR _regType$65173[ebp]
  00b92	51		 push	 ecx
  00b93	6a 00		 push	 0
  00b95	8b fc		 mov	 edi, esp
  00b97	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  00b9a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00ba0	3b fc		 cmp	 edi, esp
  00ba2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ba7	50		 push	 eax
  00ba8	8b 55 e0	 mov	 edx, DWORD PTR _hKey$65169[ebp]
  00bab	52		 push	 edx
  00bac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00bb2	3b f4		 cmp	 esi, esp
  00bb4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00bb9	89 45 d4	 mov	 DWORD PTR _err$65172[ebp], eax

; 205  : 				if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  00bbc	83 7d d4 00	 cmp	 DWORD PTR _err$65172[ebp], 0
  00bc0	75 1b		 jne	 SHORT $L65176
  00bc2	8b f4		 mov	 esi, esp
  00bc4	8b 45 e0	 mov	 eax, DWORD PTR _hKey$65169[ebp]
  00bc7	50		 push	 eax
  00bc8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00bce	3b f4		 cmp	 esi, esp
  00bd0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00bd5	85 c0		 test	 eax, eax
  00bd7	75 04		 jne	 SHORT $L65176

; 206  : 				{
; 207  : 					return true;

  00bd9	b0 01		 mov	 al, 1
  00bdb	eb 15		 jmp	 SHORT $L65157
$L65176:

; 208  : 				}
; 209  : 				RegCloseKey( hKey );

  00bdd	8b f4		 mov	 esi, esp
  00bdf	8b 4d e0	 mov	 ecx, DWORD PTR _hKey$65169[ebp]
  00be2	51		 push	 ecx
  00be3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00be9	3b f4		 cmp	 esi, esp
  00beb	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L65166:

; 210  : 			} 			
; 211  : 		}
; 212  : 	}
; 213  : 
; 214  : 	return false;

  00bf0	32 c0		 xor	 al, al
$L65157:

; 215  : }

  00bf2	52		 push	 edx
  00bf3	8b cd		 mov	 ecx, ebp
  00bf5	50		 push	 eax
  00bf6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69470
  00bfc	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00c01	58		 pop	 eax
  00c02	5a		 pop	 edx
  00c03	5f		 pop	 edi
  00c04	5e		 pop	 esi
  00c05	83 c4 30	 add	 esp, 48			; 00000030H
  00c08	3b ec		 cmp	 ebp, esp
  00c0a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c0f	8b e5		 mov	 esp, ebp
  00c11	5d		 pop	 ebp
  00c12	c3		 ret	 0
$L69470:
  00c13	02 00 00 00	 DD	 2
  00c17	00 00 00 00	 DD	 $L69469
$L69469:
  00c1b	f8 ff ff ff	 DD	 -8			; fffffff8H
  00c1f	04 00 00 00	 DD	 4
  00c23	00 00 00 00	 DD	 $L69467
  00c27	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00c2b	04 00 00 00	 DD	 4
  00c2f	00 00 00 00	 DD	 $L69468
$L69468:
  00c33	68		 DB	 104			; 00000068H
  00c34	4b		 DB	 75			; 0000004bH
  00c35	65		 DB	 101			; 00000065H
  00c36	79		 DB	 121			; 00000079H
  00c37	00		 DB	 0
$L69467:
  00c38	68		 DB	 104			; 00000068H
  00c39	4b		 DB	 75			; 0000004bH
  00c3a	65		 DB	 101			; 00000065H
  00c3b	79		 DB	 121			; 00000079H
  00c3c	00		 DB	 0
?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@11@Z ENDP ; YL_RegInfo::WriteString
_TEXT	ENDS
PUBLIC	?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z	; YL_RegInfo::WriteString
xdata$x	SEGMENT
$T69482	DD	0ffffffffH
	DD	FLAT:$L69476
	DD	00H
	DD	FLAT:$L69477
	DD	01H
	DD	FLAT:$L69478
$T69480	DD	019930520H
	DD	03H
	DD	FLAT:$T69482
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv92 = -124						; size = 4
tv131 = -120						; size = 4
tv90 = -116						; size = 4
tv128 = -112						; size = 4
tv88 = -108						; size = 4
tv93 = -104						; size = 4
$T69475 = -100						; size = 28
$T69474 = -72						; size = 28
$T69473 = -44						; size = 28
$T69472 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
_pszKeyValue$ = 20					; size = 4
?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z PROC NEAR ; YL_RegInfo::WriteString

; 218  : {

  00c40	55		 push	 ebp
  00c41	8b ec		 mov	 ebp, esp
  00c43	6a ff		 push	 -1
  00c45	68 00 00 00 00	 push	 __ehhandler$?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z
  00c4a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00c50	50		 push	 eax
  00c51	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00c58	83 ec 70	 sub	 esp, 112		; 00000070H
  00c5b	56		 push	 esi
  00c5c	57		 push	 edi
  00c5d	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  00c60	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00c65	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00c6a	f3 ab		 rep stosd

; 219  : 	if( pszRegEntry == NULL || pszKeyName == NULL || pszKeyValue == NULL )

  00c6c	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  00c70	74 0c		 je	 SHORT $L65184
  00c72	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  00c76	74 06		 je	 SHORT $L65184
  00c78	83 7d 14 00	 cmp	 DWORD PTR _pszKeyValue$[ebp], 0
  00c7c	75 07		 jne	 SHORT $L65183
$L65184:

; 220  : 	{
; 221  : 		return false;

  00c7e	32 c0		 xor	 al, al
  00c80	e9 cf 00 00 00	 jmp	 $L65182
$L65183:

; 222  : 	}
; 223  : 	return WriteString( hRegKey,string(pszRegEntry),string(pszKeyName),string(pszKeyValue) );

  00c85	8b f4		 mov	 esi, esp
  00c87	8b 45 14	 mov	 eax, DWORD PTR _pszKeyValue$[ebp]
  00c8a	50		 push	 eax
  00c8b	8d 4d d4	 lea	 ecx, DWORD PTR $T69473[ebp]
  00c8e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00c94	3b f4		 cmp	 esi, esp
  00c96	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c9b	89 45 98	 mov	 DWORD PTR tv93[ebp], eax
  00c9e	8b 4d 98	 mov	 ecx, DWORD PTR tv93[ebp]
  00ca1	89 4d 94	 mov	 DWORD PTR tv88[ebp], ecx
  00ca4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00cab	8b f4		 mov	 esi, esp
  00cad	8b 55 10	 mov	 edx, DWORD PTR _pszKeyName$[ebp]
  00cb0	52		 push	 edx
  00cb1	8d 4d b8	 lea	 ecx, DWORD PTR $T69474[ebp]
  00cb4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00cba	3b f4		 cmp	 esi, esp
  00cbc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00cc1	89 45 90	 mov	 DWORD PTR tv128[ebp], eax
  00cc4	8b 45 90	 mov	 eax, DWORD PTR tv128[ebp]
  00cc7	89 45 8c	 mov	 DWORD PTR tv90[ebp], eax
  00cca	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00cce	8b f4		 mov	 esi, esp
  00cd0	8b 4d 0c	 mov	 ecx, DWORD PTR _pszRegEntry$[ebp]
  00cd3	51		 push	 ecx
  00cd4	8d 4d 9c	 lea	 ecx, DWORD PTR $T69475[ebp]
  00cd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00cdd	3b f4		 cmp	 esi, esp
  00cdf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ce4	89 45 88	 mov	 DWORD PTR tv131[ebp], eax
  00ce7	8b 55 88	 mov	 edx, DWORD PTR tv131[ebp]
  00cea	89 55 84	 mov	 DWORD PTR tv92[ebp], edx
  00ced	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00cf1	8b 45 94	 mov	 eax, DWORD PTR tv88[ebp]
  00cf4	50		 push	 eax
  00cf5	8b 4d 8c	 mov	 ecx, DWORD PTR tv90[ebp]
  00cf8	51		 push	 ecx
  00cf9	8b 55 84	 mov	 edx, DWORD PTR tv92[ebp]
  00cfc	52		 push	 edx
  00cfd	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  00d00	50		 push	 eax
  00d01	e8 00 00 00 00	 call	 ?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@11@Z ; YL_RegInfo::WriteString
  00d06	83 c4 10	 add	 esp, 16			; 00000010H
  00d09	88 45 f3	 mov	 BYTE PTR $T69472[ebp], al
  00d0c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00d10	8b f4		 mov	 esi, esp
  00d12	8d 4d 9c	 lea	 ecx, DWORD PTR $T69475[ebp]
  00d15	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00d1b	3b f4		 cmp	 esi, esp
  00d1d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d22	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00d26	8b f4		 mov	 esi, esp
  00d28	8d 4d b8	 lea	 ecx, DWORD PTR $T69474[ebp]
  00d2b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00d31	3b f4		 cmp	 esi, esp
  00d33	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d38	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00d3f	8b f4		 mov	 esi, esp
  00d41	8d 4d d4	 lea	 ecx, DWORD PTR $T69473[ebp]
  00d44	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00d4a	3b f4		 cmp	 esi, esp
  00d4c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d51	8a 45 f3	 mov	 al, BYTE PTR $T69472[ebp]
$L65182:

; 224  : }

  00d54	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00d57	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00d5e	5f		 pop	 edi
  00d5f	5e		 pop	 esi
  00d60	83 c4 7c	 add	 esp, 124		; 0000007cH
  00d63	3b ec		 cmp	 ebp, esp
  00d65	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d6a	8b e5		 mov	 esp, ebp
  00d6c	5d		 pop	 ebp
  00d6d	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L69476:
  000a5	8b f4		 mov	 esi, esp
  000a7	8d 4d d4	 lea	 ecx, DWORD PTR $T69473[ebp]
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000b0	3b f4		 cmp	 esi, esp
  000b2	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69477:
  000b7	8b f4		 mov	 esi, esp
  000b9	8d 4d b8	 lea	 ecx, DWORD PTR $T69474[ebp]
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000c2	3b f4		 cmp	 esi, esp
  000c4	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69478:
  000c9	8b f4		 mov	 esi, esp
  000cb	8d 4d 9c	 lea	 ecx, DWORD PTR $T69475[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000d4	3b f4		 cmp	 esi, esp
  000d6	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z:
  000db	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69480
  000e0	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?WriteString@YL_RegInfo@@SA_NPAUHKEY__@@PBD11@Z ENDP	; YL_RegInfo::WriteString
PUBLIC	?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAV34@@Z ; YL_RegInfo::ReadString
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	__imp__RegQueryValueExA@24:NEAR
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T69485 = -64						; size = 4
$T69484 = -60						; size = 4
_buf2$65203 = -56					; size = 4
_buf1$ = -45						; size = 1
_regType$ = -36						; size = 4
_err$ = -28						; size = 4
_dw$ = -20						; size = 4
_hKey$ = -8						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
_strKeyValue$ = 20					; size = 4
?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAV34@@Z PROC NEAR ; YL_RegInfo::ReadString

; 228  : {

  00d70	55		 push	 ebp
  00d71	8b ec		 mov	 ebp, esp
  00d73	83 ec 40	 sub	 esp, 64			; 00000040H
  00d76	56		 push	 esi
  00d77	57		 push	 edi
  00d78	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00d7b	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00d80	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00d85	f3 ab		 rep stosd

; 229  : 	HKEY hKey; 
; 230  : 	DWORD dw = 0; 

  00d87	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 0

; 231  : 	LONG err ; 
; 232  : 	DWORD regType = REG_SZ;

  00d8e	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _regType$[ebp], 1

; 233  : 	char buf1[1];
; 234  : 	
; 235  : 	buf1[0] = 0;

  00d95	c6 45 d3 00	 mov	 BYTE PTR _buf1$[ebp], 0

; 236  : 	err = RegOpenKeyEx( hRegKey, strRegEntry.c_str() ,0, KEY_READ, &hKey );

  00d99	8b f4		 mov	 esi, esp
  00d9b	8d 45 f8	 lea	 eax, DWORD PTR _hKey$[ebp]
  00d9e	50		 push	 eax
  00d9f	68 19 00 02 00	 push	 131097			; 00020019H
  00da4	6a 00		 push	 0
  00da6	8b fc		 mov	 edi, esp
  00da8	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  00dab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00db1	3b fc		 cmp	 edi, esp
  00db3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00db8	50		 push	 eax
  00db9	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  00dbc	51		 push	 ecx
  00dbd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  00dc3	3b f4		 cmp	 esi, esp
  00dc5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00dca	89 45 e4	 mov	 DWORD PTR _err$[ebp], eax

; 237  : 	if(err == ERROR_SUCCESS) 

  00dcd	83 7d e4 00	 cmp	 DWORD PTR _err$[ebp], 0
  00dd1	0f 85 f2 00 00
	00		 jne	 $L65200

; 238  : 	{
; 239  : 		err = RegQueryValueEx( hKey, strKeyName.c_str() , 0, &regType,(LPBYTE) buf1, &dw); 

  00dd7	8b f4		 mov	 esi, esp
  00dd9	8d 55 ec	 lea	 edx, DWORD PTR _dw$[ebp]
  00ddc	52		 push	 edx
  00ddd	8d 45 d3	 lea	 eax, DWORD PTR _buf1$[ebp]
  00de0	50		 push	 eax
  00de1	8d 4d dc	 lea	 ecx, DWORD PTR _regType$[ebp]
  00de4	51		 push	 ecx
  00de5	6a 00		 push	 0
  00de7	8b fc		 mov	 edi, esp
  00de9	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  00dec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00df2	3b fc		 cmp	 edi, esp
  00df4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00df9	50		 push	 eax
  00dfa	8b 55 f8	 mov	 edx, DWORD PTR _hKey$[ebp]
  00dfd	52		 push	 edx
  00dfe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00e04	3b f4		 cmp	 esi, esp
  00e06	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00e0b	89 45 e4	 mov	 DWORD PTR _err$[ebp], eax

; 240  : 		if(err == ERROR_MORE_DATA)

  00e0e	81 7d e4 ea 00
	00 00		 cmp	 DWORD PTR _err$[ebp], 234 ; 000000eaH
  00e15	0f 85 9b 00 00
	00		 jne	 $L65202

; 241  : 		{
; 242  : 			char* buf2 = new char[dw + 1];

  00e1b	8b 45 ec	 mov	 eax, DWORD PTR _dw$[ebp]
  00e1e	83 c0 01	 add	 eax, 1
  00e21	50		 push	 eax
  00e22	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00e27	83 c4 04	 add	 esp, 4
  00e2a	89 45 c4	 mov	 DWORD PTR $T69484[ebp], eax
  00e2d	8b 4d c4	 mov	 ecx, DWORD PTR $T69484[ebp]
  00e30	89 4d c8	 mov	 DWORD PTR _buf2$65203[ebp], ecx

; 243  : 			err = RegQueryValueEx(hKey, strKeyName.c_str() , 0, &regType,(LPBYTE) buf2 , &dw); 

  00e33	8b f4		 mov	 esi, esp
  00e35	8d 55 ec	 lea	 edx, DWORD PTR _dw$[ebp]
  00e38	52		 push	 edx
  00e39	8b 45 c8	 mov	 eax, DWORD PTR _buf2$65203[ebp]
  00e3c	50		 push	 eax
  00e3d	8d 4d dc	 lea	 ecx, DWORD PTR _regType$[ebp]
  00e40	51		 push	 ecx
  00e41	6a 00		 push	 0
  00e43	8b fc		 mov	 edi, esp
  00e45	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  00e48	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  00e4e	3b fc		 cmp	 edi, esp
  00e50	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00e55	50		 push	 eax
  00e56	8b 55 f8	 mov	 edx, DWORD PTR _hKey$[ebp]
  00e59	52		 push	 edx
  00e5a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00e60	3b f4		 cmp	 esi, esp
  00e62	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00e67	89 45 e4	 mov	 DWORD PTR _err$[ebp], eax

; 244  : 			buf2[dw] = 0;

  00e6a	8b 45 c8	 mov	 eax, DWORD PTR _buf2$65203[ebp]
  00e6d	03 45 ec	 add	 eax, DWORD PTR _dw$[ebp]
  00e70	c6 00 00	 mov	 BYTE PTR [eax], 0

; 245  : 			strKeyValue = buf2;

  00e73	8b f4		 mov	 esi, esp
  00e75	8b 4d c8	 mov	 ecx, DWORD PTR _buf2$65203[ebp]
  00e78	51		 push	 ecx
  00e79	8b 4d 14	 mov	 ecx, DWORD PTR _strKeyValue$[ebp]
  00e7c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  00e82	3b f4		 cmp	 esi, esp
  00e84	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 246  : 			delete[] buf2;

  00e89	8b 55 c8	 mov	 edx, DWORD PTR _buf2$65203[ebp]
  00e8c	89 55 c0	 mov	 DWORD PTR $T69485[ebp], edx
  00e8f	8b 45 c0	 mov	 eax, DWORD PTR $T69485[ebp]
  00e92	50		 push	 eax
  00e93	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00e98	83 c4 04	 add	 esp, 4

; 247  : 			if( RegCloseKey(hKey) == ERROR_SUCCESS )

  00e9b	8b f4		 mov	 esi, esp
  00e9d	8b 4d f8	 mov	 ecx, DWORD PTR _hKey$[ebp]
  00ea0	51		 push	 ecx
  00ea1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00ea7	3b f4		 cmp	 esi, esp
  00ea9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00eae	85 c0		 test	 eax, eax
  00eb0	75 04		 jne	 SHORT $L65202

; 248  : 			{
; 249  : 				return true;

  00eb2	b0 01		 mov	 al, 1
  00eb4	eb 15		 jmp	 SHORT $L65194
$L65202:

; 250  : 			}
; 251  : 		}	
; 252  : 		RegCloseKey( hKey );

  00eb6	8b f4		 mov	 esi, esp
  00eb8	8b 55 f8	 mov	 edx, DWORD PTR _hKey$[ebp]
  00ebb	52		 push	 edx
  00ebc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00ec2	3b f4		 cmp	 esi, esp
  00ec4	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L65200:

; 253  : 	} 
; 254  : 
; 255  : 	return false;

  00ec9	32 c0		 xor	 al, al
$L65194:

; 256  : }

  00ecb	52		 push	 edx
  00ecc	8b cd		 mov	 ecx, ebp
  00ece	50		 push	 eax
  00ecf	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69491
  00ed5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00eda	58		 pop	 eax
  00edb	5a		 pop	 edx
  00edc	5f		 pop	 edi
  00edd	5e		 pop	 esi
  00ede	83 c4 40	 add	 esp, 64			; 00000040H
  00ee1	3b ec		 cmp	 ebp, esp
  00ee3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ee8	8b e5		 mov	 esp, ebp
  00eea	5d		 pop	 ebp
  00eeb	c3		 ret	 0
$L69491:
  00eec	04 00 00 00	 DD	 4
  00ef0	00 00 00 00	 DD	 $L69490
$L69490:
  00ef4	f8 ff ff ff	 DD	 -8			; fffffff8H
  00ef8	04 00 00 00	 DD	 4
  00efc	00 00 00 00	 DD	 $L69486
  00f00	ec ff ff ff	 DD	 -20			; ffffffecH
  00f04	04 00 00 00	 DD	 4
  00f08	00 00 00 00	 DD	 $L69487
  00f0c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00f10	04 00 00 00	 DD	 4
  00f14	00 00 00 00	 DD	 $L69488
  00f18	d3 ff ff ff	 DD	 -45			; ffffffd3H
  00f1c	01 00 00 00	 DD	 1
  00f20	00 00 00 00	 DD	 $L69489
$L69489:
  00f24	62		 DB	 98			; 00000062H
  00f25	75		 DB	 117			; 00000075H
  00f26	66		 DB	 102			; 00000066H
  00f27	31		 DB	 49			; 00000031H
  00f28	00		 DB	 0
$L69488:
  00f29	72		 DB	 114			; 00000072H
  00f2a	65		 DB	 101			; 00000065H
  00f2b	67		 DB	 103			; 00000067H
  00f2c	54		 DB	 84			; 00000054H
  00f2d	79		 DB	 121			; 00000079H
  00f2e	70		 DB	 112			; 00000070H
  00f2f	65		 DB	 101			; 00000065H
  00f30	00		 DB	 0
$L69487:
  00f31	64		 DB	 100			; 00000064H
  00f32	77		 DB	 119			; 00000077H
  00f33	00		 DB	 0
$L69486:
  00f34	68		 DB	 104			; 00000068H
  00f35	4b		 DB	 75			; 0000004bH
  00f36	65		 DB	 101			; 00000065H
  00f37	79		 DB	 121			; 00000079H
  00f38	00		 DB	 0
?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAV34@@Z ENDP ; YL_RegInfo::ReadString
_TEXT	ENDS
PUBLIC	?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z ; YL_RegInfo::ReadString
EXTRN	_strcpy:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
xdata$x	SEGMENT
$T69516	DD	0ffffffffH
	DD	FLAT:$L69501
	DD	00H
	DD	FLAT:$L69503
	DD	01H
	DD	FLAT:$L69505
$T69510	DD	019930520H
	DD	03H
	DD	FLAT:$T69516
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv90 = -140						; size = 4
tv140 = -136						; size = 4
tv152 = -132						; size = 4
tv135 = -128						; size = 4
tv148 = -124						; size = 4
$T69502 = -120						; size = 4
$T69500 = -114						; size = 1
$T69499 = -113						; size = 1
$T69496 = -112						; size = 28
$T69495 = -84						; size = 28
$T69494 = -53						; size = 1
_strKeyValue$ = -48					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
_szBuffer$ = 20						; size = 4
_unBuffLen$ = 24					; size = 4
?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z PROC NEAR ; YL_RegInfo::ReadString

; 259  : {

  00f40	55		 push	 ebp
  00f41	8b ec		 mov	 ebp, esp
  00f43	6a ff		 push	 -1
  00f45	68 00 00 00 00	 push	 __ehhandler$?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z
  00f4a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00f50	50		 push	 eax
  00f51	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00f58	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00f5e	56		 push	 esi
  00f5f	57		 push	 edi
  00f60	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00f66	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00f6b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00f70	f3 ab		 rep stosd
  00f72	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00f77	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00f7a	c7 45 88 00 00
	00 00		 mov	 DWORD PTR $T69502[ebp], 0

; 260  : 	if( pszRegEntry == NULL || pszKeyName == NULL)

  00f81	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  00f85	74 06		 je	 SHORT $L65217
  00f87	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  00f8b	75 07		 jne	 SHORT $L65216
$L65217:

; 261  : 	{
; 262  : 		return false;

  00f8d	32 c0		 xor	 al, al
  00f8f	e9 8d 01 00 00	 jmp	 $L65215
$L65216:

; 263  : 	}
; 264  : 	string strKeyValue;

  00f94	8b f4		 mov	 esi, esp
  00f96	8d 4d d0	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  00f99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00f9f	3b f4		 cmp	 esi, esp
  00fa1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00fa6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 265  : 	if( ReadString( hRegKey,string(pszRegEntry),string(pszKeyName),strKeyValue) && strKeyValue.length() <= unBuffLen - 1  )

  00fad	8b f4		 mov	 esi, esp
  00faf	8b 45 10	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  00fb2	50		 push	 eax
  00fb3	8d 4d ac	 lea	 ecx, DWORD PTR $T69495[ebp]
  00fb6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00fbc	3b f4		 cmp	 esi, esp
  00fbe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00fc3	89 45 84	 mov	 DWORD PTR tv148[ebp], eax
  00fc6	8b 4d 84	 mov	 ecx, DWORD PTR tv148[ebp]
  00fc9	89 4d 80	 mov	 DWORD PTR tv135[ebp], ecx
  00fcc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00fd0	8b 55 88	 mov	 edx, DWORD PTR $T69502[ebp]
  00fd3	83 ca 01	 or	 edx, 1
  00fd6	89 55 88	 mov	 DWORD PTR $T69502[ebp], edx
  00fd9	8b f4		 mov	 esi, esp
  00fdb	8b 45 0c	 mov	 eax, DWORD PTR _pszRegEntry$[ebp]
  00fde	50		 push	 eax
  00fdf	8d 4d 90	 lea	 ecx, DWORD PTR $T69496[ebp]
  00fe2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00fe8	3b f4		 cmp	 esi, esp
  00fea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00fef	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv152[ebp], eax
  00ff5	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv152[ebp]
  00ffb	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv140[ebp], ecx
  01001	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  01008	8b 55 88	 mov	 edx, DWORD PTR $T69502[ebp]
  0100b	83 ca 02	 or	 edx, 2
  0100e	89 55 88	 mov	 DWORD PTR $T69502[ebp], edx
  01011	8d 45 d0	 lea	 eax, DWORD PTR _strKeyValue$[ebp]
  01014	50		 push	 eax
  01015	8b 4d 80	 mov	 ecx, DWORD PTR tv135[ebp]
  01018	51		 push	 ecx
  01019	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv140[ebp]
  0101f	52		 push	 edx
  01020	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  01023	50		 push	 eax
  01024	e8 00 00 00 00	 call	 ?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAV34@@Z ; YL_RegInfo::ReadString
  01029	83 c4 10	 add	 esp, 16			; 00000010H
  0102c	0f b6 c8	 movzx	 ecx, al
  0102f	85 c9		 test	 ecx, ecx
  01031	74 28		 je	 SHORT $L69497
  01033	8b f4		 mov	 esi, esp
  01035	8d 4d d0	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  01038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  0103e	3b f4		 cmp	 esi, esp
  01040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01045	8b 55 18	 mov	 edx, DWORD PTR _unBuffLen$[ebp]
  01048	83 ea 01	 sub	 edx, 1
  0104b	3b c2		 cmp	 eax, edx
  0104d	77 0c		 ja	 SHORT $L69497
  0104f	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv90[ebp], 1
  01059	eb 0a		 jmp	 SHORT $L69498
$L69497:
  0105b	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv90[ebp], 0
$L69498:
  01065	8a 85 74 ff ff
	ff		 mov	 al, BYTE PTR tv90[ebp]
  0106b	88 45 cb	 mov	 BYTE PTR $T69494[ebp], al
  0106e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  01075	8b 4d 88	 mov	 ecx, DWORD PTR $T69502[ebp]
  01078	83 e1 02	 and	 ecx, 2
  0107b	74 16		 je	 SHORT $L69507
  0107d	83 65 88 fd	 and	 DWORD PTR $T69502[ebp], -3 ; fffffffdH
  01081	8b f4		 mov	 esi, esp
  01083	8d 4d 90	 lea	 ecx, DWORD PTR $T69496[ebp]
  01086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0108c	3b f4		 cmp	 esi, esp
  0108e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L69507:
  01093	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0109a	8b 55 88	 mov	 edx, DWORD PTR $T69502[ebp]
  0109d	83 e2 01	 and	 edx, 1
  010a0	74 16		 je	 SHORT $L69508
  010a2	83 65 88 fe	 and	 DWORD PTR $T69502[ebp], -2 ; fffffffeH
  010a6	8b f4		 mov	 esi, esp
  010a8	8d 4d ac	 lea	 ecx, DWORD PTR $T69495[ebp]
  010ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  010b1	3b f4		 cmp	 esi, esp
  010b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L69508:
  010b8	0f b6 45 cb	 movzx	 eax, BYTE PTR $T69494[ebp]
  010bc	85 c0		 test	 eax, eax
  010be	74 41		 je	 SHORT $L65221

; 266  : 	{
; 267  : 		strcpy( szBuffer,strKeyValue.c_str() );

  010c0	8b f4		 mov	 esi, esp
  010c2	8d 4d d0	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  010c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  010cb	3b f4		 cmp	 esi, esp
  010cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  010d2	50		 push	 eax
  010d3	8b 4d 14	 mov	 ecx, DWORD PTR _szBuffer$[ebp]
  010d6	51		 push	 ecx
  010d7	e8 00 00 00 00	 call	 _strcpy
  010dc	83 c4 08	 add	 esp, 8

; 268  : 		return true;

  010df	c6 45 8f 01	 mov	 BYTE PTR $T69499[ebp], 1
  010e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  010ea	8b f4		 mov	 esi, esp
  010ec	8d 4d d0	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  010ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  010f5	3b f4		 cmp	 esi, esp
  010f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  010fc	8a 45 8f	 mov	 al, BYTE PTR $T69499[ebp]
  010ff	eb 20		 jmp	 SHORT $L65215
$L65221:

; 269  : 	}
; 270  : 	return false;

  01101	c6 45 8e 00	 mov	 BYTE PTR $T69500[ebp], 0
  01105	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0110c	8b f4		 mov	 esi, esp
  0110e	8d 4d d0	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  01111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01117	3b f4		 cmp	 esi, esp
  01119	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0111e	8a 45 8e	 mov	 al, BYTE PTR $T69500[ebp]
$L65215:

; 271  : }

  01121	52		 push	 edx
  01122	8b cd		 mov	 ecx, ebp
  01124	50		 push	 eax
  01125	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69515
  0112b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  01130	58		 pop	 eax
  01131	5a		 pop	 edx
  01132	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01135	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0113c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0113f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01144	5f		 pop	 edi
  01145	5e		 pop	 esi
  01146	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  0114c	3b ec		 cmp	 ebp, esp
  0114e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01153	8b e5		 mov	 esp, ebp
  01155	5d		 pop	 ebp
  01156	c3		 ret	 0
$L69515:
  01157	01 00 00 00	 DD	 1
  0115b	00 00 00 00	 DD	 $L69514
$L69514:
  0115f	d0 ff ff ff	 DD	 -48			; ffffffd0H
  01163	1c 00 00 00	 DD	 28			; 0000001cH
  01167	00 00 00 00	 DD	 $L69511
$L69511:
  0116b	73		 DB	 115			; 00000073H
  0116c	74		 DB	 116			; 00000074H
  0116d	72		 DB	 114			; 00000072H
  0116e	4b		 DB	 75			; 0000004bH
  0116f	65		 DB	 101			; 00000065H
  01170	79		 DB	 121			; 00000079H
  01171	56		 DB	 86			; 00000056H
  01172	61		 DB	 97			; 00000061H
  01173	6c		 DB	 108			; 0000006cH
  01174	75		 DB	 117			; 00000075H
  01175	65		 DB	 101			; 00000065H
  01176	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
$L69501:
  000e5	8b f4		 mov	 esi, esp
  000e7	8d 4d d0	 lea	 ecx, DWORD PTR _strKeyValue$[ebp]
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000f0	3b f4		 cmp	 esi, esp
  000f2	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69503:
  000f7	8b 45 88	 mov	 eax, DWORD PTR $T69502[ebp]
  000fa	83 e0 01	 and	 eax, 1
  000fd	0f 84 16 00 00
	00		 je	 $L69504
  00103	83 65 88 fe	 and	 DWORD PTR $T69502[ebp], -2 ; fffffffeH
  00107	8b f4		 mov	 esi, esp
  00109	8d 4d ac	 lea	 ecx, DWORD PTR $T69495[ebp]
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00112	3b f4		 cmp	 esi, esp
  00114	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69504:
  00119	c3		 ret	 0
$L69505:
  0011a	8b 45 88	 mov	 eax, DWORD PTR $T69502[ebp]
  0011d	83 e0 02	 and	 eax, 2
  00120	0f 84 16 00 00
	00		 je	 $L69506
  00126	83 65 88 fd	 and	 DWORD PTR $T69502[ebp], -3 ; fffffffdH
  0012a	8b f4		 mov	 esi, esp
  0012c	8d 4d 90	 lea	 ecx, DWORD PTR $T69496[ebp]
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00135	3b f4		 cmp	 esi, esp
  00137	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69506:
  0013c	c3		 ret	 0
__ehhandler$?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z:
  0013d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69510
  00142	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ReadString@YL_RegInfo@@SA_NPAUHKEY__@@PBD1QADI@Z ENDP	; YL_RegInfo::ReadString
PUBLIC	?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1ABI@Z ; YL_RegInfo::WriteDWORD
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_regType$65244 = -48					; size = 4
_err$65243 = -44					; size = 4
_dw$65242 = -40						; size = 4
_hKey$65241 = -32					; size = 4
_regType$ = -24						; size = 4
_err$ = -20						; size = 4
_dw$ = -16						; size = 4
_hKey$ = -8						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
_unValue$ = 20						; size = 4
?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1ABI@Z PROC NEAR ; YL_RegInfo::WriteDWORD

; 275  : {

  01180	55		 push	 ebp
  01181	8b ec		 mov	 ebp, esp
  01183	83 ec 30	 sub	 esp, 48			; 00000030H
  01186	56		 push	 esi
  01187	57		 push	 edi
  01188	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0118b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  01190	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  01195	f3 ab		 rep stosd

; 276  : 
; 277  : 	HKEY hKey;
; 278  : 	DWORD dw = 4; 

  01197	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 4

; 279  : 	LONG err = -1; 

  0119e	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1

; 280  : 	DWORD regType = REG_DWORD; 	

  011a5	c7 45 e8 04 00
	00 00		 mov	 DWORD PTR _regType$[ebp], 4

; 281  : 
; 282  : 	err = RegOpenKeyEx(hRegKey, strRegEntry.c_str(),0, KEY_SET_VALUE, &hKey) ;

  011ac	8b f4		 mov	 esi, esp
  011ae	8d 45 f8	 lea	 eax, DWORD PTR _hKey$[ebp]
  011b1	50		 push	 eax
  011b2	6a 02		 push	 2
  011b4	6a 00		 push	 0
  011b6	8b fc		 mov	 edi, esp
  011b8	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  011bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  011c1	3b fc		 cmp	 edi, esp
  011c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  011c8	50		 push	 eax
  011c9	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  011cc	51		 push	 ecx
  011cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  011d3	3b f4		 cmp	 esi, esp
  011d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  011da	89 45 ec	 mov	 DWORD PTR _err$[ebp], eax

; 283  : 	if(err == ERROR_SUCCESS)

  011dd	83 7d ec 00	 cmp	 DWORD PTR _err$[ebp], 0
  011e1	75 73		 jne	 SHORT $L65235

; 284  : 	{ 
; 285  : 		err = RegSetValueEx(hKey, strKeyName.c_str() , 0, regType, (LPBYTE) &unValue, dw); 

  011e3	8b f4		 mov	 esi, esp
  011e5	8b 55 f0	 mov	 edx, DWORD PTR _dw$[ebp]
  011e8	52		 push	 edx
  011e9	8b 45 14	 mov	 eax, DWORD PTR _unValue$[ebp]
  011ec	50		 push	 eax
  011ed	8b 4d e8	 mov	 ecx, DWORD PTR _regType$[ebp]
  011f0	51		 push	 ecx
  011f1	6a 00		 push	 0
  011f3	8b fc		 mov	 edi, esp
  011f5	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  011f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  011fe	3b fc		 cmp	 edi, esp
  01200	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01205	50		 push	 eax
  01206	8b 55 f8	 mov	 edx, DWORD PTR _hKey$[ebp]
  01209	52		 push	 edx
  0120a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  01210	3b f4		 cmp	 esi, esp
  01212	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01217	89 45 ec	 mov	 DWORD PTR _err$[ebp], eax

; 286  : 		if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  0121a	83 7d ec 00	 cmp	 DWORD PTR _err$[ebp], 0
  0121e	75 1e		 jne	 SHORT $L65237
  01220	8b f4		 mov	 esi, esp
  01222	8b 45 f8	 mov	 eax, DWORD PTR _hKey$[ebp]
  01225	50		 push	 eax
  01226	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0122c	3b f4		 cmp	 esi, esp
  0122e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01233	85 c0		 test	 eax, eax
  01235	75 07		 jne	 SHORT $L65237

; 287  : 		{
; 288  : 			return true;

  01237	b0 01		 mov	 al, 1
  01239	e9 f6 00 00 00	 jmp	 $L65230
$L65237:

; 289  : 		}	
; 290  : 		RegCloseKey( hKey );

  0123e	8b f4		 mov	 esi, esp
  01240	8b 4d f8	 mov	 ecx, DWORD PTR _hKey$[ebp]
  01243	51		 push	 ecx
  01244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0124a	3b f4		 cmp	 esi, esp
  0124c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 291  : 	} 
; 292  : 	else if( err == ERROR_FILE_NOT_FOUND )

  01251	e9 dc 00 00 00	 jmp	 $L65238
$L65235:
  01256	83 7d ec 02	 cmp	 DWORD PTR _err$[ebp], 2
  0125a	0f 85 d2 00 00
	00		 jne	 $L65238

; 293  : 	{		
; 294  : 		if( CreateKey( hRegKey,strRegEntry) )

  01260	8b 55 0c	 mov	 edx, DWORD PTR _strRegEntry$[ebp]
  01263	52		 push	 edx
  01264	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  01267	50		 push	 eax
  01268	e8 00 00 00 00	 call	 ?CreateKey@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; YL_RegInfo::CreateKey
  0126d	83 c4 08	 add	 esp, 8
  01270	0f b6 c8	 movzx	 ecx, al
  01273	85 c9		 test	 ecx, ecx
  01275	0f 84 b7 00 00
	00		 je	 $L65238

; 295  : 		{
; 296  : 			HKEY hKey;
; 297  : 			DWORD dw = 4; 

  0127b	c7 45 d8 04 00
	00 00		 mov	 DWORD PTR _dw$65242[ebp], 4

; 298  : 			LONG err = -1; 

  01282	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR _err$65243[ebp], -1

; 299  : 			DWORD regType = REG_DWORD; 	

  01289	c7 45 d0 04 00
	00 00		 mov	 DWORD PTR _regType$65244[ebp], 4

; 300  : 
; 301  : 			err = RegOpenKeyEx(hRegKey, strRegEntry.c_str(),0, KEY_SET_VALUE, &hKey) ;

  01290	8b f4		 mov	 esi, esp
  01292	8d 55 e0	 lea	 edx, DWORD PTR _hKey$65241[ebp]
  01295	52		 push	 edx
  01296	6a 02		 push	 2
  01298	6a 00		 push	 0
  0129a	8b fc		 mov	 edi, esp
  0129c	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  0129f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  012a5	3b fc		 cmp	 edi, esp
  012a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  012ac	50		 push	 eax
  012ad	8b 45 08	 mov	 eax, DWORD PTR _hRegKey$[ebp]
  012b0	50		 push	 eax
  012b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  012b7	3b f4		 cmp	 esi, esp
  012b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  012be	89 45 d4	 mov	 DWORD PTR _err$65243[ebp], eax

; 302  : 			if(err == ERROR_SUCCESS)

  012c1	83 7d d4 00	 cmp	 DWORD PTR _err$65243[ebp], 0
  012c5	75 6b		 jne	 SHORT $L65238

; 303  : 			{ 
; 304  : 				err = RegSetValueEx(hKey, strKeyName.c_str() , 0, regType, (LPBYTE) &unValue, dw); 

  012c7	8b f4		 mov	 esi, esp
  012c9	8b 4d d8	 mov	 ecx, DWORD PTR _dw$65242[ebp]
  012cc	51		 push	 ecx
  012cd	8b 55 14	 mov	 edx, DWORD PTR _unValue$[ebp]
  012d0	52		 push	 edx
  012d1	8b 45 d0	 mov	 eax, DWORD PTR _regType$65244[ebp]
  012d4	50		 push	 eax
  012d5	6a 00		 push	 0
  012d7	8b fc		 mov	 edi, esp
  012d9	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  012dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  012e2	3b fc		 cmp	 edi, esp
  012e4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  012e9	50		 push	 eax
  012ea	8b 4d e0	 mov	 ecx, DWORD PTR _hKey$65241[ebp]
  012ed	51		 push	 ecx
  012ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  012f4	3b f4		 cmp	 esi, esp
  012f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  012fb	89 45 d4	 mov	 DWORD PTR _err$65243[ebp], eax

; 305  : 				if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  012fe	83 7d d4 00	 cmp	 DWORD PTR _err$65243[ebp], 0
  01302	75 1b		 jne	 SHORT $L65247
  01304	8b f4		 mov	 esi, esp
  01306	8b 55 e0	 mov	 edx, DWORD PTR _hKey$65241[ebp]
  01309	52		 push	 edx
  0130a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  01310	3b f4		 cmp	 esi, esp
  01312	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01317	85 c0		 test	 eax, eax
  01319	75 04		 jne	 SHORT $L65247

; 306  : 				{
; 307  : 					return true;

  0131b	b0 01		 mov	 al, 1
  0131d	eb 15		 jmp	 SHORT $L65230
$L65247:

; 308  : 				}	
; 309  : 				RegCloseKey( hKey );

  0131f	8b f4		 mov	 esi, esp
  01321	8b 45 e0	 mov	 eax, DWORD PTR _hKey$65241[ebp]
  01324	50		 push	 eax
  01325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  0132b	3b f4		 cmp	 esi, esp
  0132d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L65238:

; 310  : 			}
; 311  : 		}
; 312  : 	}
; 313  : 
; 314  : 	return false;

  01332	32 c0		 xor	 al, al
$L65230:

; 315  : }

  01334	52		 push	 edx
  01335	8b cd		 mov	 ecx, ebp
  01337	50		 push	 eax
  01338	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69521
  0133e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  01343	58		 pop	 eax
  01344	5a		 pop	 edx
  01345	5f		 pop	 edi
  01346	5e		 pop	 esi
  01347	83 c4 30	 add	 esp, 48			; 00000030H
  0134a	3b ec		 cmp	 ebp, esp
  0134c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01351	8b e5		 mov	 esp, ebp
  01353	5d		 pop	 ebp
  01354	c3		 ret	 0
$L69521:
  01355	02 00 00 00	 DD	 2
  01359	00 00 00 00	 DD	 $L69520
$L69520:
  0135d	f8 ff ff ff	 DD	 -8			; fffffff8H
  01361	04 00 00 00	 DD	 4
  01365	00 00 00 00	 DD	 $L69518
  01369	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0136d	04 00 00 00	 DD	 4
  01371	00 00 00 00	 DD	 $L69519
$L69519:
  01375	68		 DB	 104			; 00000068H
  01376	4b		 DB	 75			; 0000004bH
  01377	65		 DB	 101			; 00000065H
  01378	79		 DB	 121			; 00000079H
  01379	00		 DB	 0
$L69518:
  0137a	68		 DB	 104			; 00000068H
  0137b	4b		 DB	 75			; 0000004bH
  0137c	65		 DB	 101			; 00000065H
  0137d	79		 DB	 121			; 00000079H
  0137e	00		 DB	 0
?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1ABI@Z ENDP ; YL_RegInfo::WriteDWORD
_TEXT	ENDS
PUBLIC	?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z ; YL_RegInfo::WriteDWORD
xdata$x	SEGMENT
$T69531	DD	0ffffffffH
	DD	FLAT:$L69526
	DD	00H
	DD	FLAT:$L69527
$T69529	DD	019930520H
	DD	02H
	DD	FLAT:$T69531
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv88 = -84						; size = 4
tv82 = -80						; size = 4
tv85 = -76						; size = 4
$T69525 = -72						; size = 28
$T69524 = -44						; size = 28
$T69523 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
_unValue$ = 20						; size = 4
?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z PROC NEAR ; YL_RegInfo::WriteDWORD

; 317  : {

  01380	55		 push	 ebp
  01381	8b ec		 mov	 ebp, esp
  01383	6a ff		 push	 -1
  01385	68 00 00 00 00	 push	 __ehhandler$?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z
  0138a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  01390	50		 push	 eax
  01391	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  01398	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0139b	56		 push	 esi
  0139c	57		 push	 edi
  0139d	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  013a0	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  013a5	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  013aa	f3 ab		 rep stosd

; 318  : 	if( pszRegEntry == NULL || pszKeyName == NULL )

  013ac	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  013b0	74 06		 je	 SHORT $L65255
  013b2	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  013b6	75 07		 jne	 SHORT $L65254
$L65255:

; 319  : 	{
; 320  : 		return false;

  013b8	32 c0		 xor	 al, al
  013ba	e9 96 00 00 00	 jmp	 $L65253
$L65254:

; 321  : 	}
; 322  : 	return WriteDWORD( hRegKey,string(pszRegEntry),string(pszKeyName),unValue );

  013bf	8b f4		 mov	 esi, esp
  013c1	8b 45 10	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  013c4	50		 push	 eax
  013c5	8d 4d d4	 lea	 ecx, DWORD PTR $T69524[ebp]
  013c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  013ce	3b f4		 cmp	 esi, esp
  013d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  013d5	89 45 b4	 mov	 DWORD PTR tv85[ebp], eax
  013d8	8b 4d b4	 mov	 ecx, DWORD PTR tv85[ebp]
  013db	89 4d b0	 mov	 DWORD PTR tv82[ebp], ecx
  013de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  013e5	8b f4		 mov	 esi, esp
  013e7	8b 55 0c	 mov	 edx, DWORD PTR _pszRegEntry$[ebp]
  013ea	52		 push	 edx
  013eb	8d 4d b8	 lea	 ecx, DWORD PTR $T69525[ebp]
  013ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  013f4	3b f4		 cmp	 esi, esp
  013f6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  013fb	89 45 ac	 mov	 DWORD PTR tv88[ebp], eax
  013fe	8b 45 ac	 mov	 eax, DWORD PTR tv88[ebp]
  01401	89 45 a8	 mov	 DWORD PTR tv84[ebp], eax
  01404	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01408	8b 4d 14	 mov	 ecx, DWORD PTR _unValue$[ebp]
  0140b	51		 push	 ecx
  0140c	8b 55 b0	 mov	 edx, DWORD PTR tv82[ebp]
  0140f	52		 push	 edx
  01410	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  01413	50		 push	 eax
  01414	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  01417	51		 push	 ecx
  01418	e8 00 00 00 00	 call	 ?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1ABI@Z ; YL_RegInfo::WriteDWORD
  0141d	83 c4 10	 add	 esp, 16			; 00000010H
  01420	88 45 f3	 mov	 BYTE PTR $T69523[ebp], al
  01423	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01427	8b f4		 mov	 esi, esp
  01429	8d 4d b8	 lea	 ecx, DWORD PTR $T69525[ebp]
  0142c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01432	3b f4		 cmp	 esi, esp
  01434	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01439	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01440	8b f4		 mov	 esi, esp
  01442	8d 4d d4	 lea	 ecx, DWORD PTR $T69524[ebp]
  01445	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0144b	3b f4		 cmp	 esi, esp
  0144d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01452	8a 45 f3	 mov	 al, BYTE PTR $T69523[ebp]
$L65253:

; 323  : }

  01455	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01458	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0145f	5f		 pop	 edi
  01460	5e		 pop	 esi
  01461	83 c4 58	 add	 esp, 88			; 00000058H
  01464	3b ec		 cmp	 ebp, esp
  01466	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0146b	8b e5		 mov	 esp, ebp
  0146d	5d		 pop	 ebp
  0146e	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L69526:
  00147	8b f4		 mov	 esi, esp
  00149	8d 4d d4	 lea	 ecx, DWORD PTR $T69524[ebp]
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00152	3b f4		 cmp	 esi, esp
  00154	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69527:
  00159	8b f4		 mov	 esi, esp
  0015b	8d 4d b8	 lea	 ecx, DWORD PTR $T69525[ebp]
  0015e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00164	3b f4		 cmp	 esi, esp
  00166	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z:
  0016b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69529
  00170	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?WriteDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1ABI@Z ENDP	; YL_RegInfo::WriteDWORD
PUBLIC	?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAI@Z ; YL_RegInfo::ReadDWORD
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_regType$ = -36						; size = 4
_err$ = -28						; size = 4
_dw$ = -20						; size = 4
_hKey$ = -8						; size = 4
_hRegKey$ = 8						; size = 4
_strRegEntry$ = 12					; size = 4
_strKeyName$ = 16					; size = 4
_unValue$ = 20						; size = 4
?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAI@Z PROC NEAR ; YL_RegInfo::ReadDWORD

; 327  : {

  01470	55		 push	 ebp
  01471	8b ec		 mov	 ebp, esp
  01473	83 ec 28	 sub	 esp, 40			; 00000028H
  01476	56		 push	 esi
  01477	57		 push	 edi
  01478	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0147b	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  01480	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  01485	f3 ab		 rep stosd

; 328  : 	HKEY hKey; 
; 329  : 	DWORD dw = 4; 

  01487	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _dw$[ebp], 4

; 330  : 	LONG err ; 
; 331  : 	DWORD regType = REG_DWORD;

  0148e	c7 45 dc 04 00
	00 00		 mov	 DWORD PTR _regType$[ebp], 4

; 332  : 	
; 333  : 	err = RegOpenKeyEx(hRegKey, strRegEntry.c_str() ,0, KEY_READ, &hKey);

  01495	8b f4		 mov	 esi, esp
  01497	8d 45 f8	 lea	 eax, DWORD PTR _hKey$[ebp]
  0149a	50		 push	 eax
  0149b	68 19 00 02 00	 push	 131097			; 00020019H
  014a0	6a 00		 push	 0
  014a2	8b fc		 mov	 edi, esp
  014a4	8b 4d 0c	 mov	 ecx, DWORD PTR _strRegEntry$[ebp]
  014a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  014ad	3b fc		 cmp	 edi, esp
  014af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  014b4	50		 push	 eax
  014b5	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  014b8	51		 push	 ecx
  014b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  014bf	3b f4		 cmp	 esi, esp
  014c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  014c6	89 45 e4	 mov	 DWORD PTR _err$[ebp], eax

; 334  : 	if(err == ERROR_SUCCESS) 

  014c9	83 7d e4 00	 cmp	 DWORD PTR _err$[ebp], 0
  014cd	75 6b		 jne	 SHORT $L65269

; 335  : 	{ 
; 336  : 		err = RegQueryValueEx(hKey, strKeyName.c_str() , 0, &regType,(LPBYTE) &unValue, &dw); 

  014cf	8b f4		 mov	 esi, esp
  014d1	8d 55 ec	 lea	 edx, DWORD PTR _dw$[ebp]
  014d4	52		 push	 edx
  014d5	8b 45 14	 mov	 eax, DWORD PTR _unValue$[ebp]
  014d8	50		 push	 eax
  014d9	8d 4d dc	 lea	 ecx, DWORD PTR _regType$[ebp]
  014dc	51		 push	 ecx
  014dd	6a 00		 push	 0
  014df	8b fc		 mov	 edi, esp
  014e1	8b 4d 10	 mov	 ecx, DWORD PTR _strKeyName$[ebp]
  014e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
  014ea	3b fc		 cmp	 edi, esp
  014ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  014f1	50		 push	 eax
  014f2	8b 55 f8	 mov	 edx, DWORD PTR _hKey$[ebp]
  014f5	52		 push	 edx
  014f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  014fc	3b f4		 cmp	 esi, esp
  014fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01503	89 45 e4	 mov	 DWORD PTR _err$[ebp], eax

; 337  : 		if( err == ERROR_SUCCESS && RegCloseKey(hKey) == ERROR_SUCCESS )

  01506	83 7d e4 00	 cmp	 DWORD PTR _err$[ebp], 0
  0150a	75 1b		 jne	 SHORT $L65271
  0150c	8b f4		 mov	 esi, esp
  0150e	8b 45 f8	 mov	 eax, DWORD PTR _hKey$[ebp]
  01511	50		 push	 eax
  01512	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  01518	3b f4		 cmp	 esi, esp
  0151a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0151f	85 c0		 test	 eax, eax
  01521	75 04		 jne	 SHORT $L65271

; 338  : 		{
; 339  : 			return true;

  01523	b0 01		 mov	 al, 1
  01525	eb 15		 jmp	 SHORT $L65264
$L65271:

; 340  : 		}
; 341  : 		RegCloseKey( hKey );

  01527	8b f4		 mov	 esi, esp
  01529	8b 4d f8	 mov	 ecx, DWORD PTR _hKey$[ebp]
  0152c	51		 push	 ecx
  0152d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  01533	3b f4		 cmp	 esi, esp
  01535	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L65269:

; 342  : 	} 
; 343  : 
; 344  : 	return false;

  0153a	32 c0		 xor	 al, al
$L65264:

; 345  : }

  0153c	52		 push	 edx
  0153d	8b cd		 mov	 ecx, ebp
  0153f	50		 push	 eax
  01540	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69537
  01546	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0154b	58		 pop	 eax
  0154c	5a		 pop	 edx
  0154d	5f		 pop	 edi
  0154e	5e		 pop	 esi
  0154f	83 c4 28	 add	 esp, 40			; 00000028H
  01552	3b ec		 cmp	 ebp, esp
  01554	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01559	8b e5		 mov	 esp, ebp
  0155b	5d		 pop	 ebp
  0155c	c3		 ret	 0
$L69537:
  0155d	03 00 00 00	 DD	 3
  01561	00 00 00 00	 DD	 $L69536
$L69536:
  01565	f8 ff ff ff	 DD	 -8			; fffffff8H
  01569	04 00 00 00	 DD	 4
  0156d	00 00 00 00	 DD	 $L69533
  01571	ec ff ff ff	 DD	 -20			; ffffffecH
  01575	04 00 00 00	 DD	 4
  01579	00 00 00 00	 DD	 $L69534
  0157d	dc ff ff ff	 DD	 -36			; ffffffdcH
  01581	04 00 00 00	 DD	 4
  01585	00 00 00 00	 DD	 $L69535
$L69535:
  01589	72		 DB	 114			; 00000072H
  0158a	65		 DB	 101			; 00000065H
  0158b	67		 DB	 103			; 00000067H
  0158c	54		 DB	 84			; 00000054H
  0158d	79		 DB	 121			; 00000079H
  0158e	70		 DB	 112			; 00000070H
  0158f	65		 DB	 101			; 00000065H
  01590	00		 DB	 0
$L69534:
  01591	64		 DB	 100			; 00000064H
  01592	77		 DB	 119			; 00000077H
  01593	00		 DB	 0
$L69533:
  01594	68		 DB	 104			; 00000068H
  01595	4b		 DB	 75			; 0000004bH
  01596	65		 DB	 101			; 00000065H
  01597	79		 DB	 121			; 00000079H
  01598	00		 DB	 0
?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAI@Z ENDP ; YL_RegInfo::ReadDWORD
_TEXT	ENDS
PUBLIC	?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z	; YL_RegInfo::ReadDWORD
xdata$x	SEGMENT
$T69547	DD	0ffffffffH
	DD	FLAT:$L69542
	DD	00H
	DD	FLAT:$L69543
$T69545	DD	019930520H
	DD	02H
	DD	FLAT:$T69547
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv88 = -84						; size = 4
tv82 = -80						; size = 4
tv85 = -76						; size = 4
$T69541 = -72						; size = 28
$T69540 = -44						; size = 28
$T69539 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hRegKey$ = 8						; size = 4
_pszRegEntry$ = 12					; size = 4
_pszKeyName$ = 16					; size = 4
_unValue$ = 20						; size = 4
?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z PROC NEAR ; YL_RegInfo::ReadDWORD

; 348  : {

  015a0	55		 push	 ebp
  015a1	8b ec		 mov	 ebp, esp
  015a3	6a ff		 push	 -1
  015a5	68 00 00 00 00	 push	 __ehhandler$?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z
  015aa	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  015b0	50		 push	 eax
  015b1	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  015b8	83 ec 4c	 sub	 esp, 76			; 0000004cH
  015bb	56		 push	 esi
  015bc	57		 push	 edi
  015bd	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  015c0	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  015c5	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  015ca	f3 ab		 rep stosd

; 349  : 	if( pszRegEntry == NULL || pszKeyName == NULL )

  015cc	83 7d 0c 00	 cmp	 DWORD PTR _pszRegEntry$[ebp], 0
  015d0	74 06		 je	 SHORT $L65279
  015d2	83 7d 10 00	 cmp	 DWORD PTR _pszKeyName$[ebp], 0
  015d6	75 07		 jne	 SHORT $L65278
$L65279:

; 350  : 	{
; 351  : 		return false;

  015d8	32 c0		 xor	 al, al
  015da	e9 96 00 00 00	 jmp	 $L65277
$L65278:

; 352  : 	}
; 353  : 	return ReadDWORD( hRegKey,string(pszRegEntry),string(pszKeyName),unValue );

  015df	8b f4		 mov	 esi, esp
  015e1	8b 45 10	 mov	 eax, DWORD PTR _pszKeyName$[ebp]
  015e4	50		 push	 eax
  015e5	8d 4d d4	 lea	 ecx, DWORD PTR $T69540[ebp]
  015e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  015ee	3b f4		 cmp	 esi, esp
  015f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  015f5	89 45 b4	 mov	 DWORD PTR tv85[ebp], eax
  015f8	8b 4d b4	 mov	 ecx, DWORD PTR tv85[ebp]
  015fb	89 4d b0	 mov	 DWORD PTR tv82[ebp], ecx
  015fe	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  01605	8b f4		 mov	 esi, esp
  01607	8b 55 0c	 mov	 edx, DWORD PTR _pszRegEntry$[ebp]
  0160a	52		 push	 edx
  0160b	8d 4d b8	 lea	 ecx, DWORD PTR $T69541[ebp]
  0160e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  01614	3b f4		 cmp	 esi, esp
  01616	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0161b	89 45 ac	 mov	 DWORD PTR tv88[ebp], eax
  0161e	8b 45 ac	 mov	 eax, DWORD PTR tv88[ebp]
  01621	89 45 a8	 mov	 DWORD PTR tv84[ebp], eax
  01624	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  01628	8b 4d 14	 mov	 ecx, DWORD PTR _unValue$[ebp]
  0162b	51		 push	 ecx
  0162c	8b 55 b0	 mov	 edx, DWORD PTR tv82[ebp]
  0162f	52		 push	 edx
  01630	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  01633	50		 push	 eax
  01634	8b 4d 08	 mov	 ecx, DWORD PTR _hRegKey$[ebp]
  01637	51		 push	 ecx
  01638	e8 00 00 00 00	 call	 ?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1AAI@Z ; YL_RegInfo::ReadDWORD
  0163d	83 c4 10	 add	 esp, 16			; 00000010H
  01640	88 45 f3	 mov	 BYTE PTR $T69539[ebp], al
  01643	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  01647	8b f4		 mov	 esi, esp
  01649	8d 4d b8	 lea	 ecx, DWORD PTR $T69541[ebp]
  0164c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  01652	3b f4		 cmp	 esi, esp
  01654	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01659	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01660	8b f4		 mov	 esi, esp
  01662	8d 4d d4	 lea	 ecx, DWORD PTR $T69540[ebp]
  01665	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0166b	3b f4		 cmp	 esi, esp
  0166d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01672	8a 45 f3	 mov	 al, BYTE PTR $T69539[ebp]
$L65277:

; 354  : }

  01675	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01678	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0167f	5f		 pop	 edi
  01680	5e		 pop	 esi
  01681	83 c4 58	 add	 esp, 88			; 00000058H
  01684	3b ec		 cmp	 ebp, esp
  01686	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0168b	8b e5		 mov	 esp, ebp
  0168d	5d		 pop	 ebp
  0168e	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
$L69542:
  00175	8b f4		 mov	 esi, esp
  00177	8d 4d d4	 lea	 ecx, DWORD PTR $T69540[ebp]
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00180	3b f4		 cmp	 esi, esp
  00182	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69543:
  00187	8b f4		 mov	 esi, esp
  00189	8d 4d b8	 lea	 ecx, DWORD PTR $T69541[ebp]
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00192	3b f4		 cmp	 esi, esp
  00194	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z:
  00199	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69545
  0019e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?ReadDWORD@YL_RegInfo@@SA_NPAUHKEY__@@PBD1AAI@Z ENDP	; YL_RegInfo::ReadDWORD
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T69557	DD	0ffffffffH
	DD	FLAT:$L69551
	DD	00H
	DD	FLAT:$L69550
$T69555	DD	019930520H
	DD	02H
	DD	FLAT:$T69557
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T69552 = -44						; size = 4
$T69549 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69552[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00038	50		 push	 eax
  00039	8d 4d d8	 lea	 ecx, DWORD PTR $T69549[ebp]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  0004c	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  0004f	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00052	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00059	8b f4		 mov	 esi, esp
  0005b	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  0005e	52		 push	 edx
  0005f	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b f4		 mov	 esi, esp
  00071	50		 push	 eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b 45 d4	 mov	 eax, DWORD PTR $T69552[ebp]
  00085	83 c8 01	 or	 eax, 1
  00088	89 45 d4	 mov	 DWORD PTR $T69552[ebp], eax
  0008b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0008f	8b f4		 mov	 esi, esp
  00091	8d 4d d8	 lea	 ecx, DWORD PTR $T69549[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	83 c4 34	 add	 esp, 52			; 00000034H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69550:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69549[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69551:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69552[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69553
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69552[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69553:
  00034	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69555
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69569	DD	0ffffffffH
	DD	FLAT:$L69563
	DD	00H
	DD	FLAT:$L69562
$T69567	DD	019930520H
	DD	02H
	DD	FLAT:$T69569
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T69564 = -44						; size = 4
$T69561 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69564[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00038	50		 push	 eax
  00039	8d 4d d8	 lea	 ecx, DWORD PTR $T69561[ebp]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  0004c	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  0004f	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00052	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00059	8b f4		 mov	 esi, esp
  0005b	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  0005e	52		 push	 edx
  0005f	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b f4		 mov	 esi, esp
  00071	50		 push	 eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b 45 d4	 mov	 eax, DWORD PTR $T69564[ebp]
  00085	83 c8 01	 or	 eax, 1
  00088	89 45 d4	 mov	 DWORD PTR $T69564[ebp], eax
  0008b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0008f	8b f4		 mov	 esi, esp
  00091	8d 4d d8	 lea	 ecx, DWORD PTR $T69561[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	83 c4 34	 add	 esp, 52			; 00000034H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69562:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69561[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69563:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69564[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69565
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69564[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69565:
  00034	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69567
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69581	DD	0ffffffffH
	DD	FLAT:$L69575
	DD	00H
	DD	FLAT:$L69574
$T69579	DD	019930520H
	DD	02H
	DD	FLAT:$T69581
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T69576 = -44						; size = 4
$T69573 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 1
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69576[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	8a 45 0c	 mov	 al, BYTE PTR __Left$[ebp]
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	8d 4d d8	 lea	 ecx, DWORD PTR $T69573[ebp]
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
  00044	3b f4		 cmp	 esi, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  0004e	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00051	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  00054	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0005b	8b f4		 mov	 esi, esp
  0005d	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00060	52		 push	 edx
  00061	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b f4		 mov	 esi, esp
  00073	50		 push	 eax
  00074	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b 45 d4	 mov	 eax, DWORD PTR $T69576[ebp]
  00087	83 c8 01	 or	 eax, 1
  0008a	89 45 d4	 mov	 DWORD PTR $T69576[ebp], eax
  0008d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00091	8b f4		 mov	 esi, esp
  00093	8d 4d d8	 lea	 ecx, DWORD PTR $T69573[ebp]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0009c	3b f4		 cmp	 esi, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  000a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	83 c4 34	 add	 esp, 52			; 00000034H
  000b5	3b ec		 cmp	 ebp, esp
  000b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69574:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69573[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69575:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69576[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69577
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69576[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69577:
  00034	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69579
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69593	DD	0ffffffffH
	DD	FLAT:$L69587
	DD	00H
	DD	FLAT:$L69586
$T69591	DD	019930520H
	DD	02H
	DD	FLAT:$T69593
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T69588 = -44						; size = 4
$T69585 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69588[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00038	50		 push	 eax
  00039	8d 4d d8	 lea	 ecx, DWORD PTR $T69585[ebp]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  0004c	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  0004f	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00052	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00059	8b f4		 mov	 esi, esp
  0005b	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  0005e	52		 push	 edx
  0005f	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b f4		 mov	 esi, esp
  00071	50		 push	 eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b 45 d4	 mov	 eax, DWORD PTR $T69588[ebp]
  00085	83 c8 01	 or	 eax, 1
  00088	89 45 d4	 mov	 DWORD PTR $T69588[ebp], eax
  0008b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0008f	8b f4		 mov	 esi, esp
  00091	8d 4d d8	 lea	 ecx, DWORD PTR $T69585[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	83 c4 34	 add	 esp, 52			; 00000034H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69586:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69585[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69587:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69588[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69589
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69588[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69589:
  00034	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69591
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69605	DD	0ffffffffH
	DD	FLAT:$L69599
	DD	00H
	DD	FLAT:$L69598
$T69603	DD	019930520H
	DD	02H
	DD	FLAT:$T69605
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T69600 = -44						; size = 4
$T69597 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69600[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00038	50		 push	 eax
  00039	8d 4d d8	 lea	 ecx, DWORD PTR $T69597[ebp]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  0004c	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  0004f	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00052	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00059	8b f4		 mov	 esi, esp
  0005b	8a 55 10	 mov	 dl, BYTE PTR __Right$[ebp]
  0005e	52		 push	 edx
  0005f	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b f4		 mov	 esi, esp
  00071	50		 push	 eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b 45 d4	 mov	 eax, DWORD PTR $T69600[ebp]
  00085	83 c8 01	 or	 eax, 1
  00088	89 45 d4	 mov	 DWORD PTR $T69600[ebp], eax
  0008b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0008f	8b f4		 mov	 esi, esp
  00091	8d 4d d8	 lea	 ecx, DWORD PTR $T69597[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	83 c4 34	 add	 esp, 52			; 00000034H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69598:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69597[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69599:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69600[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69601
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69600[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69601:
  00034	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69603
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69617	DD	0ffffffffH
	DD	FLAT:$L69611
	DD	00H
	DD	FLAT:$L69610
$T69615	DD	019930520H
	DD	02H
	DD	FLAT:$T69617
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T69612 = -44						; size = 4
$T69609 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 21   : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69612[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00038	50		 push	 eax
  00039	8d 4d d8	 lea	 ecx, DWORD PTR $T69609[ebp]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  0004c	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  0004f	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00052	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00059	8b f4		 mov	 esi, esp
  0005b	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  0005e	52		 push	 edx
  0005f	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b f4		 mov	 esi, esp
  00071	50		 push	 eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b 45 d4	 mov	 eax, DWORD PTR $T69612[ebp]
  00085	83 c8 01	 or	 eax, 1
  00088	89 45 d4	 mov	 DWORD PTR $T69612[ebp], eax
  0008b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0008f	8b f4		 mov	 esi, esp
  00091	8d 4d d8	 lea	 ecx, DWORD PTR $T69609[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	83 c4 34	 add	 esp, 52			; 00000034H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69610:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69609[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69611:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69612[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69613
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69612[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69613:
  00034	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69615
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69629	DD	0ffffffffH
	DD	FLAT:$L69623
	DD	00H
	DD	FLAT:$L69622
$T69627	DD	019930520H
	DD	02H
	DD	FLAT:$T69629
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T69624 = -44						; size = 4
$T69621 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69624[ebp], 0

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00038	50		 push	 eax
  00039	8d 4d d8	 lea	 ecx, DWORD PTR $T69621[ebp]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  0004c	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  0004f	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00052	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00059	8b f4		 mov	 esi, esp
  0005b	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  0005e	52		 push	 edx
  0005f	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b f4		 mov	 esi, esp
  00071	50		 push	 eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b 45 d4	 mov	 eax, DWORD PTR $T69624[ebp]
  00085	83 c8 01	 or	 eax, 1
  00088	89 45 d4	 mov	 DWORD PTR $T69624[ebp], eax
  0008b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0008f	8b f4		 mov	 esi, esp
  00091	8d 4d d8	 lea	 ecx, DWORD PTR $T69621[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 33   : 	}

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	83 c4 34	 add	 esp, 52			; 00000034H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69622:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69621[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69623:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69624[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69625
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69624[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69625:
  00034	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69627
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69641	DD	0ffffffffH
	DD	FLAT:$L69635
	DD	00H
	DD	FLAT:$L69634
$T69639	DD	019930520H
	DD	02H
	DD	FLAT:$T69641
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT
tv78 = -52						; size = 4
tv83 = -48						; size = 4
$T69636 = -44						; size = 4
$T69633 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 2
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 41   : 	{	// return character + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69636[ebp], 0

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	66 8b 45 0c	 mov	 ax, WORD PTR __Left$[ebp]
  00039	50		 push	 eax
  0003a	6a 01		 push	 1
  0003c	8d 4d d8	 lea	 ecx, DWORD PTR $T69633[ebp]
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  0004f	8b 4d d0	 mov	 ecx, DWORD PTR tv83[ebp]
  00052	89 4d cc	 mov	 DWORD PTR tv78[ebp], ecx
  00055	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0005c	8b f4		 mov	 esi, esp
  0005e	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00061	52		 push	 edx
  00062	8b 4d cc	 mov	 ecx, DWORD PTR tv78[ebp]
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b f4		 mov	 esi, esp
  00074	50		 push	 eax
  00075	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b 45 d4	 mov	 eax, DWORD PTR $T69636[ebp]
  00088	83 c8 01	 or	 eax, 1
  0008b	89 45 d4	 mov	 DWORD PTR $T69636[ebp], eax
  0008e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00092	8b f4		 mov	 esi, esp
  00094	8d 4d d8	 lea	 ecx, DWORD PTR $T69633[ebp]
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 43   : 	}

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	83 c4 34	 add	 esp, 52			; 00000034H
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69634:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69633[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69635:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69636[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69637
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69636[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69637:
  00034	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69639
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69653	DD	0ffffffffH
	DD	FLAT:$L69647
	DD	00H
	DD	FLAT:$L69646
$T69651	DD	019930520H
	DD	02H
	DD	FLAT:$T69653
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T69648 = -44						; size = 4
$T69645 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69648[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00038	50		 push	 eax
  00039	8d 4d d8	 lea	 ecx, DWORD PTR $T69645[ebp]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  0004c	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  0004f	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00052	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00059	8b f4		 mov	 esi, esp
  0005b	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  0005e	52		 push	 edx
  0005f	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b f4		 mov	 esi, esp
  00071	50		 push	 eax
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0007b	3b f4		 cmp	 esi, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b 45 d4	 mov	 eax, DWORD PTR $T69648[ebp]
  00085	83 c8 01	 or	 eax, 1
  00088	89 45 d4	 mov	 DWORD PTR $T69648[ebp], eax
  0008b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0008f	8b f4		 mov	 esi, esp
  00091	8d 4d d8	 lea	 ecx, DWORD PTR $T69645[ebp]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	83 c4 34	 add	 esp, 52			; 00000034H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69646:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69645[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69647:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69648[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69649
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69648[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69649:
  00034	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69651
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69665	DD	0ffffffffH
	DD	FLAT:$L69659
	DD	00H
	DD	FLAT:$L69658
$T69663	DD	019930520H
	DD	02H
	DD	FLAT:$T69665
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T69660 = -44						; size = 4
$T69657 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 2
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 61   : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 28	 sub	 esp, 40			; 00000028H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T69660[ebp], 0

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00033	8b f4		 mov	 esi, esp
  00035	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00038	50		 push	 eax
  00039	8d 4d d8	 lea	 ecx, DWORD PTR $T69657[ebp]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	89 45 d0	 mov	 DWORD PTR tv82[ebp], eax
  0004c	8b 4d d0	 mov	 ecx, DWORD PTR tv82[ebp]
  0004f	89 4d cc	 mov	 DWORD PTR tv77[ebp], ecx
  00052	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00059	8b f4		 mov	 esi, esp
  0005b	66 8b 55 10	 mov	 dx, WORD PTR __Right$[ebp]
  0005f	52		 push	 edx
  00060	8b 4d cc	 mov	 ecx, DWORD PTR tv77[ebp]
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
  00069	3b f4		 cmp	 esi, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b f4		 mov	 esi, esp
  00072	50		 push	 eax
  00073	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0007c	3b f4		 cmp	 esi, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b 45 d4	 mov	 eax, DWORD PTR $T69660[ebp]
  00086	83 c8 01	 or	 eax, 1
  00089	89 45 d4	 mov	 DWORD PTR $T69660[ebp], eax
  0008c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00090	8b f4		 mov	 esi, esp
  00092	8d 4d d8	 lea	 ecx, DWORD PTR $T69657[ebp]
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0009b	3b f4		 cmp	 esi, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : 	}

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	83 c4 34	 add	 esp, 52			; 00000034H
  000b4	3b ec		 cmp	 ebp, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69658:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d d8	 lea	 ecx, DWORD PTR $T69657[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69659:
  00012	8b 45 d4	 mov	 eax, DWORD PTR $T69660[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	0f 84 16 00 00
	00		 je	 $L69661
  0001e	83 65 d4 fe	 and	 DWORD PTR $T69660[ebp], -2 ; fffffffeH
  00022	8b f4		 mov	 esi, esp
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
  0002d	3b f4		 cmp	 esi, esp
  0002f	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
$L69661:
  00034	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69663
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
EXTRN	__imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_??1locale@std@@QAE@XZ:NEAR
EXTRN	__imp_?to_char_type@?$char_traits@D@std@@SADABH@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@D@std@@SAHXZ:NEAR
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:NEAR
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:NEAR
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:NEAR
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB:DWORD
EXTRN	__imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69685	DD	0ffffffffH
	DD	FLAT:$L69676
	DD	00H
	DD	FLAT:$L69677
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T69687	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L69675
$T69686	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T69687
$T69679	DD	019930520H
	DD	04H
	DD	FLAT:$T69685
	DD	01H
	DD	FLAT:$T69686
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv207 = -128						; size = 1
tv206 = -127						; size = 1
tv205 = -126						; size = 1
tv204 = -125						; size = 1
tv203 = -124						; size = 4
tv202 = -120						; size = 4
tv201 = -116						; size = 4
tv200 = -112						; size = 4
tv199 = -108						; size = 4
tv198 = -104						; size = 4
tv135 = -100						; size = 4
tv197 = -96						; size = 4
tv196 = -92						; size = 4
tv195 = -88						; size = 4
tv194 = -84						; size = 4
tv189 = -80						; size = 4
tv65 = -76						; size = 4
$T69673 = -72						; size = 4
$T69672 = -68						; size = 4
$T69669 = -64						; size = 4
__Meta$68143 = -56					; size = 4
__Size$68140 = -48					; size = 4
__Ctype_fac$68137 = -44					; size = 4
__Ok$ = -36						; size = 8
__Changed$ = -21					; size = 1
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 70	 sub	 esp, 112		; 00000070H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8d 7d 80	 lea	 edi, DWORD PTR [ebp-128]
  00022	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00038	c6 45 eb 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0003c	6a 00		 push	 0
  0003e	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00041	50		 push	 eax
  00042	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00051	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00054	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  00059	0f b6 c8	 movzx	 ecx, al
  0005c	85 c9		 test	 ecx, ecx
  0005e	0f 84 87 02 00
	00		 je	 $L69674

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00064	8b f4		 mov	 esi, esp
  00066	8d 55 c0	 lea	 edx, DWORD PTR $T69669[ebp]
  00069	52		 push	 edx
  0006a	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00072	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00075	8b ca		 mov	 ecx, edx
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  00087	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]
  0008a	89 45 b0	 mov	 DWORD PTR tv189[ebp], eax
  0008d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00091	8b 4d b0	 mov	 ecx, DWORD PTR tv189[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0009a	83 c4 04	 add	 esp, 4
  0009d	89 45 d4	 mov	 DWORD PTR __Ctype_fac$68137[ebp], eax
  000a0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  000a4	8b f4		 mov	 esi, esp
  000a6	8d 4d c0	 lea	 ecx, DWORD PTR $T69669[ebp]
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ
  000af	3b f4		 cmp	 esi, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 438  : 		_Str.erase();

  000b6	8b f4		 mov	 esi, esp
  000b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  000be	8b 02		 mov	 eax, DWORD PTR [edx]
  000c0	50		 push	 eax
  000c1	6a 00		 push	 0
  000c3	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
  000cc	3b f4		 cmp	 esi, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000d3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000d7	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000da	8b 11		 mov	 edx, DWORD PTR [ecx]
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000df	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000e2	8b f4		 mov	 esi, esp
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f1	89 45 ac	 mov	 DWORD PTR tv194[ebp], eax
  000f4	83 7d ac 00	 cmp	 DWORD PTR tv194[ebp], 0
  000f8	7e 61		 jle	 SHORT $L69670
  000fa	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ff	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00102	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00105	8b f4		 mov	 esi, esp
  00107	8b ca		 mov	 ecx, edx
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0010f	3b f4		 cmp	 esi, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00116	89 45 a8	 mov	 DWORD PTR tv195[ebp], eax
  00119	8b f4		 mov	 esi, esp
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00124	3b f4		 cmp	 esi, esp
  00126	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012b	89 45 a4	 mov	 DWORD PTR tv196[ebp], eax
  0012e	8b 45 a8	 mov	 eax, DWORD PTR tv195[ebp]
  00131	3b 45 a4	 cmp	 eax, DWORD PTR tv196[ebp]
  00134	73 25		 jae	 SHORT $L69670
  00136	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00139	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0013e	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00141	8b f4		 mov	 esi, esp
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00149	3b f4		 cmp	 esi, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	89 45 a0	 mov	 DWORD PTR tv197[ebp], eax
  00153	8b 45 a0	 mov	 eax, DWORD PTR tv197[ebp]
  00156	89 45 9c	 mov	 DWORD PTR tv135[ebp], eax
  00159	eb 1b		 jmp	 SHORT $L69671
$L69670:
  0015b	8b f4		 mov	 esi, esp
  0015d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00166	3b f4		 cmp	 esi, esp
  00168	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016d	89 45 98	 mov	 DWORD PTR tv198[ebp], eax
  00170	8b 4d 98	 mov	 ecx, DWORD PTR tv198[ebp]
  00173	89 4d 9c	 mov	 DWORD PTR tv135[ebp], ecx
$L69671:
  00176	8b 55 9c	 mov	 edx, DWORD PTR tv135[ebp]
  00179	89 55 d0	 mov	 DWORD PTR __Size$68140[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  0017c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0017f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00181	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00184	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00187	8b f4		 mov	 esi, esp
  00189	8b ca		 mov	 ecx, edx
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00191	3b f4		 cmp	 esi, esp
  00193	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00198	89 45 94	 mov	 DWORD PTR tv199[ebp], eax
  0019b	8b f4		 mov	 esi, esp
  0019d	8b 4d 94	 mov	 ecx, DWORD PTR tv199[ebp]
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  001a6	3b f4		 cmp	 esi, esp
  001a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ad	89 45 90	 mov	 DWORD PTR tv200[ebp], eax
  001b0	8b 45 90	 mov	 eax, DWORD PTR tv200[ebp]
  001b3	89 45 c8	 mov	 DWORD PTR __Meta$68143[ebp], eax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  001b6	eb 41		 jmp	 SHORT $L68144
$L68145:
  001b8	8b 4d d0	 mov	 ecx, DWORD PTR __Size$68140[ebp]
  001bb	83 e9 01	 sub	 ecx, 1
  001be	89 4d d0	 mov	 DWORD PTR __Size$68140[ebp], ecx
  001c1	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001c4	8b 02		 mov	 eax, DWORD PTR [edx]
  001c6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001c9	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  001cc	8b f4		 mov	 esi, esp
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001d4	3b f4		 cmp	 esi, esp
  001d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001db	89 45 8c	 mov	 DWORD PTR tv201[ebp], eax
  001de	8b f4		 mov	 esi, esp
  001e0	8b 4d 8c	 mov	 ecx, DWORD PTR tv201[ebp]
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  001e9	3b f4		 cmp	 esi, esp
  001eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f0	89 45 88	 mov	 DWORD PTR tv202[ebp], eax
  001f3	8b 4d 88	 mov	 ecx, DWORD PTR tv202[ebp]
  001f6	89 4d c8	 mov	 DWORD PTR __Meta$68143[ebp], ecx
$L68144:
  001f9	83 7d d0 00	 cmp	 DWORD PTR __Size$68140[ebp], 0
  001fd	0f 86 c0 00 00
	00		 jbe	 $L68146

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  00203	8b f4		 mov	 esi, esp
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0020b	3b f4		 cmp	 esi, esp
  0020d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00212	89 45 84	 mov	 DWORD PTR tv203[ebp], eax
  00215	8b 55 84	 mov	 edx, DWORD PTR tv203[ebp]
  00218	89 55 bc	 mov	 DWORD PTR $T69672[ebp], edx
  0021b	8b f4		 mov	 esi, esp
  0021d	8d 45 c8	 lea	 eax, DWORD PTR __Meta$68143[ebp]
  00220	50		 push	 eax
  00221	8d 4d bc	 lea	 ecx, DWORD PTR $T69672[ebp]
  00224	51		 push	 ecx
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  0022b	83 c4 08	 add	 esp, 8
  0022e	3b f4		 cmp	 esi, esp
  00230	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00235	88 45 83	 mov	 BYTE PTR tv204[ebp], al
  00238	0f b6 55 83	 movzx	 edx, BYTE PTR tv204[ebp]
  0023c	85 d2		 test	 edx, edx
  0023e	74 0b		 je	 SHORT $L68148

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  00240	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00243	83 c8 01	 or	 eax, 1
  00246	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  00249	eb 78		 jmp	 SHORT $L68146
$L68148:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  0024b	8b f4		 mov	 esi, esp
  0024d	8d 4d c8	 lea	 ecx, DWORD PTR __Meta$68143[ebp]
  00250	51		 push	 ecx
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  00257	83 c4 04	 add	 esp, 4
  0025a	3b f4		 cmp	 esi, esp
  0025c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00261	88 45 82	 mov	 BYTE PTR tv205[ebp], al
  00264	8b f4		 mov	 esi, esp
  00266	8a 55 82	 mov	 dl, BYTE PTR tv205[ebp]
  00269	52		 push	 edx
  0026a	6a 48		 push	 72			; 00000048H
  0026c	8b 4d d4	 mov	 ecx, DWORD PTR __Ctype_fac$68137[ebp]
  0026f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@D@std@@QBE_NFD@Z
  00275	3b f4		 cmp	 esi, esp
  00277	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0027c	88 45 81	 mov	 BYTE PTR tv206[ebp], al
  0027f	0f b6 45 81	 movzx	 eax, BYTE PTR tv206[ebp]
  00283	85 c0		 test	 eax, eax
  00285	74 02		 je	 SHORT $L68150

; 454  : 				break;	// whitespace, quit

  00287	eb 3a		 jmp	 SHORT $L68146
$L68150:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  00289	8b f4		 mov	 esi, esp
  0028b	8d 4d c8	 lea	 ecx, DWORD PTR __Meta$68143[ebp]
  0028e	51		 push	 ecx
  0028f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  00295	83 c4 04	 add	 esp, 4
  00298	3b f4		 cmp	 esi, esp
  0029a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029f	88 45 80	 mov	 BYTE PTR tv207[ebp], al
  002a2	8b f4		 mov	 esi, esp
  002a4	8a 55 80	 mov	 dl, BYTE PTR tv207[ebp]
  002a7	52		 push	 edx
  002a8	6a 01		 push	 1
  002aa	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  002ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
  002b3	3b f4		 cmp	 esi, esp
  002b5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 458  : 				_Changed = true;

  002ba	c6 45 eb 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  002be	e9 f5 fe ff ff	 jmp	 $L68145
$L68146:
  002c3	eb 26		 jmp	 SHORT $L69674
$L69675:

; 460  : 		_CATCH_IO_(_Istr)

  002c5	8b f4		 mov	 esi, esp
  002c7	6a 01		 push	 1
  002c9	6a 04		 push	 4
  002cb	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  002ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d0	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  002d3	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d6	8b ca		 mov	 ecx, edx
  002d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  002de	3b f4		 cmp	 esi, esp
  002e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e5	b8 00 00 00 00	 mov	 eax, $L69674
  002ea	c3		 ret	 0
$L69674:
  002eb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  002f2	8b f4		 mov	 esi, esp
  002f4	6a 00		 push	 0
  002f6	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  002f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002fb	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  002fe	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00301	8b ca		 mov	 ecx, edx
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  00309	3b f4		 cmp	 esi, esp
  0030b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 464  : 	if (!_Changed)

  00310	0f b6 45 eb	 movzx	 eax, BYTE PTR __Changed$[ebp]
  00314	85 c0		 test	 eax, eax
  00316	75 09		 jne	 SHORT $L68152

; 465  : 		_State |= ios_base::failbit;

  00318	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  0031b	83 c9 02	 or	 ecx, 2
  0031e	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L68152:

; 466  : 	_Istr.setstate(_State);

  00321	8b f4		 mov	 esi, esp
  00323	6a 00		 push	 0
  00325	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00328	52		 push	 edx
  00329	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0032c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032e	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00331	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00334	8b ca		 mov	 ecx, edx
  00336	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0033c	3b f4		 cmp	 esi, esp
  0033e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 467  : 	return (_Istr);

  00343	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00346	89 45 b8	 mov	 DWORD PTR $T69673[ebp], eax
  00349	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00350	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00353	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00358	8b 45 b8	 mov	 eax, DWORD PTR $T69673[ebp]

; 468  : 	}

  0035b	52		 push	 edx
  0035c	8b cd		 mov	 ecx, ebp
  0035e	50		 push	 eax
  0035f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69684
  00365	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0036a	58		 pop	 eax
  0036b	5a		 pop	 edx
  0036c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0036f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00376	5f		 pop	 edi
  00377	5e		 pop	 esi
  00378	5b		 pop	 ebx
  00379	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  0037f	3b ec		 cmp	 ebp, esp
  00381	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00386	8b e5		 mov	 esp, ebp
  00388	5d		 pop	 ebp
  00389	c3		 ret	 0
$L69684:
  0038a	02 00 00 00	 DD	 2
  0038e	00 00 00 00	 DD	 $L69683
$L69683:
  00392	dc ff ff ff	 DD	 -36			; ffffffdcH
  00396	08 00 00 00	 DD	 8
  0039a	00 00 00 00	 DD	 $L69680
  0039e	c8 ff ff ff	 DD	 -56			; ffffffc8H
  003a2	04 00 00 00	 DD	 4
  003a6	00 00 00 00	 DD	 $L69681
$L69681:
  003aa	5f		 DB	 95			; 0000005fH
  003ab	4d		 DB	 77			; 0000004dH
  003ac	65		 DB	 101			; 00000065H
  003ad	74		 DB	 116			; 00000074H
  003ae	61		 DB	 97			; 00000061H
  003af	00		 DB	 0
$L69680:
  003b0	5f		 DB	 95			; 0000005fH
  003b1	4f		 DB	 79			; 0000004fH
  003b2	6b		 DB	 107			; 0000006bH
  003b3	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69676:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
$L69677:
  00008	8b f4		 mov	 esi, esp
  0000a	8d 4d c0	 lea	 ecx, DWORD PTR $T69669[ebp]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ
  00013	3b f4		 cmp	 esi, esp
  00015	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69679
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T69697	DD	0ffffffffH
	DD	FLAT:$L69693
$T69695	DD	019930520H
	DD	01H
	DD	FLAT:$T69697
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00027	50		 push	 eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00037	8b f4		 mov	 esi, esp
  00039	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00055	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00069	5e		 pop	 esi
  0006a	83 c4 10	 add	 esp, 16			; 00000010H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69693:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69695
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0001e	8b f4		 mov	 esi, esp
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	85 c0		 test	 eax, eax
  0002f	74 2f		 je	 SHORT $L66496

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003d	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00040	8b f4		 mov	 esi, esp
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b f4		 mov	 esi, esp
  00051	8b c8		 mov	 ecx, eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L66496:

; 61   : 			}

  00060	5e		 pop	 esi
  00061	83 c4 04	 add	 esp, 4
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00015	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00026	8b f4		 mov	 esi, esp
  00028	8b c8		 mov	 ecx, eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	85 c0		 test	 eax, eax
  00039	74 2f		 je	 SHORT $L67497

; 54   : 				_Myistr.rdbuf()->_Lock();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00047	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004a	8b f4		 mov	 esi, esp
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b f4		 mov	 esi, esp
  0005b	8b c8		 mov	 ecx, eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67497:

; 55   : 			}

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	5e		 pop	 esi
  0006e	83 c4 04	 add	 esp, 4
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@@
PUBLIC	__CTA2?AVbad_cast@@
PUBLIC	??_R0?AVbad_cast@@@8				; bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
EXTRN	__imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:NEAR
EXTRN	__CxxThrowException@8:NEAR
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??0bad_cast@@QAE@ABV0@@Z:NEAR			; bad_cast::bad_cast
EXTRN	??1bad_cast@@UAE@XZ:NEAR			; bad_cast::~bad_cast
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:NEAR
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:NEAR
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:NEAR
EXTRN	__imp_?_Incref@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Register@facet@locale@std@@QAEXXZ:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_??0bad_cast@@QAE@PBD@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69715	DD	0ffffffffH
	DD	FLAT:$L69707
$T69709	DD	019930520H
	DD	01H
	DD	FLAT:$T69715
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT
__TI2?AVbad_cast@@ DD 00H
	DD	FLAT:??1bad_cast@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@@@8 DD FLAT:??_7type_info@@6B@		; bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T69706 = -64						; size = 4
$T69704 = -60						; size = 12
__Pfmod$68066 = -48					; size = 4
__Pf$ = -44						; size = 4
__Id$ = -40						; size = 4
__Psave$ = -32						; size = 4
__Lock$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 34	 sub	 esp, 52			; 00000034H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00020	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0002c	8b f4		 mov	 esi, esp
  0002e	6a 00		 push	 0
  00030	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  0004c	89 45 e0	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  0004f	8b f4		 mov	 esi, esp
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	89 45 d8	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00067	8b f4		 mov	 esi, esp
  00069	8b 4d d8	 mov	 ecx, DWORD PTR __Id$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	89 45 d4	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00080	83 7d d4 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00084	74 05		 je	 SHORT $L68049

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  00086	e9 86 00 00 00	 jmp	 $L68050
$L68049:
  0008b	83 7d e0 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  0008f	74 08		 je	 SHORT $L68051

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00091	8b 55 e0	 mov	 edx, DWORD PTR __Psave$[ebp]
  00094	89 55 d4	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00097	eb 78		 jmp	 SHORT $L68050
$L68051:
  00099	8b f4		 mov	 esi, esp
  0009b	8d 45 e0	 lea	 eax, DWORD PTR __Psave$[ebp]
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
  000a5	83 c4 04	 add	 esp, 4
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	83 f8 ff	 cmp	 eax, -1
  000b2	75 25		 jne	 SHORT $L68054

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  000b4	8b f4		 mov	 esi, esp
  000b6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  000bb	8d 4d c4	 lea	 ecx, DWORD PTR $T69704[ebp]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  000c4	3b f4		 cmp	 esi, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  000d0	8d 4d c4	 lea	 ecx, DWORD PTR $T69704[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 __CxxThrowException@8
$L68054:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  000d9	8b 55 e0	 mov	 edx, DWORD PTR __Psave$[ebp]
  000dc	89 55 d4	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  000df	8b 45 e0	 mov	 eax, DWORD PTR __Psave$[ebp]
  000e2	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000e7	8b 4d e0	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000ea	89 4d d0	 mov	 DWORD PTR __Pfmod$68066[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ed	8b f4		 mov	 esi, esp
  000ef	8b 4d d0	 mov	 ecx, DWORD PTR __Pfmod$68066[ebp]
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ
  000f8	3b f4		 cmp	 esi, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 343  : 		_Pfmod->_Register();

  000ff	8b f4		 mov	 esi, esp
  00101	8b 4d d0	 mov	 ecx, DWORD PTR __Pfmod$68066[ebp]
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
  0010a	3b f4		 cmp	 esi, esp
  0010c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L68050:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00111	8b 55 d4	 mov	 edx, DWORD PTR __Pf$[ebp]
  00114	89 55 c0	 mov	 DWORD PTR $T69706[ebp], edx
  00117	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0011e	8b f4		 mov	 esi, esp
  00120	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00129	3b f4		 cmp	 esi, esp
  0012b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00130	8b 45 c0	 mov	 eax, DWORD PTR $T69706[ebp]
$L69703:

; 347  : 	}

  00133	52		 push	 edx
  00134	8b cd		 mov	 ecx, ebp
  00136	50		 push	 eax
  00137	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69714
  0013d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00142	58		 pop	 eax
  00143	5a		 pop	 edx
  00144	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00147	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	83 c4 40	 add	 esp, 64			; 00000040H
  00153	3b ec		 cmp	 ebp, esp
  00155	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
$L69714:
  0015e	02 00 00 00	 DD	 2
  00162	00 00 00 00	 DD	 $L69713
$L69713:
  00166	ec ff ff ff	 DD	 -20			; ffffffecH
  0016a	04 00 00 00	 DD	 4
  0016e	00 00 00 00	 DD	 $L69710
  00172	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00176	04 00 00 00	 DD	 4
  0017a	00 00 00 00	 DD	 $L69711
$L69711:
  0017e	5f		 DB	 95			; 0000005fH
  0017f	50		 DB	 80			; 00000050H
  00180	73		 DB	 115			; 00000073H
  00181	61		 DB	 97			; 00000061H
  00182	76		 DB	 118			; 00000076H
  00183	65		 DB	 101			; 00000065H
  00184	00		 DB	 0
$L69710:
  00185	5f		 DB	 95			; 0000005fH
  00186	4c		 DB	 76			; 0000004cH
  00187	6f		 DB	 111			; 0000006fH
  00188	63		 DB	 99			; 00000063H
  00189	6b		 DB	 107			; 0000006bH
  0018a	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69707:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69709
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00004	8b f4		 mov	 esi, esp
  00006	6a 0a		 push	 10			; 0000000aH
  00008	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00010	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00013	8b ca		 mov	 ecx, edx
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	50		 push	 eax
  00023	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00033	5e		 pop	 esi
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
EXTRN	__imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69734	DD	0ffffffffH
	DD	FLAT:$L69725
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T69736	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L69724
$T69735	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T69736
$T69727	DD	019930520H
	DD	03H
	DD	FLAT:$T69734
	DD	01H
	DD	FLAT:$T69735
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
tv175 = -113						; size = 1
tv174 = -112						; size = 4
tv173 = -108						; size = 4
tv172 = -104						; size = 4
tv171 = -98						; size = 1
tv170 = -97						; size = 1
tv169 = -96						; size = 4
tv168 = -92						; size = 4
tv167 = -88						; size = 4
tv166 = -84						; size = 4
tv165 = -80						; size = 4
tv65 = -76						; size = 4
$T69722 = -72						; size = 4
$T69721 = -68						; size = 4
__Meta$68163 = -60					; size = 4
__Metadelim$68162 = -48					; size = 4
__Ok$ = -36						; size = 8
__Changed$ = -21					; size = 1
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 64	 sub	 esp, 100		; 00000064H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8d 7d 8c	 lea	 edi, DWORD PTR [ebp-116]
  00022	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00038	c6 45 eb 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0003c	6a 01		 push	 1
  0003e	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00041	50		 push	 eax
  00042	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00051	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00054	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  00059	0f b6 c8	 movzx	 ecx, al
  0005c	85 c9		 test	 ecx, ecx
  0005e	0f 84 f6 01 00
	00		 je	 $L69723

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00064	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00068	8b f4		 mov	 esi, esp
  0006a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  00085	8b f4		 mov	 esi, esp
  00087	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  0008a	51		 push	 ecx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z
  00091	83 c4 04	 add	 esp, 4
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0009e	8b 55 b4	 mov	 edx, DWORD PTR tv65[ebp]
  000a1	89 55 d0	 mov	 DWORD PTR __Metadelim$68162[ebp], edx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  000a4	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a9	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000ac	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000af	8b f4		 mov	 esi, esp
  000b1	8b ca		 mov	 ecx, edx
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	89 45 b0	 mov	 DWORD PTR tv165[ebp], eax
  000c3	8b f4		 mov	 esi, esp
  000c5	8b 4d b0	 mov	 ecx, DWORD PTR tv165[ebp]
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	89 45 ac	 mov	 DWORD PTR tv166[ebp], eax
  000d8	8b 45 ac	 mov	 eax, DWORD PTR tv166[ebp]
  000db	89 45 c4	 mov	 DWORD PTR __Meta$68163[ebp], eax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000de	eb 38		 jmp	 SHORT $L68164
$L68165:
  000e0	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e5	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000e8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000eb	8b f4		 mov	 esi, esp
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000f3	3b f4		 cmp	 esi, esp
  000f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fa	89 45 a8	 mov	 DWORD PTR tv167[ebp], eax
  000fd	8b f4		 mov	 esi, esp
  000ff	8b 4d a8	 mov	 ecx, DWORD PTR tv167[ebp]
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  00108	3b f4		 cmp	 esi, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	89 45 a4	 mov	 DWORD PTR tv168[ebp], eax
  00112	8b 45 a4	 mov	 eax, DWORD PTR tv168[ebp]
  00115	89 45 c4	 mov	 DWORD PTR __Meta$68163[ebp], eax
$L68164:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00118	8b f4		 mov	 esi, esp
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  00120	3b f4		 cmp	 esi, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	89 45 a0	 mov	 DWORD PTR tv169[ebp], eax
  0012a	8b 4d a0	 mov	 ecx, DWORD PTR tv169[ebp]
  0012d	89 4d bc	 mov	 DWORD PTR $T69721[ebp], ecx
  00130	8b f4		 mov	 esi, esp
  00132	8d 55 c4	 lea	 edx, DWORD PTR __Meta$68163[ebp]
  00135	52		 push	 edx
  00136	8d 45 bc	 lea	 eax, DWORD PTR $T69721[ebp]
  00139	50		 push	 eax
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00140	83 c4 08	 add	 esp, 8
  00143	3b f4		 cmp	 esi, esp
  00145	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014a	88 45 9f	 mov	 BYTE PTR tv170[ebp], al
  0014d	0f b6 4d 9f	 movzx	 ecx, BYTE PTR tv170[ebp]
  00151	85 c9		 test	 ecx, ecx
  00153	74 0e		 je	 SHORT $L68168

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  00155	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00158	83 ca 01	 or	 edx, 1
  0015b	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  0015e	e9 d1 00 00 00	 jmp	 $L68166
$L68168:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  00163	8b f4		 mov	 esi, esp
  00165	8d 45 d0	 lea	 eax, DWORD PTR __Metadelim$68162[ebp]
  00168	50		 push	 eax
  00169	8d 4d c4	 lea	 ecx, DWORD PTR __Meta$68163[ebp]
  0016c	51		 push	 ecx
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00173	83 c4 08	 add	 esp, 8
  00176	3b f4		 cmp	 esi, esp
  00178	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017d	88 45 9e	 mov	 BYTE PTR tv171[ebp], al
  00180	0f b6 55 9e	 movzx	 edx, BYTE PTR tv171[ebp]
  00184	85 d2		 test	 edx, edx
  00186	74 37		 je	 SHORT $L68170

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00188	c6 45 eb 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  0018c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0018f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00191	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00194	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00197	8b f4		 mov	 esi, esp
  00199	8b ca		 mov	 ecx, edx
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001a1	3b f4		 cmp	 esi, esp
  001a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a8	89 45 98	 mov	 DWORD PTR tv172[ebp], eax
  001ab	8b f4		 mov	 esi, esp
  001ad	8b 4d 98	 mov	 ecx, DWORD PTR tv172[ebp]
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  001b6	3b f4		 cmp	 esi, esp
  001b8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 501  : 				break;

  001bd	eb 75		 jmp	 SHORT $L68166
$L68170:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  001bf	8b f4		 mov	 esi, esp
  001c1	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  001ca	3b f4		 cmp	 esi, esp
  001cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d1	89 45 94	 mov	 DWORD PTR tv173[ebp], eax
  001d4	8b f4		 mov	 esi, esp
  001d6	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  001df	3b f4		 cmp	 esi, esp
  001e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e6	89 45 90	 mov	 DWORD PTR tv174[ebp], eax
  001e9	8b 45 94	 mov	 eax, DWORD PTR tv173[ebp]
  001ec	3b 45 90	 cmp	 eax, DWORD PTR tv174[ebp]
  001ef	77 0b		 ja	 SHORT $L68172

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  001f1	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  001f4	83 c9 02	 or	 ecx, 2
  001f7	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  001fa	eb 38		 jmp	 SHORT $L68166
$L68172:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  001fc	8b f4		 mov	 esi, esp
  001fe	8d 55 c4	 lea	 edx, DWORD PTR __Meta$68163[ebp]
  00201	52		 push	 edx
  00202	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
  00208	83 c4 04	 add	 esp, 4
  0020b	3b f4		 cmp	 esi, esp
  0020d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00212	88 45 8f	 mov	 BYTE PTR tv175[ebp], al
  00215	8b f4		 mov	 esi, esp
  00217	8a 45 8f	 mov	 al, BYTE PTR tv175[ebp]
  0021a	50		 push	 eax
  0021b	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0021e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
  00224	3b f4		 cmp	 esi, esp
  00226	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 511  : 				_Changed = true;

  0022b	c6 45 eb 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  0022f	e9 ac fe ff ff	 jmp	 $L68165
$L68166:
  00234	eb 24		 jmp	 SHORT $L69723
$L69724:

; 513  : 		_CATCH_IO_(_Istr)

  00236	8b f4		 mov	 esi, esp
  00238	6a 01		 push	 1
  0023a	6a 04		 push	 4
  0023c	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0023f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00241	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00244	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0024d	3b f4		 cmp	 esi, esp
  0024f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00254	b8 00 00 00 00	 mov	 eax, $L69723
  00259	c3		 ret	 0
$L69723:
  0025a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  00261	0f b6 45 eb	 movzx	 eax, BYTE PTR __Changed$[ebp]
  00265	85 c0		 test	 eax, eax
  00267	75 09		 jne	 SHORT $L68174

; 517  : 		_State |= ios_base::failbit;

  00269	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  0026c	83 c9 02	 or	 ecx, 2
  0026f	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L68174:

; 518  : 	_Istr.setstate(_State);

  00272	8b f4		 mov	 esi, esp
  00274	6a 00		 push	 0
  00276	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00279	52		 push	 edx
  0027a	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0027d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027f	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00282	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00285	8b ca		 mov	 ecx, edx
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0028d	3b f4		 cmp	 esi, esp
  0028f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 519  : 	return (_Istr);

  00294	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00297	89 45 b8	 mov	 DWORD PTR $T69722[ebp], eax
  0029a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  002a1	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  002a4	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  002a9	8b 45 b8	 mov	 eax, DWORD PTR $T69722[ebp]

; 520  : 	}

  002ac	52		 push	 edx
  002ad	8b cd		 mov	 ecx, ebp
  002af	50		 push	 eax
  002b0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69733
  002b6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002bb	58		 pop	 eax
  002bc	5a		 pop	 edx
  002bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002c7	5f		 pop	 edi
  002c8	5e		 pop	 esi
  002c9	5b		 pop	 ebx
  002ca	83 c4 74	 add	 esp, 116		; 00000074H
  002cd	3b ec		 cmp	 ebp, esp
  002cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002d4	8b e5		 mov	 esp, ebp
  002d6	5d		 pop	 ebp
  002d7	c3		 ret	 0
$L69733:
  002d8	03 00 00 00	 DD	 3
  002dc	00 00 00 00	 DD	 $L69732
$L69732:
  002e0	dc ff ff ff	 DD	 -36			; ffffffdcH
  002e4	08 00 00 00	 DD	 8
  002e8	00 00 00 00	 DD	 $L69728
  002ec	d0 ff ff ff	 DD	 -48			; ffffffd0H
  002f0	04 00 00 00	 DD	 4
  002f4	00 00 00 00	 DD	 $L69729
  002f8	c4 ff ff ff	 DD	 -60			; ffffffc4H
  002fc	04 00 00 00	 DD	 4
  00300	00 00 00 00	 DD	 $L69730
$L69730:
  00304	5f		 DB	 95			; 0000005fH
  00305	4d		 DB	 77			; 0000004dH
  00306	65		 DB	 101			; 00000065H
  00307	74		 DB	 116			; 00000074H
  00308	61		 DB	 97			; 00000061H
  00309	00		 DB	 0
$L69729:
  0030a	5f		 DB	 95			; 0000005fH
  0030b	4d		 DB	 77			; 0000004dH
  0030c	65		 DB	 101			; 00000065H
  0030d	74		 DB	 116			; 00000074H
  0030e	61		 DB	 97			; 00000061H
  0030f	64		 DB	 100			; 00000064H
  00310	65		 DB	 101			; 00000065H
  00311	6c		 DB	 108			; 0000006cH
  00312	69		 DB	 105			; 00000069H
  00313	6d		 DB	 109			; 0000006dH
  00314	00		 DB	 0
$L69728:
  00315	5f		 DB	 95			; 0000005fH
  00316	4f		 DB	 79			; 0000004fH
  00317	6b		 DB	 107			; 0000006bH
  00318	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69725:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69727
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z:NEAR
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:NEAR
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:NEAR
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69758	DD	0ffffffffH
	DD	FLAT:$L69751
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T69760	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L69750
$T69759	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T69760
$T69753	DD	019930520H
	DD	03H
	DD	FLAT:$T69758
	DD	01H
	DD	FLAT:$T69759
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv221 = -137						; size = 1
tv220 = -136						; size = 4
tv219 = -132						; size = 4
tv218 = -128						; size = 4
tv217 = -122						; size = 1
tv216 = -121						; size = 1
tv215 = -120						; size = 4
tv214 = -116						; size = 4
tv213 = -112						; size = 4
tv212 = -108						; size = 4
tv211 = -101						; size = 1
tv210 = -100						; size = 4
tv209 = -96						; size = 4
tv208 = -92						; size = 4
tv207 = -85						; size = 1
tv83 = -84						; size = 4
tv81 = -80						; size = 4
$T69748 = -76						; size = 4
$T69747 = -72						; size = 4
$T69746 = -68						; size = 4
$T69745 = -64						; size = 4
$T69744 = -60						; size = 4
$T69743 = -56						; size = 4
$T69742 = -52						; size = 4
__Count$68197 = -48					; size = 4
__Ok$ = -40						; size = 8
__Pad$ = -28						; size = 4
__Size$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 7c	 sub	 esp, 124		; 0000007cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-140]
  00025	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00034	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  0003b	8b f4		 mov	 esi, esp
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  00046	3b f4		 cmp	 esi, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	89 45 e8	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00050	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00058	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0005b	8b f4		 mov	 esi, esp
  0005d	8b ca		 mov	 ecx, edx
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	85 c0		 test	 eax, eax
  0006e	7e 45		 jle	 SHORT $L69740
  00070	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00073	8b 08		 mov	 ecx, DWORD PTR [eax]
  00075	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00078	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0007b	8b f4		 mov	 esi, esp
  0007d	8b ca		 mov	 ecx, edx
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00085	3b f4		 cmp	 esi, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	3b 45 e8	 cmp	 eax, DWORD PTR __Size$[ebp]
  0008f	76 24		 jbe	 SHORT $L69740
  00091	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00099	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0009c	8b f4		 mov	 esi, esp
  0009e	8b ca		 mov	 ecx, edx
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000a6	3b f4		 cmp	 esi, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	2b 45 e8	 sub	 eax, DWORD PTR __Size$[ebp]
  000b0	89 45 b0	 mov	 DWORD PTR tv81[ebp], eax
  000b3	eb 07		 jmp	 SHORT $L69741
$L69740:
  000b5	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L69741:
  000bc	8b 45 b0	 mov	 eax, DWORD PTR tv81[ebp]
  000bf	89 45 e4	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  000c2	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c5	51		 push	 ecx
  000c6	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000c9	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000ce	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  000d5	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000d8	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000dd	0f b6 d0	 movzx	 edx, al
  000e0	85 d2		 test	 edx, edx
  000e2	75 0e		 jne	 SHORT $L68186

; 550  : 		_State |= ios_base::badbit;

  000e4	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000e7	83 c8 04	 or	 eax, 4
  000ea	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000ed	e9 d8 02 00 00	 jmp	 $L69749
$L68186:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000f2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000f6	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000f9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000fe	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00101	8b f4		 mov	 esi, esp
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  00109	3b f4		 cmp	 esi, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	89 45 ac	 mov	 DWORD PTR tv83[ebp], eax
  00113	8b 45 ac	 mov	 eax, DWORD PTR tv83[ebp]
  00116	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0011b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0011e	0f 84 bb 00 00
	00		 je	 $L68189

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00124	eb 09		 jmp	 SHORT $L68190
$L68191:
  00126	8b 4d e4	 mov	 ecx, DWORD PTR __Pad$[ebp]
  00129	83 e9 01	 sub	 ecx, 1
  0012c	89 4d e4	 mov	 DWORD PTR __Pad$[ebp], ecx
$L68190:
  0012f	83 7d e4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00133	0f 86 a6 00 00
	00		 jbe	 $L68189

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  00139	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0013c	8b 02		 mov	 eax, DWORD PTR [edx]
  0013e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00141	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00144	8b f4		 mov	 esi, esp
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0014c	3b f4		 cmp	 esi, esp
  0014e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00153	88 45 ab	 mov	 BYTE PTR tv207[ebp], al
  00156	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00159	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015b	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0015e	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00161	8b f4		 mov	 esi, esp
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00169	3b f4		 cmp	 esi, esp
  0016b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00170	89 45 a4	 mov	 DWORD PTR tv208[ebp], eax
  00173	8b f4		 mov	 esi, esp
  00175	8a 45 ab	 mov	 al, BYTE PTR tv207[ebp]
  00178	50		 push	 eax
  00179	8b 4d a4	 mov	 ecx, DWORD PTR tv208[ebp]
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00182	3b f4		 cmp	 esi, esp
  00184	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00189	89 45 a0	 mov	 DWORD PTR tv209[ebp], eax
  0018c	8b 4d a0	 mov	 ecx, DWORD PTR tv209[ebp]
  0018f	89 4d cc	 mov	 DWORD PTR $T69742[ebp], ecx
  00192	8b f4		 mov	 esi, esp
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  0019a	3b f4		 cmp	 esi, esp
  0019c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a1	89 45 9c	 mov	 DWORD PTR tv210[ebp], eax
  001a4	8b 55 9c	 mov	 edx, DWORD PTR tv210[ebp]
  001a7	89 55 c8	 mov	 DWORD PTR $T69743[ebp], edx
  001aa	8b f4		 mov	 esi, esp
  001ac	8d 45 cc	 lea	 eax, DWORD PTR $T69742[ebp]
  001af	50		 push	 eax
  001b0	8d 4d c8	 lea	 ecx, DWORD PTR $T69743[ebp]
  001b3	51		 push	 ecx
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  001ba	83 c4 08	 add	 esp, 8
  001bd	3b f4		 cmp	 esi, esp
  001bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c4	88 45 9b	 mov	 BYTE PTR tv211[ebp], al
  001c7	0f b6 55 9b	 movzx	 edx, BYTE PTR tv211[ebp]
  001cb	85 d2		 test	 edx, edx
  001cd	74 0b		 je	 SHORT $L68195

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  001cf	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001d2	83 c8 04	 or	 eax, 4
  001d5	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  001d8	eb 05		 jmp	 SHORT $L68189
$L68195:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  001da	e9 47 ff ff ff	 jmp	 $L68191
$L68189:
  001df	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  001e3	0f 85 c2 00 00
	00		 jne	 $L68196

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  001e9	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Count$68197[ebp], 0
  001f0	eb 09		 jmp	 SHORT $L68198
$L68199:
  001f2	8b 4d d0	 mov	 ecx, DWORD PTR __Count$68197[ebp]
  001f5	83 c1 01	 add	 ecx, 1
  001f8	89 4d d0	 mov	 DWORD PTR __Count$68197[ebp], ecx
$L68198:
  001fb	8b 55 d0	 mov	 edx, DWORD PTR __Count$68197[ebp]
  001fe	3b 55 e8	 cmp	 edx, DWORD PTR __Size$[ebp]
  00201	0f 83 a4 00 00
	00		 jae	 $L68196

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  00207	8b f4		 mov	 esi, esp
  00209	8b 45 d0	 mov	 eax, DWORD PTR __Count$68197[ebp]
  0020c	50		 push	 eax
  0020d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
  00216	3b f4		 cmp	 esi, esp
  00218	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0021d	89 45 94	 mov	 DWORD PTR tv212[ebp], eax
  00220	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00223	8b 11		 mov	 edx, DWORD PTR [ecx]
  00225	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00228	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0022b	8b f4		 mov	 esi, esp
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00233	3b f4		 cmp	 esi, esp
  00235	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023a	89 45 90	 mov	 DWORD PTR tv213[ebp], eax
  0023d	8b f4		 mov	 esi, esp
  0023f	8b 45 94	 mov	 eax, DWORD PTR tv212[ebp]
  00242	8a 08		 mov	 cl, BYTE PTR [eax]
  00244	51		 push	 ecx
  00245	8b 4d 90	 mov	 ecx, DWORD PTR tv213[ebp]
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0024e	3b f4		 cmp	 esi, esp
  00250	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00255	89 45 8c	 mov	 DWORD PTR tv214[ebp], eax
  00258	8b 55 8c	 mov	 edx, DWORD PTR tv214[ebp]
  0025b	89 55 c4	 mov	 DWORD PTR $T69744[ebp], edx
  0025e	8b f4		 mov	 esi, esp
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  00266	3b f4		 cmp	 esi, esp
  00268	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0026d	89 45 88	 mov	 DWORD PTR tv215[ebp], eax
  00270	8b 45 88	 mov	 eax, DWORD PTR tv215[ebp]
  00273	89 45 c0	 mov	 DWORD PTR $T69745[ebp], eax
  00276	8b f4		 mov	 esi, esp
  00278	8d 4d c4	 lea	 ecx, DWORD PTR $T69744[ebp]
  0027b	51		 push	 ecx
  0027c	8d 55 c0	 lea	 edx, DWORD PTR $T69745[ebp]
  0027f	52		 push	 edx
  00280	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  00286	83 c4 08	 add	 esp, 8
  00289	3b f4		 cmp	 esi, esp
  0028b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00290	88 45 87	 mov	 BYTE PTR tv216[ebp], al
  00293	0f b6 45 87	 movzx	 eax, BYTE PTR tv216[ebp]
  00297	85 c0		 test	 eax, eax
  00299	74 0b		 je	 SHORT $L68203

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  0029b	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  0029e	83 c9 04	 or	 ecx, 4
  002a1	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  002a4	eb 05		 jmp	 SHORT $L68196
$L68203:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  002a6	e9 47 ff ff ff	 jmp	 $L68199
$L68196:
  002ab	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  002af	0f 85 d1 00 00
	00		 jne	 $L68204

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  002b5	eb 09		 jmp	 SHORT $L68205
$L68206:
  002b7	8b 55 e4	 mov	 edx, DWORD PTR __Pad$[ebp]
  002ba	83 ea 01	 sub	 edx, 1
  002bd	89 55 e4	 mov	 DWORD PTR __Pad$[ebp], edx
$L68205:
  002c0	83 7d e4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  002c4	0f 86 bc 00 00
	00		 jbe	 $L68204

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  002ca	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002cf	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002d2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d5	8b f4		 mov	 esi, esp
  002d7	8b ca		 mov	 ecx, edx
  002d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  002df	3b f4		 cmp	 esi, esp
  002e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e6	88 45 86	 mov	 BYTE PTR tv217[ebp], al
  002e9	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ee	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002f1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002f4	8b f4		 mov	 esi, esp
  002f6	8b ca		 mov	 ecx, edx
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002fe	3b f4		 cmp	 esi, esp
  00300	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00305	89 45 80	 mov	 DWORD PTR tv218[ebp], eax
  00308	8b f4		 mov	 esi, esp
  0030a	8a 45 86	 mov	 al, BYTE PTR tv217[ebp]
  0030d	50		 push	 eax
  0030e	8b 4d 80	 mov	 ecx, DWORD PTR tv218[ebp]
  00311	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00317	3b f4		 cmp	 esi, esp
  00319	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0031e	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv219[ebp], eax
  00324	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv219[ebp]
  0032a	89 4d bc	 mov	 DWORD PTR $T69746[ebp], ecx
  0032d	8b f4		 mov	 esi, esp
  0032f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
  00335	3b f4		 cmp	 esi, esp
  00337	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0033c	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv220[ebp], eax
  00342	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv220[ebp]
  00348	89 55 b8	 mov	 DWORD PTR $T69747[ebp], edx
  0034b	8b f4		 mov	 esi, esp
  0034d	8d 45 bc	 lea	 eax, DWORD PTR $T69746[ebp]
  00350	50		 push	 eax
  00351	8d 4d b8	 lea	 ecx, DWORD PTR $T69747[ebp]
  00354	51		 push	 ecx
  00355	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
  0035b	83 c4 08	 add	 esp, 8
  0035e	3b f4		 cmp	 esi, esp
  00360	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00365	88 85 77 ff ff
	ff		 mov	 BYTE PTR tv221[ebp], al
  0036b	0f b6 95 77 ff
	ff ff		 movzx	 edx, BYTE PTR tv221[ebp]
  00372	85 d2		 test	 edx, edx
  00374	74 0b		 je	 SHORT $L68210

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  00376	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00379	83 c8 04	 or	 eax, 4
  0037c	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  0037f	eb 05		 jmp	 SHORT $L68204
$L68210:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  00381	e9 31 ff ff ff	 jmp	 $L68206
$L68204:
  00386	8b f4		 mov	 esi, esp
  00388	6a 00		 push	 0
  0038a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0038d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0038f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00392	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00395	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  0039b	3b f4		 cmp	 esi, esp
  0039d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a2	eb 26		 jmp	 SHORT $L69749
$L69750:

; 581  : 		_CATCH_IO_(_Ostr)

  003a4	8b f4		 mov	 esi, esp
  003a6	6a 01		 push	 1
  003a8	6a 04		 push	 4
  003aa	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  003af	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  003b2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  003b5	8b ca		 mov	 ecx, edx
  003b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003bd	3b f4		 cmp	 esi, esp
  003bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c4	b8 00 00 00 00	 mov	 eax, $L69749
  003c9	c3		 ret	 0
$L69749:
  003ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  003d1	8b f4		 mov	 esi, esp
  003d3	6a 00		 push	 0
  003d5	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  003d8	50		 push	 eax
  003d9	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003dc	8b 11		 mov	 edx, DWORD PTR [ecx]
  003de	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003e1	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  003e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003ea	3b f4		 cmp	 esi, esp
  003ec	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 585  : 	return (_Ostr);

  003f1	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003f4	89 45 b4	 mov	 DWORD PTR $T69748[ebp], eax
  003f7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  003fe	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00401	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00406	8b 45 b4	 mov	 eax, DWORD PTR $T69748[ebp]

; 586  : 	}

  00409	52		 push	 edx
  0040a	8b cd		 mov	 ecx, ebp
  0040c	50		 push	 eax
  0040d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69757
  00413	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00418	58		 pop	 eax
  00419	5a		 pop	 edx
  0041a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0041d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00424	5f		 pop	 edi
  00425	5e		 pop	 esi
  00426	5b		 pop	 ebx
  00427	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  0042d	3b ec		 cmp	 ebp, esp
  0042f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00434	8b e5		 mov	 esp, ebp
  00436	5d		 pop	 ebp
  00437	c3		 ret	 0
$L69757:
  00438	01 00 00 00	 DD	 1
  0043c	00 00 00 00	 DD	 $L69756
$L69756:
  00440	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00444	08 00 00 00	 DD	 8
  00448	00 00 00 00	 DD	 $L69754
$L69754:
  0044c	5f		 DB	 95			; 0000005fH
  0044d	4f		 DB	 79			; 0000004fH
  0044e	6b		 DB	 107			; 0000006bH
  0044f	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69751:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69753
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:NEAR
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T69768	DD	0ffffffffH
	DD	FLAT:$L69764
$T69766	DD	019930520H
	DD	01H
	DD	FLAT:$T69768
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00027	50		 push	 eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0003f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00042	8b f4		 mov	 esi, esp
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	0f b6 c0	 movzx	 eax, al
  00054	85 c0		 test	 eax, eax
  00056	74 4b		 je	 SHORT $L67506
  00058	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0005b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00060	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00063	8b f4		 mov	 esi, esp
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	85 c0		 test	 eax, eax
  00074	74 2d		 je	 SHORT $L67506

; 90   : 				_Ostr.tie()->flush();

  00076	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00081	8b f4		 mov	 esi, esp
  00083	8b ca		 mov	 ecx, edx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0008b	3b f4		 cmp	 esi, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b f4		 mov	 esi, esp
  00094	8b c8		 mov	 ecx, eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0009c	3b f4		 cmp	 esi, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67506:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  000a3	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000ab	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000ae	8b f4		 mov	 esi, esp
  000b0	8b ca		 mov	 ecx, edx
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  000b8	3b f4		 cmp	 esi, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  000c5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d9	5e		 pop	 esi
  000da	83 c4 10	 add	 esp, 16			; 00000010H
  000dd	3b ec		 cmp	 ebp, esp
  000df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69764:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69766
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69776	DD	0ffffffffH
	DD	FLAT:$L69772
$T69774	DD	019930520H
	DD	01H
	DD	FLAT:$T69776
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  0002b	8b f4		 mov	 esi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	85 c0		 test	 eax, eax
  0003f	75 14		 jne	 SHORT $L67508

; 99   : 				this->_Myostr._Osfx();

  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00046	8b f4		 mov	 esi, esp
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67508:

; 100  : 			}

  00055	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006e	5e		 pop	 esi
  0006f	83 c4 10	 add	 esp, 16			; 00000010H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69772:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69774
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00015	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00026	8b f4		 mov	 esi, esp
  00028	8b c8		 mov	 ecx, eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	85 c0		 test	 eax, eax
  00039	74 2f		 je	 SHORT $L67771

; 70   : 				_Myostr.rdbuf()->_Lock();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00047	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004a	8b f4		 mov	 esi, esp
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b f4		 mov	 esi, esp
  0005b	8b c8		 mov	 ecx, eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67771:

; 71   : 			}

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	5e		 pop	 esi
  0006e	83 c4 04	 add	 esp, 4
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0001e	8b f4		 mov	 esi, esp
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	85 c0		 test	 eax, eax
  0002f	74 2f		 je	 SHORT $L67774

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003d	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00040	8b f4		 mov	 esi, esp
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b f4		 mov	 esi, esp
  00051	8b c8		 mov	 ecx, eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67774:

; 77   : 			}

  00060	5e		 pop	 esi
  00061	83 c4 04	 add	 esp, 4
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ:NEAR
EXTRN	__imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB:DWORD
EXTRN	__imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z:NEAR
EXTRN	__imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?is@?$ctype@_W@std@@QBE_NF_W@Z:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z:NEAR
EXTRN	__imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z:NEAR
EXTRN	__imp_?eof@?$char_traits@_W@std@@SAGXZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T69799	DD	0ffffffffH
	DD	FLAT:$L69790
	DD	00H
	DD	FLAT:$L69791
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T69801	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L69789
$T69800	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T69801
$T69793	DD	019930520H
	DD	04H
	DD	FLAT:$T69799
	DD	01H
	DD	FLAT:$T69800
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv207 = -128						; size = 2
tv206 = -125						; size = 1
tv205 = -124						; size = 2
tv204 = -121						; size = 1
tv203 = -120						; size = 2
tv202 = -118						; size = 2
tv201 = -116						; size = 4
tv200 = -110						; size = 2
tv199 = -108						; size = 4
tv198 = -104						; size = 4
tv135 = -100						; size = 4
tv197 = -96						; size = 4
tv196 = -92						; size = 4
tv195 = -88						; size = 4
tv194 = -84						; size = 4
tv189 = -80						; size = 4
tv65 = -76						; size = 4
$T69787 = -72						; size = 4
$T69786 = -66						; size = 2
$T69783 = -64						; size = 4
__Meta$68227 = -56					; size = 2
__Size$68224 = -48					; size = 4
__Ctype_fac$68221 = -44					; size = 4
__Ok$ = -36						; size = 8
__Changed$ = -21					; size = 1
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 70	 sub	 esp, 112		; 00000070H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8d 7d 80	 lea	 edi, DWORD PTR [ebp-128]
  00022	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;

  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 432  : 	bool _Changed = false;

  00038	c6 45 eb 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0003c	6a 00		 push	 0
  0003e	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00041	50		 push	 eax
  00042	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 434  : 
; 435  : 	if (_Ok)

  00051	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00054	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  00059	0f b6 c8	 movzx	 ecx, al
  0005c	85 c9		 test	 ecx, ecx
  0005e	0f 84 94 02 00
	00		 je	 $L69788

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00064	8b f4		 mov	 esi, esp
  00066	8d 55 c0	 lea	 edx, DWORD PTR $T69783[ebp]
  00069	52		 push	 edx
  0006a	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00072	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00075	8b ca		 mov	 ecx, edx
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  00087	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]
  0008a	89 45 b0	 mov	 DWORD PTR tv189[ebp], eax
  0008d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00091	8b 4d b0	 mov	 ecx, DWORD PTR tv189[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  0009a	83 c4 04	 add	 esp, 4
  0009d	89 45 d4	 mov	 DWORD PTR __Ctype_fac$68221[ebp], eax
  000a0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  000a4	8b f4		 mov	 esi, esp
  000a6	8d 4d c0	 lea	 ecx, DWORD PTR $T69783[ebp]
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ
  000af	3b f4		 cmp	 esi, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 438  : 		_Str.erase();

  000b6	8b f4		 mov	 esi, esp
  000b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  000be	8b 02		 mov	 eax, DWORD PTR [edx]
  000c0	50		 push	 eax
  000c1	6a 00		 push	 0
  000c3	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
  000cc	3b f4		 cmp	 esi, esp
  000ce	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 439  : 
; 440  : 		_TRY_IO_BEGIN

  000d3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  000d7	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000da	8b 11		 mov	 edx, DWORD PTR [ecx]
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000df	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000e2	8b f4		 mov	 esi, esp
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000ea	3b f4		 cmp	 esi, esp
  000ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f1	89 45 ac	 mov	 DWORD PTR tv194[ebp], eax
  000f4	83 7d ac 00	 cmp	 DWORD PTR tv194[ebp], 0
  000f8	7e 61		 jle	 SHORT $L69784
  000fa	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ff	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00102	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00105	8b f4		 mov	 esi, esp
  00107	8b ca		 mov	 ecx, edx
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  0010f	3b f4		 cmp	 esi, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00116	89 45 a8	 mov	 DWORD PTR tv195[ebp], eax
  00119	8b f4		 mov	 esi, esp
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00124	3b f4		 cmp	 esi, esp
  00126	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012b	89 45 a4	 mov	 DWORD PTR tv196[ebp], eax
  0012e	8b 45 a8	 mov	 eax, DWORD PTR tv195[ebp]
  00131	3b 45 a4	 cmp	 eax, DWORD PTR tv196[ebp]
  00134	73 25		 jae	 SHORT $L69784
  00136	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00139	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0013e	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00141	8b f4		 mov	 esi, esp
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00149	3b f4		 cmp	 esi, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	89 45 a0	 mov	 DWORD PTR tv197[ebp], eax
  00153	8b 45 a0	 mov	 eax, DWORD PTR tv197[ebp]
  00156	89 45 9c	 mov	 DWORD PTR tv135[ebp], eax
  00159	eb 1b		 jmp	 SHORT $L69785
$L69784:
  0015b	8b f4		 mov	 esi, esp
  0015d	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00166	3b f4		 cmp	 esi, esp
  00168	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016d	89 45 98	 mov	 DWORD PTR tv198[ebp], eax
  00170	8b 4d 98	 mov	 ecx, DWORD PTR tv198[ebp]
  00173	89 4d 9c	 mov	 DWORD PTR tv135[ebp], ecx
$L69785:
  00176	8b 55 9c	 mov	 edx, DWORD PTR tv135[ebp]
  00179	89 55 d0	 mov	 DWORD PTR __Size$68224[ebp], edx

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  0017c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0017f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00181	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00184	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00187	8b f4		 mov	 esi, esp
  00189	8b ca		 mov	 ecx, edx
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00191	3b f4		 cmp	 esi, esp
  00193	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00198	89 45 94	 mov	 DWORD PTR tv199[ebp], eax
  0019b	8b f4		 mov	 esi, esp
  0019d	8b 4d 94	 mov	 ecx, DWORD PTR tv199[ebp]
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  001a6	3b f4		 cmp	 esi, esp
  001a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ad	66 89 45 92	 mov	 WORD PTR tv200[ebp], ax
  001b1	66 8b 45 92	 mov	 ax, WORD PTR tv200[ebp]
  001b5	66 89 45 c8	 mov	 WORD PTR __Meta$68227[ebp], ax

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  001b9	eb 44		 jmp	 SHORT $L68228
$L68229:
  001bb	8b 4d d0	 mov	 ecx, DWORD PTR __Size$68224[ebp]
  001be	83 e9 01	 sub	 ecx, 1
  001c1	89 4d d0	 mov	 DWORD PTR __Size$68224[ebp], ecx
  001c4	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001c7	8b 02		 mov	 eax, DWORD PTR [edx]
  001c9	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001cc	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  001cf	8b f4		 mov	 esi, esp
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  001d7	3b f4		 cmp	 esi, esp
  001d9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001de	89 45 8c	 mov	 DWORD PTR tv201[ebp], eax
  001e1	8b f4		 mov	 esi, esp
  001e3	8b 4d 8c	 mov	 ecx, DWORD PTR tv201[ebp]
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  001ec	3b f4		 cmp	 esi, esp
  001ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f3	66 89 45 8a	 mov	 WORD PTR tv202[ebp], ax
  001f7	66 8b 4d 8a	 mov	 cx, WORD PTR tv202[ebp]
  001fb	66 89 4d c8	 mov	 WORD PTR __Meta$68227[ebp], cx
$L68228:
  001ff	83 7d d0 00	 cmp	 DWORD PTR __Size$68224[ebp], 0
  00203	0f 86 c7 00 00
	00		 jbe	 $L68230

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  00209	8b f4		 mov	 esi, esp
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00211	3b f4		 cmp	 esi, esp
  00213	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00218	66 89 45 88	 mov	 WORD PTR tv203[ebp], ax
  0021c	66 8b 55 88	 mov	 dx, WORD PTR tv203[ebp]
  00220	66 89 55 be	 mov	 WORD PTR $T69786[ebp], dx
  00224	8b f4		 mov	 esi, esp
  00226	8d 45 c8	 lea	 eax, DWORD PTR __Meta$68227[ebp]
  00229	50		 push	 eax
  0022a	8d 4d be	 lea	 ecx, DWORD PTR $T69786[ebp]
  0022d	51		 push	 ecx
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  00234	83 c4 08	 add	 esp, 8
  00237	3b f4		 cmp	 esi, esp
  00239	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023e	88 45 87	 mov	 BYTE PTR tv204[ebp], al
  00241	0f b6 55 87	 movzx	 edx, BYTE PTR tv204[ebp]
  00245	85 d2		 test	 edx, edx
  00247	74 0b		 je	 SHORT $L68232

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  00249	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0024c	83 c8 01	 or	 eax, 1
  0024f	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 450  : 				break;

  00252	eb 7c		 jmp	 SHORT $L68230
$L68232:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  00254	8b f4		 mov	 esi, esp
  00256	8d 4d c8	 lea	 ecx, DWORD PTR __Meta$68227[ebp]
  00259	51		 push	 ecx
  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  00260	83 c4 04	 add	 esp, 4
  00263	3b f4		 cmp	 esi, esp
  00265	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0026a	66 89 45 84	 mov	 WORD PTR tv205[ebp], ax
  0026e	8b f4		 mov	 esi, esp
  00270	66 8b 55 84	 mov	 dx, WORD PTR tv205[ebp]
  00274	52		 push	 edx
  00275	6a 48		 push	 72			; 00000048H
  00277	8b 4d d4	 mov	 ecx, DWORD PTR __Ctype_fac$68221[ebp]
  0027a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
  00280	3b f4		 cmp	 esi, esp
  00282	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00287	88 45 83	 mov	 BYTE PTR tv206[ebp], al
  0028a	0f b6 45 83	 movzx	 eax, BYTE PTR tv206[ebp]
  0028e	85 c0		 test	 eax, eax
  00290	74 02		 je	 SHORT $L68234

; 454  : 				break;	// whitespace, quit

  00292	eb 3c		 jmp	 SHORT $L68230
$L68234:

; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  00294	8b f4		 mov	 esi, esp
  00296	8d 4d c8	 lea	 ecx, DWORD PTR __Meta$68227[ebp]
  00299	51		 push	 ecx
  0029a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  002a0	83 c4 04	 add	 esp, 4
  002a3	3b f4		 cmp	 esi, esp
  002a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002aa	66 89 45 80	 mov	 WORD PTR tv207[ebp], ax
  002ae	8b f4		 mov	 esi, esp
  002b0	66 8b 55 80	 mov	 dx, WORD PTR tv207[ebp]
  002b4	52		 push	 edx
  002b5	6a 01		 push	 1
  002b7	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  002ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
  002c0	3b f4		 cmp	 esi, esp
  002c2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 458  : 				_Changed = true;

  002c7	c6 45 eb 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 459  : 				}

  002cb	e9 eb fe ff ff	 jmp	 $L68229
$L68230:
  002d0	eb 26		 jmp	 SHORT $L69788
$L69789:

; 460  : 		_CATCH_IO_(_Istr)

  002d2	8b f4		 mov	 esi, esp
  002d4	6a 01		 push	 1
  002d6	6a 04		 push	 4
  002d8	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  002db	8b 08		 mov	 ecx, DWORD PTR [eax]
  002dd	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  002e0	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002e3	8b ca		 mov	 ecx, edx
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  002eb	3b f4		 cmp	 esi, esp
  002ed	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f2	b8 00 00 00 00	 mov	 eax, $L69788
  002f7	c3		 ret	 0
$L69788:
  002f8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  002ff	8b f4		 mov	 esi, esp
  00301	6a 00		 push	 0
  00303	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00306	8b 08		 mov	 ecx, DWORD PTR [eax]
  00308	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0030b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0030e	8b ca		 mov	 ecx, edx
  00310	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  00316	3b f4		 cmp	 esi, esp
  00318	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 464  : 	if (!_Changed)

  0031d	0f b6 45 eb	 movzx	 eax, BYTE PTR __Changed$[ebp]
  00321	85 c0		 test	 eax, eax
  00323	75 09		 jne	 SHORT $L68236

; 465  : 		_State |= ios_base::failbit;

  00325	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00328	83 c9 02	 or	 ecx, 2
  0032b	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L68236:

; 466  : 	_Istr.setstate(_State);

  0032e	8b f4		 mov	 esi, esp
  00330	6a 00		 push	 0
  00332	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00335	52		 push	 edx
  00336	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00339	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033b	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0033e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00341	8b ca		 mov	 ecx, edx
  00343	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  00349	3b f4		 cmp	 esi, esp
  0034b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 467  : 	return (_Istr);

  00350	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00353	89 45 b8	 mov	 DWORD PTR $T69787[ebp], eax
  00356	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0035d	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00360	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00365	8b 45 b8	 mov	 eax, DWORD PTR $T69787[ebp]

; 468  : 	}

  00368	52		 push	 edx
  00369	8b cd		 mov	 ecx, ebp
  0036b	50		 push	 eax
  0036c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69798
  00372	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00377	58		 pop	 eax
  00378	5a		 pop	 edx
  00379	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0037c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00383	5f		 pop	 edi
  00384	5e		 pop	 esi
  00385	5b		 pop	 ebx
  00386	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  0038c	3b ec		 cmp	 ebp, esp
  0038e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00393	8b e5		 mov	 esp, ebp
  00395	5d		 pop	 ebp
  00396	c3		 ret	 0
$L69798:
  00397	02 00 00 00	 DD	 2
  0039b	00 00 00 00	 DD	 $L69797
$L69797:
  0039f	dc ff ff ff	 DD	 -36			; ffffffdcH
  003a3	08 00 00 00	 DD	 8
  003a7	00 00 00 00	 DD	 $L69794
  003ab	c8 ff ff ff	 DD	 -56			; ffffffc8H
  003af	02 00 00 00	 DD	 2
  003b3	00 00 00 00	 DD	 $L69795
$L69795:
  003b7	5f		 DB	 95			; 0000005fH
  003b8	4d		 DB	 77			; 0000004dH
  003b9	65		 DB	 101			; 00000065H
  003ba	74		 DB	 116			; 00000074H
  003bb	61		 DB	 97			; 00000061H
  003bc	00		 DB	 0
$L69794:
  003bd	5f		 DB	 95			; 0000005fH
  003be	4f		 DB	 79			; 0000004fH
  003bf	6b		 DB	 107			; 0000006bH
  003c0	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69790:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
$L69791:
  00008	8b f4		 mov	 esi, esp
  0000a	8d 4d c0	 lea	 ecx, DWORD PTR $T69783[ebp]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ
  00013	3b f4		 cmp	 esi, esp
  00015	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69793
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	SEGMENT
$T69811	DD	0ffffffffH
	DD	FLAT:$L69807
$T69809	DD	019930520H
	DD	01H
	DD	FLAT:$T69811
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00027	50		 push	 eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00037	8b f4		 mov	 esi, esp
  00039	8a 4d 0c	 mov	 cl, BYTE PTR __Noskip$[ebp]
  0003c	51		 push	 ecx
  0003d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 74   : 			}

  00055	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00069	5e		 pop	 esi
  0006a	83 c4 10	 add	 esp, 16			; 00000010H
  0006d	3b ec		 cmp	 ebp, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69807:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69809
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 77   : 			{	// test if _Ipfx succeeded

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   : 			return (_Ok);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 79   : 			}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
EXTRN	__imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 58   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0001e	8b f4		 mov	 esi, esp
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	85 c0		 test	 eax, eax
  0002f	74 2f		 je	 SHORT $L66503

; 60   : 				_Myistr.rdbuf()->_Unlock();

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003d	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00040	8b f4		 mov	 esi, esp
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b f4		 mov	 esi, esp
  00051	8b c8		 mov	 ecx, eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L66503:

; 61   : 			}

  00060	5e		 pop	 esi
  00061	83 c4 04	 add	 esp, 4
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	__imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00015	89 08		 mov	 DWORD PTR [eax], ecx

; 53   : 			if (_Myistr.rdbuf() != 0)

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00026	8b f4		 mov	 esi, esp
  00028	8b c8		 mov	 ecx, eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	85 c0		 test	 eax, eax
  00039	74 2f		 je	 SHORT $L67500

; 54   : 				_Myistr.rdbuf()->_Lock();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00047	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004a	8b f4		 mov	 esi, esp
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b f4		 mov	 esi, esp
  0005b	8b c8		 mov	 ecx, eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67500:

; 55   : 			}

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	5e		 pop	 esi
  0006e	83 c4 04	 add	 esp, 4
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69828	DD	0ffffffffH
	DD	FLAT:$L69820
$T69822	DD	019930520H
	DD	01H
	DD	FLAT:$T69828
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T69819 = -64						; size = 4
$T69818 = -60						; size = 12
__Pfmod$68094 = -48					; size = 4
__Pf$ = -44						; size = 4
__Id$ = -40						; size = 4
__Psave$ = -32						; size = 4
__Lock$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 34	 sub	 esp, 52			; 00000034H
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00020	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0002c	8b f4		 mov	 esi, esp
  0002e	6a 00		 push	 0
  00030	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  0004c	89 45 e0	 mov	 DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  0004f	8b f4		 mov	 esi, esp
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	89 45 d8	 mov	 DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00067	8b f4		 mov	 esi, esp
  00069	8b 4d d8	 mov	 ecx, DWORD PTR __Id$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	89 45 d4	 mov	 DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

  00080	83 7d d4 00	 cmp	 DWORD PTR __Pf$[ebp], 0
  00084	74 05		 je	 SHORT $L68085

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  00086	e9 86 00 00 00	 jmp	 $L68086
$L68085:
  0008b	83 7d e0 00	 cmp	 DWORD PTR __Psave$[ebp], 0
  0008f	74 08		 je	 SHORT $L68087

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

  00091	8b 55 e0	 mov	 edx, DWORD PTR __Psave$[ebp]
  00094	89 55 d4	 mov	 DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00097	eb 78		 jmp	 SHORT $L68086
$L68087:
  00099	8b f4		 mov	 esi, esp
  0009b	8d 45 e0	 lea	 eax, DWORD PTR __Psave$[ebp]
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z
  000a5	83 c4 04	 add	 esp, 4
  000a8	3b f4		 cmp	 esi, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	83 f8 ff	 cmp	 eax, -1
  000b2	75 25		 jne	 SHORT $L68090

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  000b4	8b f4		 mov	 esi, esp
  000b6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  000bb	8d 4d c4	 lea	 ecx, DWORD PTR $T69818[ebp]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  000c4	3b f4		 cmp	 esi, esp
  000c6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cb	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  000d0	8d 4d c4	 lea	 ecx, DWORD PTR $T69818[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 __CxxThrowException@8
$L68090:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  000d9	8b 55 e0	 mov	 edx, DWORD PTR __Psave$[ebp]
  000dc	89 55 d4	 mov	 DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  000df	8b 45 e0	 mov	 eax, DWORD PTR __Psave$[ebp]
  000e2	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000e7	8b 4d e0	 mov	 ecx, DWORD PTR __Psave$[ebp]
  000ea	89 4d d0	 mov	 DWORD PTR __Pfmod$68094[ebp], ecx

; 342  : 		_Pfmod->_Incref();

  000ed	8b f4		 mov	 esi, esp
  000ef	8b 4d d0	 mov	 ecx, DWORD PTR __Pfmod$68094[ebp]
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ
  000f8	3b f4		 cmp	 esi, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 343  : 		_Pfmod->_Register();

  000ff	8b f4		 mov	 esi, esp
  00101	8b 4d d0	 mov	 ecx, DWORD PTR __Pfmod$68094[ebp]
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
  0010a	3b f4		 cmp	 esi, esp
  0010c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L68086:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00111	8b 55 d4	 mov	 edx, DWORD PTR __Pf$[ebp]
  00114	89 55 c0	 mov	 DWORD PTR $T69819[ebp], edx
  00117	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0011e	8b f4		 mov	 esi, esp
  00120	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00129	3b f4		 cmp	 esi, esp
  0012b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00130	8b 45 c0	 mov	 eax, DWORD PTR $T69819[ebp]
$L69817:

; 347  : 	}

  00133	52		 push	 edx
  00134	8b cd		 mov	 ecx, ebp
  00136	50		 push	 eax
  00137	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69827
  0013d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00142	58		 pop	 eax
  00143	5a		 pop	 edx
  00144	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00147	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi
  00150	83 c4 40	 add	 esp, 64			; 00000040H
  00153	3b ec		 cmp	 ebp, esp
  00155	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
$L69827:
  0015e	02 00 00 00	 DD	 2
  00162	00 00 00 00	 DD	 $L69826
$L69826:
  00166	ec ff ff ff	 DD	 -20			; ffffffecH
  0016a	04 00 00 00	 DD	 4
  0016e	00 00 00 00	 DD	 $L69823
  00172	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00176	04 00 00 00	 DD	 4
  0017a	00 00 00 00	 DD	 $L69824
$L69824:
  0017e	5f		 DB	 95			; 0000005fH
  0017f	50		 DB	 80			; 00000050H
  00180	73		 DB	 115			; 00000073H
  00181	61		 DB	 97			; 00000061H
  00182	76		 DB	 118			; 00000076H
  00183	65		 DB	 101			; 00000065H
  00184	00		 DB	 0
$L69823:
  00185	5f		 DB	 95			; 0000005fH
  00186	4c		 DB	 76			; 0000004cH
  00187	6f		 DB	 111			; 0000006fH
  00188	63		 DB	 99			; 00000063H
  00189	6b		 DB	 107			; 0000006bH
  0018a	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69820:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69822
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00004	8b f4		 mov	 esi, esp
  00006	6a 0a		 push	 10			; 0000000aH
  00008	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0000b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00010	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00013	8b ca		 mov	 ecx, edx
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  0001b	3b f4		 cmp	 esi, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	50		 push	 eax
  00023	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	}

  00033	5e		 pop	 esi
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
EXTRN	__imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
EXTRN	__imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69847	DD	0ffffffffH
	DD	FLAT:$L69838
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T69849	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L69837
$T69848	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T69849
$T69840	DD	019930520H
	DD	03H
	DD	FLAT:$T69847
	DD	01H
	DD	FLAT:$T69848
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT
tv175 = -110						; size = 2
tv174 = -108						; size = 4
tv173 = -104						; size = 4
tv172 = -100						; size = 4
tv171 = -94						; size = 1
tv170 = -93						; size = 1
tv169 = -92						; size = 2
tv168 = -90						; size = 2
tv167 = -88						; size = 4
tv166 = -82						; size = 2
tv165 = -80						; size = 4
tv65 = -74						; size = 2
$T69835 = -72						; size = 4
$T69834 = -66						; size = 2
__Meta$68247 = -60					; size = 2
__Metadelim$68246 = -48					; size = 2
__Ok$ = -36						; size = 8
__Changed$ = -21					; size = 1
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 2
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 60	 sub	 esp, 96			; 00000060H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8d 7d 90	 lea	 edi, DWORD PTR [ebp-112]
  00022	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;

  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 480  : 	bool _Changed = false;

  00038	c6 45 eb 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0003c	6a 01		 push	 1
  0003e	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00041	50		 push	 eax
  00042	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 482  : 
; 483  : 	if (_Ok)

  00051	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00054	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  00059	0f b6 c8	 movzx	 ecx, al
  0005c	85 c9		 test	 ecx, ecx
  0005e	0f 84 04 02 00
	00		 je	 $L69836

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN

  00064	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 486  : 		_Str.erase();

  00068	8b f4		 mov	 esi, esp
  0006a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  00070	8b 02		 mov	 eax, DWORD PTR [edx]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);

  00085	8b f4		 mov	 esi, esp
  00087	8d 4d 10	 lea	 ecx, DWORD PTR __Delim$[ebp]
  0008a	51		 push	 ecx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
  00091	83 c4 04	 add	 esp, 4
  00094	3b f4		 cmp	 esi, esp
  00096	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009b	66 89 45 b6	 mov	 WORD PTR tv65[ebp], ax
  0009f	66 8b 55 b6	 mov	 dx, WORD PTR tv65[ebp]
  000a3	66 89 55 d0	 mov	 WORD PTR __Metadelim$68246[ebp], dx

; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  000a7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000af	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000b2	8b f4		 mov	 esi, esp
  000b4	8b ca		 mov	 ecx, edx
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c3	89 45 b0	 mov	 DWORD PTR tv165[ebp], eax
  000c6	8b f4		 mov	 esi, esp
  000c8	8b 4d b0	 mov	 ecx, DWORD PTR tv165[ebp]
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000d1	3b f4		 cmp	 esi, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d8	66 89 45 ae	 mov	 WORD PTR tv166[ebp], ax
  000dc	66 8b 45 ae	 mov	 ax, WORD PTR tv166[ebp]
  000e0	66 89 45 c4	 mov	 WORD PTR __Meta$68247[ebp], ax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  000e4	eb 3b		 jmp	 SHORT $L68248
$L68249:
  000e6	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000e9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000ee	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000f1	8b f4		 mov	 esi, esp
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	89 45 a8	 mov	 DWORD PTR tv167[ebp], eax
  00103	8b f4		 mov	 esi, esp
  00105	8b 4d a8	 mov	 ecx, DWORD PTR tv167[ebp]
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  0010e	3b f4		 cmp	 esi, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00115	66 89 45 a6	 mov	 WORD PTR tv168[ebp], ax
  00119	66 8b 45 a6	 mov	 ax, WORD PTR tv168[ebp]
  0011d	66 89 45 c4	 mov	 WORD PTR __Meta$68247[ebp], ax
$L68248:

; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00121	8b f4		 mov	 esi, esp
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00129	3b f4		 cmp	 esi, esp
  0012b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00130	66 89 45 a4	 mov	 WORD PTR tv169[ebp], ax
  00134	66 8b 4d a4	 mov	 cx, WORD PTR tv169[ebp]
  00138	66 89 4d be	 mov	 WORD PTR $T69834[ebp], cx
  0013c	8b f4		 mov	 esi, esp
  0013e	8d 55 c4	 lea	 edx, DWORD PTR __Meta$68247[ebp]
  00141	52		 push	 edx
  00142	8d 45 be	 lea	 eax, DWORD PTR $T69834[ebp]
  00145	50		 push	 eax
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  0014c	83 c4 08	 add	 esp, 8
  0014f	3b f4		 cmp	 esi, esp
  00151	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00156	88 45 a3	 mov	 BYTE PTR tv170[ebp], al
  00159	0f b6 4d a3	 movzx	 ecx, BYTE PTR tv170[ebp]
  0015d	85 c9		 test	 ecx, ecx
  0015f	74 0e		 je	 SHORT $L68252

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  00161	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00164	83 ca 01	 or	 edx, 1
  00167	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 495  : 				break;

  0016a	e9 d3 00 00 00	 jmp	 $L68250
$L68252:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  0016f	8b f4		 mov	 esi, esp
  00171	8d 45 d0	 lea	 eax, DWORD PTR __Metadelim$68246[ebp]
  00174	50		 push	 eax
  00175	8d 4d c4	 lea	 ecx, DWORD PTR __Meta$68247[ebp]
  00178	51		 push	 ecx
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  0017f	83 c4 08	 add	 esp, 8
  00182	3b f4		 cmp	 esi, esp
  00184	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00189	88 45 a2	 mov	 BYTE PTR tv171[ebp], al
  0018c	0f b6 55 a2	 movzx	 edx, BYTE PTR tv171[ebp]
  00190	85 d2		 test	 edx, edx
  00192	74 37		 je	 SHORT $L68254

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;

  00194	c6 45 eb 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 500  : 				_Istr.rdbuf()->sbumpc();

  00198	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0019b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  001a0	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001a3	8b f4		 mov	 esi, esp
  001a5	8b ca		 mov	 ecx, edx
  001a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  001ad	3b f4		 cmp	 esi, esp
  001af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b4	89 45 9c	 mov	 DWORD PTR tv172[ebp], eax
  001b7	8b f4		 mov	 esi, esp
  001b9	8b 4d 9c	 mov	 ecx, DWORD PTR tv172[ebp]
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  001c2	3b f4		 cmp	 esi, esp
  001c4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 501  : 				break;

  001c9	eb 77		 jmp	 SHORT $L68250
$L68254:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  001cb	8b f4		 mov	 esi, esp
  001cd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  001d6	3b f4		 cmp	 esi, esp
  001d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001dd	89 45 98	 mov	 DWORD PTR tv173[ebp], eax
  001e0	8b f4		 mov	 esi, esp
  001e2	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  001eb	3b f4		 cmp	 esi, esp
  001ed	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f2	89 45 94	 mov	 DWORD PTR tv174[ebp], eax
  001f5	8b 45 98	 mov	 eax, DWORD PTR tv173[ebp]
  001f8	3b 45 94	 cmp	 eax, DWORD PTR tv174[ebp]
  001fb	77 0b		 ja	 SHORT $L68256

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  001fd	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  00200	83 c9 02	 or	 ecx, 2
  00203	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 506  : 				break;

  00206	eb 3a		 jmp	 SHORT $L68250
$L68256:

; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  00208	8b f4		 mov	 esi, esp
  0020a	8d 55 c4	 lea	 edx, DWORD PTR __Meta$68247[ebp]
  0020d	52		 push	 edx
  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
  00214	83 c4 04	 add	 esp, 4
  00217	3b f4		 cmp	 esi, esp
  00219	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0021e	66 89 45 92	 mov	 WORD PTR tv175[ebp], ax
  00222	8b f4		 mov	 esi, esp
  00224	66 8b 45 92	 mov	 ax, WORD PTR tv175[ebp]
  00228	50		 push	 eax
  00229	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
  00232	3b f4		 cmp	 esi, esp
  00234	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 511  : 				_Changed = true;

  00239	c6 45 eb 01	 mov	 BYTE PTR __Changed$[ebp], 1

; 512  : 				}

  0023d	e9 a4 fe ff ff	 jmp	 $L68249
$L68250:
  00242	eb 24		 jmp	 SHORT $L69836
$L69837:

; 513  : 		_CATCH_IO_(_Istr)

  00244	8b f4		 mov	 esi, esp
  00246	6a 01		 push	 1
  00248	6a 04		 push	 4
  0024a	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0024d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024f	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00252	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  0025b	3b f4		 cmp	 esi, esp
  0025d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00262	b8 00 00 00 00	 mov	 eax, $L69836
  00267	c3		 ret	 0
$L69836:
  00268	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  0026f	0f b6 45 eb	 movzx	 eax, BYTE PTR __Changed$[ebp]
  00273	85 c0		 test	 eax, eax
  00275	75 09		 jne	 SHORT $L68258

; 517  : 		_State |= ios_base::failbit;

  00277	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  0027a	83 c9 02	 or	 ecx, 2
  0027d	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx
$L68258:

; 518  : 	_Istr.setstate(_State);

  00280	8b f4		 mov	 esi, esp
  00282	6a 00		 push	 0
  00284	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00287	52		 push	 edx
  00288	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0028b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00290	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00293	8b ca		 mov	 ecx, edx
  00295	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  0029b	3b f4		 cmp	 esi, esp
  0029d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 519  : 	return (_Istr);

  002a2	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  002a5	89 45 b8	 mov	 DWORD PTR $T69835[ebp], eax
  002a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  002af	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  002b2	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  002b7	8b 45 b8	 mov	 eax, DWORD PTR $T69835[ebp]

; 520  : 	}

  002ba	52		 push	 edx
  002bb	8b cd		 mov	 ecx, ebp
  002bd	50		 push	 eax
  002be	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69846
  002c4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002c9	58		 pop	 eax
  002ca	5a		 pop	 edx
  002cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  002d5	5f		 pop	 edi
  002d6	5e		 pop	 esi
  002d7	5b		 pop	 ebx
  002d8	83 c4 70	 add	 esp, 112		; 00000070H
  002db	3b ec		 cmp	 ebp, esp
  002dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e2	8b e5		 mov	 esp, ebp
  002e4	5d		 pop	 ebp
  002e5	c3		 ret	 0
$L69846:
  002e6	03 00 00 00	 DD	 3
  002ea	00 00 00 00	 DD	 $L69845
$L69845:
  002ee	dc ff ff ff	 DD	 -36			; ffffffdcH
  002f2	08 00 00 00	 DD	 8
  002f6	00 00 00 00	 DD	 $L69841
  002fa	d0 ff ff ff	 DD	 -48			; ffffffd0H
  002fe	02 00 00 00	 DD	 2
  00302	00 00 00 00	 DD	 $L69842
  00306	c4 ff ff ff	 DD	 -60			; ffffffc4H
  0030a	02 00 00 00	 DD	 2
  0030e	00 00 00 00	 DD	 $L69843
$L69843:
  00312	5f		 DB	 95			; 0000005fH
  00313	4d		 DB	 77			; 0000004dH
  00314	65		 DB	 101			; 00000065H
  00315	74		 DB	 116			; 00000074H
  00316	61		 DB	 97			; 00000061H
  00317	00		 DB	 0
$L69842:
  00318	5f		 DB	 95			; 0000005fH
  00319	4d		 DB	 77			; 0000004dH
  0031a	65		 DB	 101			; 00000065H
  0031b	74		 DB	 116			; 00000074H
  0031c	61		 DB	 97			; 00000061H
  0031d	64		 DB	 100			; 00000064H
  0031e	65		 DB	 101			; 00000065H
  0031f	6c		 DB	 108			; 0000006cH
  00320	69		 DB	 105			; 00000069H
  00321	6d		 DB	 109			; 0000006dH
  00322	00		 DB	 0
$L69841:
  00323	5f		 DB	 95			; 0000005fH
  00324	4f		 DB	 79			; 0000004fH
  00325	6b		 DB	 107			; 0000006bH
  00326	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69838:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
__ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69840
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
EXTRN	__imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ:NEAR
EXTRN	__imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z:NEAR
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69871	DD	0ffffffffH
	DD	FLAT:$L69864
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T69873	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L69863
$T69872	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T69873
$T69866	DD	019930520H
	DD	03H
	DD	FLAT:$T69871
	DD	01H
	DD	FLAT:$T69872
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv221 = -113						; size = 1
tv220 = -112						; size = 2
tv219 = -110						; size = 2
tv218 = -108						; size = 4
tv217 = -104						; size = 2
tv216 = -101						; size = 1
tv215 = -100						; size = 2
tv214 = -98						; size = 2
tv213 = -96						; size = 4
tv212 = -92						; size = 4
tv211 = -85						; size = 1
tv210 = -84						; size = 2
tv209 = -82						; size = 2
tv208 = -80						; size = 4
tv207 = -74						; size = 2
tv83 = -72						; size = 4
tv81 = -68						; size = 4
$T69861 = -64						; size = 4
$T69860 = -60						; size = 2
$T69859 = -58						; size = 2
$T69858 = -56						; size = 2
$T69857 = -54						; size = 2
$T69856 = -52						; size = 2
$T69855 = -50						; size = 2
__Count$68281 = -48					; size = 4
__Ok$ = -40						; size = 8
__Pad$ = -28						; size = 4
__Size$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 64	 sub	 esp, 100		; 00000064H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8d 7d 8c	 lea	 edi, DWORD PTR [ebp-116]
  00022	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;

  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 544  : 	_Mysizt _Size = _Str.size();

  00038	8b f4		 mov	 esi, esp
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  00043	3b f4		 cmp	 esi, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	89 45 e8	 mov	 DWORD PTR __Size$[ebp], eax

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00055	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00058	8b f4		 mov	 esi, esp
  0005a	8b ca		 mov	 ecx, edx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	85 c0		 test	 eax, eax
  0006b	7e 45		 jle	 SHORT $L69853
  0006d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00075	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00078	8b f4		 mov	 esi, esp
  0007a	8b ca		 mov	 ecx, edx
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	3b 45 e8	 cmp	 eax, DWORD PTR __Size$[ebp]
  0008c	76 24		 jbe	 SHORT $L69853
  0008e	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00091	8b 08		 mov	 ecx, DWORD PTR [eax]
  00093	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00096	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00099	8b f4		 mov	 esi, esp
  0009b	8b ca		 mov	 ecx, edx
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
  000a3	3b f4		 cmp	 esi, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	2b 45 e8	 sub	 eax, DWORD PTR __Size$[ebp]
  000ad	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  000b0	eb 07		 jmp	 SHORT $L69854
$L69853:
  000b2	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$L69854:
  000b9	8b 45 bc	 mov	 eax, DWORD PTR tv81[ebp]
  000bc	89 45 e4	 mov	 DWORD PTR __Pad$[ebp], eax

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  000bf	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c2	51		 push	 ecx
  000c3	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000c6	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  000cb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 548  : 
; 549  : 	if (!_Ok)

  000d2	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000d5	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
  000da	0f b6 d0	 movzx	 edx, al
  000dd	85 d2		 test	 edx, edx
  000df	75 0e		 jne	 SHORT $L68270

; 550  : 		_State |= ios_base::badbit;

  000e1	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  000e4	83 c8 04	 or	 eax, 4
  000e7	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 551  : 	else

  000ea	e9 dd 02 00 00	 jmp	 $L69862
$L68270:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN

  000ef	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000f3	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000f6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000fb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000fe	8b f4		 mov	 esi, esp
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  00106	3b f4		 cmp	 esi, esp
  00108	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010d	89 45 b8	 mov	 DWORD PTR tv83[ebp], eax
  00110	8b 45 b8	 mov	 eax, DWORD PTR tv83[ebp]
  00113	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00118	83 f8 40	 cmp	 eax, 64			; 00000040H
  0011b	0f 84 c3 00 00
	00		 je	 $L68273

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00121	eb 09		 jmp	 SHORT $L68274
$L68275:
  00123	8b 4d e4	 mov	 ecx, DWORD PTR __Pad$[ebp]
  00126	83 e9 01	 sub	 ecx, 1
  00129	89 4d e4	 mov	 DWORD PTR __Pad$[ebp], ecx
$L68274:
  0012c	83 7d e4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00130	0f 86 ae 00 00
	00		 jbe	 $L68273

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  00136	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00139	8b 02		 mov	 eax, DWORD PTR [edx]
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0013e	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00141	8b f4		 mov	 esi, esp
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  00149	3b f4		 cmp	 esi, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	66 89 45 b6	 mov	 WORD PTR tv207[ebp], ax
  00154	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00157	8b 11		 mov	 edx, DWORD PTR [ecx]
  00159	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0015c	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0015f	8b f4		 mov	 esi, esp
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00167	3b f4		 cmp	 esi, esp
  00169	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016e	89 45 b0	 mov	 DWORD PTR tv208[ebp], eax
  00171	8b f4		 mov	 esi, esp
  00173	66 8b 45 b6	 mov	 ax, WORD PTR tv207[ebp]
  00177	50		 push	 eax
  00178	8b 4d b0	 mov	 ecx, DWORD PTR tv208[ebp]
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00181	3b f4		 cmp	 esi, esp
  00183	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00188	66 89 45 ae	 mov	 WORD PTR tv209[ebp], ax
  0018c	66 8b 4d ae	 mov	 cx, WORD PTR tv209[ebp]
  00190	66 89 4d ce	 mov	 WORD PTR $T69855[ebp], cx
  00194	8b f4		 mov	 esi, esp
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  0019c	3b f4		 cmp	 esi, esp
  0019e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a3	66 89 45 ac	 mov	 WORD PTR tv210[ebp], ax
  001a7	66 8b 55 ac	 mov	 dx, WORD PTR tv210[ebp]
  001ab	66 89 55 cc	 mov	 WORD PTR $T69856[ebp], dx
  001af	8b f4		 mov	 esi, esp
  001b1	8d 45 ce	 lea	 eax, DWORD PTR $T69855[ebp]
  001b4	50		 push	 eax
  001b5	8d 4d cc	 lea	 ecx, DWORD PTR $T69856[ebp]
  001b8	51		 push	 ecx
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  001bf	83 c4 08	 add	 esp, 8
  001c2	3b f4		 cmp	 esi, esp
  001c4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c9	88 45 ab	 mov	 BYTE PTR tv211[ebp], al
  001cc	0f b6 55 ab	 movzx	 edx, BYTE PTR tv211[ebp]
  001d0	85 d2		 test	 edx, edx
  001d2	74 0b		 je	 SHORT $L68279

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  001d4	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  001d7	83 c8 04	 or	 eax, 4
  001da	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 560  : 					break;

  001dd	eb 05		 jmp	 SHORT $L68273
$L68279:

; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  001df	e9 3f ff ff ff	 jmp	 $L68275
$L68273:
  001e4	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  001e8	0f 85 c9 00 00
	00		 jne	 $L68280

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  001ee	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Count$68281[ebp], 0
  001f5	eb 09		 jmp	 SHORT $L68282
$L68283:
  001f7	8b 4d d0	 mov	 ecx, DWORD PTR __Count$68281[ebp]
  001fa	83 c1 01	 add	 ecx, 1
  001fd	89 4d d0	 mov	 DWORD PTR __Count$68281[ebp], ecx
$L68282:
  00200	8b 55 d0	 mov	 edx, DWORD PTR __Count$68281[ebp]
  00203	3b 55 e8	 cmp	 edx, DWORD PTR __Size$[ebp]
  00206	0f 83 ab 00 00
	00		 jae	 $L68280

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  0020c	8b f4		 mov	 esi, esp
  0020e	8b 45 d0	 mov	 eax, DWORD PTR __Count$68281[ebp]
  00211	50		 push	 eax
  00212	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
  0021b	3b f4		 cmp	 esi, esp
  0021d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00222	89 45 a4	 mov	 DWORD PTR tv212[ebp], eax
  00225	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00228	8b 11		 mov	 edx, DWORD PTR [ecx]
  0022a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0022d	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00230	8b f4		 mov	 esi, esp
  00232	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00238	3b f4		 cmp	 esi, esp
  0023a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023f	89 45 a0	 mov	 DWORD PTR tv213[ebp], eax
  00242	8b f4		 mov	 esi, esp
  00244	8b 45 a4	 mov	 eax, DWORD PTR tv212[ebp]
  00247	66 8b 08	 mov	 cx, WORD PTR [eax]
  0024a	51		 push	 ecx
  0024b	8b 4d a0	 mov	 ecx, DWORD PTR tv213[ebp]
  0024e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00254	3b f4		 cmp	 esi, esp
  00256	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025b	66 89 45 9e	 mov	 WORD PTR tv214[ebp], ax
  0025f	66 8b 55 9e	 mov	 dx, WORD PTR tv214[ebp]
  00263	66 89 55 ca	 mov	 WORD PTR $T69857[ebp], dx
  00267	8b f4		 mov	 esi, esp
  00269	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  0026f	3b f4		 cmp	 esi, esp
  00271	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00276	66 89 45 9c	 mov	 WORD PTR tv215[ebp], ax
  0027a	66 8b 45 9c	 mov	 ax, WORD PTR tv215[ebp]
  0027e	66 89 45 c8	 mov	 WORD PTR $T69858[ebp], ax
  00282	8b f4		 mov	 esi, esp
  00284	8d 4d ca	 lea	 ecx, DWORD PTR $T69857[ebp]
  00287	51		 push	 ecx
  00288	8d 55 c8	 lea	 edx, DWORD PTR $T69858[ebp]
  0028b	52		 push	 edx
  0028c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  00292	83 c4 08	 add	 esp, 8
  00295	3b f4		 cmp	 esi, esp
  00297	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0029c	88 45 9b	 mov	 BYTE PTR tv216[ebp], al
  0029f	0f b6 45 9b	 movzx	 eax, BYTE PTR tv216[ebp]
  002a3	85 c0		 test	 eax, eax
  002a5	74 0b		 je	 SHORT $L68287

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  002a7	8b 4d ec	 mov	 ecx, DWORD PTR __State$[ebp]
  002aa	83 c9 04	 or	 ecx, 4
  002ad	89 4d ec	 mov	 DWORD PTR __State$[ebp], ecx

; 569  : 					break;

  002b0	eb 05		 jmp	 SHORT $L68280
$L68287:

; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  002b2	e9 40 ff ff ff	 jmp	 $L68283
$L68280:
  002b7	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  002bb	0f 85 c7 00 00
	00		 jne	 $L68288

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  002c1	eb 09		 jmp	 SHORT $L68289
$L68290:
  002c3	8b 55 e4	 mov	 edx, DWORD PTR __Pad$[ebp]
  002c6	83 ea 01	 sub	 edx, 1
  002c9	89 55 e4	 mov	 DWORD PTR __Pad$[ebp], edx
$L68289:
  002cc	83 7d e4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  002d0	0f 86 b2 00 00
	00		 jbe	 $L68288

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  002d6	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002db	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002de	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002e1	8b f4		 mov	 esi, esp
  002e3	8b ca		 mov	 ecx, edx
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
  002eb	3b f4		 cmp	 esi, esp
  002ed	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f2	66 89 45 98	 mov	 WORD PTR tv217[ebp], ax
  002f6	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002fb	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002fe	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00301	8b f4		 mov	 esi, esp
  00303	8b ca		 mov	 ecx, edx
  00305	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  0030b	3b f4		 cmp	 esi, esp
  0030d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00312	89 45 94	 mov	 DWORD PTR tv218[ebp], eax
  00315	8b f4		 mov	 esi, esp
  00317	66 8b 45 98	 mov	 ax, WORD PTR tv217[ebp]
  0031b	50		 push	 eax
  0031c	8b 4d 94	 mov	 ecx, DWORD PTR tv218[ebp]
  0031f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00325	3b f4		 cmp	 esi, esp
  00327	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0032c	66 89 45 92	 mov	 WORD PTR tv219[ebp], ax
  00330	66 8b 4d 92	 mov	 cx, WORD PTR tv219[ebp]
  00334	66 89 4d c6	 mov	 WORD PTR $T69859[ebp], cx
  00338	8b f4		 mov	 esi, esp
  0033a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eof@?$char_traits@_W@std@@SAGXZ
  00340	3b f4		 cmp	 esi, esp
  00342	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00347	66 89 45 90	 mov	 WORD PTR tv220[ebp], ax
  0034b	66 8b 55 90	 mov	 dx, WORD PTR tv220[ebp]
  0034f	66 89 55 c4	 mov	 WORD PTR $T69860[ebp], dx
  00353	8b f4		 mov	 esi, esp
  00355	8d 45 c6	 lea	 eax, DWORD PTR $T69859[ebp]
  00358	50		 push	 eax
  00359	8d 4d c4	 lea	 ecx, DWORD PTR $T69860[ebp]
  0035c	51		 push	 ecx
  0035d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
  00363	83 c4 08	 add	 esp, 8
  00366	3b f4		 cmp	 esi, esp
  00368	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0036d	88 45 8f	 mov	 BYTE PTR tv221[ebp], al
  00370	0f b6 55 8f	 movzx	 edx, BYTE PTR tv221[ebp]
  00374	85 d2		 test	 edx, edx
  00376	74 0b		 je	 SHORT $L68294

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  00378	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  0037b	83 c8 04	 or	 eax, 4
  0037e	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 578  : 					break;

  00381	eb 05		 jmp	 SHORT $L68288
$L68294:

; 579  : 					}
; 580  : 		_Ostr.width(0);

  00383	e9 3b ff ff ff	 jmp	 $L68290
$L68288:
  00388	8b f4		 mov	 esi, esp
  0038a	6a 00		 push	 0
  0038c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0038f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00391	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00394	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00397	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
  0039d	3b f4		 cmp	 esi, esp
  0039f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a4	eb 26		 jmp	 SHORT $L69862
$L69863:

; 581  : 		_CATCH_IO_(_Ostr)

  003a6	8b f4		 mov	 esi, esp
  003a8	6a 01		 push	 1
  003aa	6a 04		 push	 4
  003ac	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003af	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b1	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  003b4	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  003b7	8b ca		 mov	 ecx, edx
  003b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  003bf	3b f4		 cmp	 esi, esp
  003c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c6	b8 00 00 00 00	 mov	 eax, $L69862
  003cb	c3		 ret	 0
$L69862:
  003cc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  003d3	8b f4		 mov	 esi, esp
  003d5	6a 00		 push	 0
  003d7	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  003da	50		 push	 eax
  003db	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003de	8b 11		 mov	 edx, DWORD PTR [ecx]
  003e0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003e3	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  003e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
  003ec	3b f4		 cmp	 esi, esp
  003ee	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 585  : 	return (_Ostr);

  003f3	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003f6	89 45 c0	 mov	 DWORD PTR $T69861[ebp], eax
  003f9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00400	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00403	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00408	8b 45 c0	 mov	 eax, DWORD PTR $T69861[ebp]

; 586  : 	}

  0040b	52		 push	 edx
  0040c	8b cd		 mov	 ecx, ebp
  0040e	50		 push	 eax
  0040f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $L69870
  00415	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0041a	58		 pop	 eax
  0041b	5a		 pop	 edx
  0041c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0041f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00426	5f		 pop	 edi
  00427	5e		 pop	 esi
  00428	5b		 pop	 ebx
  00429	83 c4 74	 add	 esp, 116		; 00000074H
  0042c	3b ec		 cmp	 ebp, esp
  0042e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00433	8b e5		 mov	 esp, ebp
  00435	5d		 pop	 ebp
  00436	c3		 ret	 0
$L69870:
  00437	01 00 00 00	 DD	 1
  0043b	00 00 00 00	 DD	 $L69869
$L69869:
  0043f	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00443	08 00 00 00	 DD	 8
  00447	00 00 00 00	 DD	 $L69867
$L69867:
  0044b	5f		 DB	 95			; 0000005fH
  0044c	4f		 DB	 79			; 0000004fH
  0044d	6b		 DB	 107			; 0000006bH
  0044e	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69864:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69866
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ:NEAR
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T69881	DD	0ffffffffH
	DD	FLAT:$L69877
$T69879	DD	019930520H
	DD	01H
	DD	FLAT:$T69881
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00027	50		 push	 eax
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0003f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00042	8b f4		 mov	 esi, esp
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	0f b6 c0	 movzx	 eax, al
  00054	85 c0		 test	 eax, eax
  00056	74 4b		 je	 SHORT $L67514
  00058	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0005b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00060	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00063	8b f4		 mov	 esi, esp
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	85 c0		 test	 eax, eax
  00074	74 2d		 je	 SHORT $L67514

; 90   : 				_Ostr.tie()->flush();

  00076	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0007e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00081	8b f4		 mov	 esi, esp
  00083	8b ca		 mov	 ecx, edx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
  0008b	3b f4		 cmp	 esi, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b f4		 mov	 esi, esp
  00094	8b c8		 mov	 ecx, eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  0009c	3b f4		 cmp	 esi, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67514:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  000a3	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000ab	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000ae	8b f4		 mov	 esi, esp
  000b0	8b ca		 mov	 ecx, edx
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  000b8	3b f4		 cmp	 esi, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 92   : 			}

  000c5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000d9	5e		 pop	 esi
  000da	83 c4 10	 add	 esp, 16			; 00000010H
  000dd	3b ec		 cmp	 ebp, esp
  000df	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69877:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69879
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T69889	DD	0ffffffffH
	DD	FLAT:$L69885
$T69887	DD	019930520H
	DD	01H
	DD	FLAT:$T69889
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  0002b	8b f4		 mov	 esi, esp
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00033	3b f4		 cmp	 esi, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	85 c0		 test	 eax, eax
  0003f	75 14		 jne	 SHORT $L67516

; 99   : 				this->_Myostr._Osfx();

  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00046	8b f4		 mov	 esi, esp
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67516:

; 100  : 			}

  00055	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006e	5e		 pop	 esi
  0006f	83 c4 10	 add	 esp, 16			; 00000010H
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69885:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69887
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 110  : 			}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00015	89 08		 mov	 DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  00026	8b f4		 mov	 esi, esp
  00028	8b c8		 mov	 ecx, eax
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00030	3b f4		 cmp	 esi, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	85 c0		 test	 eax, eax
  00039	74 2f		 je	 SHORT $L67777

; 70   : 				_Myostr.rdbuf()->_Lock();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00047	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004a	8b f4		 mov	 esi, esp
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00052	3b f4		 cmp	 esi, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b f4		 mov	 esi, esp
  0005b	8b c8		 mov	 ecx, eax
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67777:

; 71   : 			}

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	5e		 pop	 esi
  0006e	83 c4 04	 add	 esp, 4
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0001e	8b f4		 mov	 esi, esp
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00026	3b f4		 cmp	 esi, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	85 c0		 test	 eax, eax
  0002f	74 2f		 je	 SHORT $L67780

; 76   : 				_Myostr.rdbuf()->_Unlock();

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003d	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00040	8b f4		 mov	 esi, esp
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b f4		 mov	 esi, esp
  00051	8b c8		 mov	 ecx, eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$L67780:

; 77   : 			}

  00060	5e		 pop	 esi
  00061	83 c4 04	 add	 esp, 4
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
END
